<bigarchive>
<archive relative="****phantomglobalvars****">
</archive>
<archive relative = "globals.xml" vhdlpkg="chip_cfg_pkg">

  
  <var name="NB_BITS_ADDR" value="28" ><comment>AHB Address bus size</comment></var>
  <var name="SYS_IFC_NB_STD_CHANNEL" value="8" >
    <comment>System Ifc Number of generic channel
    </comment>
  </var>
  <var name="BB_IFC_NB_STD_CHANNEL" value="3" >
    <comment>BB Ifc Number of generic channel
    </comment>
  </var>


  
  
  <enum name="Sys_Master_Id">
    <entry name="SYS_MID_DUMMY"/>
    <bound name="SYS_MID_RR_Start"><comment>After this starts the Round Robin Pool</comment></bound>
    <entry name="SYS_MID_CM4I"/>
    <entry name="SYS_MID_CM4D"/>
    <entry name="SYS_MID_CM4S"/>
    <entry name="SYS_MID_DMA"/>
    <entry name="SYS_MID_AES"/>
    <entry name="SYS_MID_LZMA"/>
    <entry name="SYS_MID_IFC"/>
    <entry name="SYS_MID_BB2SYS"/>
    <entry name="SYS_MID_CM4IC"/>
    <entry name="SYS_MID_CM4DC"/>
    <bound name="SYS_MID_RR_End"/>
  </enum>
  <var name="SYS_NB_STATIC_MASTER" value="SYS_MID_RR_Start-1"/>
  <var name="SYS_NB_MASTERS" value="SYS_MID_RR_End-1"/>


  <var name="SYS_NB_BITS_SLAVE" value="4"/>
  
  <enum name="Sys_slave_Id">
    <entry name="SYS_SID_DUMMY"/>
    <entry name="SYS_SID_FLASH"/>
    <entry name="SYS_SID_PSRAM"/>
    <entry name="SYS_SID_SYS2LP"/>
    <entry name="SYS_SID_RAM0"/>
    <entry name="SYS_SID_RAM1"/>
    <entry name="SYS_SID_RAM2"/>
    <entry name="SYS_SID_IFC"/>
    <entry name="SYS_SID_SYS2BB"/>
    <entry name="SYS_SID_CM4"/>
    <entry name="SYS_SID_ROM"/>
    <bound name="SYS_SID_End"/>
  </enum>
  <var name="SYS_NB_SLAVES" value="SYS_SID_End-1" />



  <var name="SYS_NB_BITS_PADDR" value="12"></var>
  <var name="SYS_APB_STEP" value="exp2(SYS_NB_BITS_PADDR)"/>

  
  <enum name="Sys_Module_Id">
    <entry name="SYS_ID_SPI1"><comment>The following modules are linked to ifc dma req with 2 requests per module</comment></entry>
    <entry name="SYS_ID_SPI2"/>
    <entry name="SYS_ID_RSVD2"/>
    <entry name="SYS_ID_UART1"/>
    <entry name="SYS_ID_UART2"/>
    <entry name="SYS_ID_UART3"/>
    <entry name="SYS_ID_RSVD6"/>
    <entry name="SYS_ID_SDMMC2"/>
    <entry name="SYS_ID_I2S"/>
    <entry name="SYS_ID_RSVD9"/>
    <entry name="SYS_ID_RSVD10"/>
    <entry name="SYS_ID_RSVD11"/>
    <entry name="SYS_ID_RSVD12"/>
    <entry name="SYS_ID_RSVD13"/>
    <entry name="SYS_ID_IFC"/>
    <entry name="SYS_ID_RSVD15"/>
    <entry name="SYS_ID_GPT1"/>
    <entry name="SYS_ID_GPT2"/>
    <entry name="SYS_ID_KEYPAD"/>
    <entry name="SYS_ID_SEG_LCD"/>
    <entry name="SYS_ID_I2C1"/>
    <entry name="SYS_ID_I2C2"/>
    <entry name="SYS_ID_I2C3"/>
    <entry name="SYS_ID_RSVD23"/>
    <entry name="SYS_ID_RSVD24"/>
    <entry name="SYS_ID_RSVD25"/>
    <entry name="SYS_ID_RSVD26"/>
    <entry name="SYS_ID_RSVD27"/>
    <entry name="SYS_ID_RSVD28"/>
    <entry name="SYS_ID_RSVD29"/>
    <entry name="SYS_ID_RSVD30"/>
    <entry name="SYS_ID_RSVD31"/>
    <entry name="SYS_ID_RSVD32"/>
    <entry name="SYS_ID_DMA"/>
    <entry name="SYS_ID_MAILBOX"/>
    <entry name="SYS_ID_RSVD35"/>
    <entry name="SYS_ID_CTRL"/>
    <entry name="SYS_ID_WDT"/>
    <entry name="SYS_ID_RSVD38"/>
    <entry name="SYS_ID_RSVD39"/>
    <entry name="SYS_ID_LZMA"/>
    <entry name="SYS_ID_RSVD41"/>
    <entry name="SYS_ID_BT_DBM"/>
    <entry name="SYS_ID_BT_MODEM"/>
    <entry name="SYS_ID_BT_CORE"/>
    <entry name="SYS_ID_WCN_RF_IF"/>
    <entry name="SYS_ID_RSVD46"/>
    <entry name="SYS_ID_PAGE_SPY"/>
    <entry name="SYS_ID_RSVD48"/>
    <entry name="SYS_ID_RSVD49"/>
    <entry name="SYS_ID_RSVD50"/>
    <entry name="SYS_ID_RSVD51"/>
    <entry name="SYS_ID_RSVD52"/>
    <entry name="SYS_ID_RSVD53"/>
    <entry name="SYS_ID_RSVD54"/>
    <entry name="SYS_ID_RSVD55"/>
    <entry name="SYS_ID_RSVD56"/>
    <entry name="SYS_ID_RSVD57"/>
    <entry name="SYS_ID_RSVD58"/>
    <entry name="SYS_ID_RSVD59"/>
    <entry name="SYS_ID_RSVD60"/>
    <entry name="SYS_ID_RSVD61"/>
    <entry name="SYS_ID_RSVD62"/>
    <entry name="SYS_ID_RSVD63"/>
    <entry name="SYS_ID_RSVD64"/>
    <entry name="SYS_ID_RSVD65"/>
    <entry name="SYS_ID_SPIFLASH"/>
    <entry name="SYS_ID_RSVD72"/>
    <entry name="SYS_ID_AES"/>
  </enum>

  <var name="LP_NB_BITS_PADDR" value="12"></var>
  <var name="LP_APB_STEP" value="exp2(LP_NB_BITS_PADDR)"/>

  
  <enum name="LP_Module_Id">
    <entry name="LP_ID_CTRL"/>
    <entry name="LP_ID_TIMER"/>
    <entry name="LP_ID_GPIO"/>
    <entry name="LP_ID_IOMUX"/>
    <entry name="LP_ID_PSRAM8_CTRL"/>
    <entry name="LP_ID_BT_AON"/>
    <entry name="LP_ID_RSVD6"/>
    <entry name="LP_ID_RSVD7"/>
    <entry name="LP_ID_PMUC"/>
    <entry name="LP_ID_RTC"/>
    <entry name="LP_ID_LPUART"/>
    <entry name="LP_ID_GSM_LPS"/>
    <entry name="LP_ID_NB_LPS"/>
    <entry name="LP_ID_WDT"/>
    <entry name="LP_ID_RSVD14"/>
    <entry name="LP_ID_RSVD15"/>
  </enum>

  
  <enum name="Sys_Ifc_Request_IDs">
    <entry name="SYS_ID_TX_SPI1"/>      
    <entry name="SYS_ID_RX_SPI1"/>      
    <entry name="SYS_ID_TX_SPI2"/>      
    <entry name="SYS_ID_RX_SPI2"/>      
    <entry name="SYS_ID_TX_RSVD4"/>     
    <entry name="SYS_ID_RX_RSVD5"/>     
    <entry name="SYS_ID_TX_UART1"/>     
    <entry name="SYS_ID_RX_UART1"/>     
    <entry name="SYS_ID_TX_UART2"/>     
    <entry name="SYS_ID_RX_UART2"/>     
    <entry name="SYS_ID_TX_UART3"/>     
    <entry name="SYS_ID_RX_UART3"/>     
    <entry name="SYS_ID_TX_RSVD12"/>    
    <entry name="SYS_ID_RX_RSVD13"/>    
    <entry name="SYS_ID_TX_SDMMC2"/>    
    <entry name="SYS_ID_RX_SDMMC2"/>    
    <entry name="SYS_ID_TX_I2S"/>       
    <entry name="SYS_ID_RX_I2S"/>       

  </enum>


  
  <enum name="Sys_Irq_Id">
      <entry name="SYS_IRQ_GPIO"/>
      <entry name="SYS_IRQ_LPTIMER"/>
      <entry name="SYS_IRQ_LPTIMER_OS"/>
      <entry name="SYS_IRQ_RTC"/>
      <entry name="SYS_IRQ_DMA"/>
      <entry name="SYS_IRQ_MAILBOX"/>
      <entry name="SYS_IRQ_RSVD6"/>
      <entry name="SYS_IRQ_SPI1"/>
      <entry name="SYS_IRQ_SPI2"/>
      <entry name="SYS_IRQ_FLASH"/>
      <entry name="SYS_IRQ_I2C1"/>
      <entry name="SYS_IRQ_I2C2"/>
      <entry name="SYS_IRQ_I2C3"/>
      <entry name="SYS_IRQ_RSVD13"/>
      <entry name="SYS_IRQ_UART1"/>
      <entry name="SYS_IRQ_UART2"/>
      <entry name="SYS_IRQ_UART3"/>
      <entry name="SYS_IRQ_LPUART"/>
      <entry name="SYS_IRQ_KEYPAD"/>
      <entry name="SYS_IRQ_RSVD19"/>
      <entry name="SYS_IRQ_SDMMC2"/>
      <entry name="SYS_IRQ_LZMA"/>
      <entry name="SYS_IRQ_AES"/>
      <entry name="SYS_IRQ_PMUC"/>
      <entry name="SYS_IRQ_GPADC"/>
      <entry name="SYS_IRQ_PSRAM8_CTRL"/>
      <entry name="SYS_IRQ_I2S"/>
      <entry name="SYS_IRQ_GPT1"/>
      <entry name="SYS_IRQ_GPT2"/>
      <entry name="SYS_IRQ_BCPU_IRQ0"/>
      <entry name="SYS_IRQ_BCPU_IRQ1"/>
      <entry name="SYS_IRQ_BCPU_IRQ2"/>
      <entry name="SYS_IRQ_BCPU_IRQ3"/>
      <entry name="SYS_IRQ_BBWDT_TIMEOUT"/>
      <entry name="SYS_IRQ_AONWDT"/>
      <entry name="SYS_IRQ_DBM"/>
      <entry name="SYS_IRQ_BLE"/>
      <entry name="SYS_IRQ_CM4_ICACHE"/>
      <entry name="SYS_IRQ_CM4_DCACHE"/>
      <entry name="SYS_IRQ_PAGE_SPY"/>
      <bound name="SYS_NB_IRQ"><comment>Number of IRQ</comment></bound>
  </enum>


  
  
  <enum name="BB_Master_Id">
    <entry name="BB_MID_DUMMY"/>
    <bound name="BB_MID_RR_Start"><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name="BB_MID_BCPU"/>
    <entry name="BB_MID_RSVD2"/>
    <entry name="BB_MID_RSVD3"/>
    <entry name="BB_MID_DMA"/>
    <entry name="BB_MID_F8"/>
    <entry name="BB_MID_RF_IF"/>
    <entry name="BB_MID_IFC"/>
    <entry name="BB_MID_SYS2BB"/>
    <bound name="BB_MID_RR_End"/>
  </enum>
  <var name="BB_NB_STATIC_MASTER" value="BB_MID_RR_Start-1"/>
  <var name="BB_NB_MASTERS" value="BB_MID_RR_End-1"/>


  
  <enum name="BB_slave_Id">
    <entry name="BB_SID_DUMMY"/>
    <entry name="BB_SID_ROM"/>
    <entry name="BB_SID_RAM0"/>
    <entry name="BB_SID_RAM1"/>
    <entry name="BB_SID_RAM2"/>
    <entry name="BB_SID_RAM3"/>
    <entry name="BB_SID_NB_RAM"/>
    <entry name="BB_SID_IFC"/>
    <entry name="BB_SID_BB2SYS"/>
    <entry name="BB_SID_BB2LP"/>
    <entry name="BB_SID_PSRAM"/>
    <bound name="BB_SID_End"/>
  </enum>
  <var name="BB_NB_SLAVES" value="BB_SID_End-1" />  


  <var name="BB_NB_BITS_PADDR" value="12"></var>
  <var name="BB_APB_STEP" value="exp2(BB_NB_BITS_PADDR)"/>

  
  <enum name="BB_Module_Id">
    <entry name="BB_ID_SCI1"/>
    <entry name="BB_ID_SCI2"/>
    <entry name="BB_ID_DEBUG_UART"/>
    <entry name="BB_ID_GSM_RFSPI"/>
    <entry name="BB_ID_NB_RFSPI"/>
    <entry name="BB_ID_GSM_TCU"/>
    <entry name="BB_ID_NB_TCU"/>
    <entry name="BB_ID_CTRL"/>
    <entry name="BB_ID_RF_IF"/>
    <entry name="BB_ID_ROM_CTRL"/>
    <entry name="BB_ID_IRQ"/>
    <entry name="BB_ID_DMA"/>
    <entry name="BB_ID_WDT"/>
    <entry name="BB_ID_TIMER"/>
    <entry name="BB_ID_IFC"/>
    <entry name="BB_ID_DEBUG_HOST"/> <comment>value="exp2(SYS_NB_BITS_PSEL)-1" The debug host is placed at last PSEL15 in the IFC</comment>
    <entry name="BB_ID_XCOR"/>
    <entry name="BB_ID_CORDIC"/>
    <entry name="BB_ID_ITLV"/>
    <entry name="BB_ID_VITAC"/>
    <entry name="BB_ID_EXCOR"/>
    <entry name="BB_ID_CHOLK"/>
    <entry name="BB_ID_CIPHER"/>
    <entry name="BB_ID_RSVD23"/>
    <entry name="BB_ID_RSVD24"/>
    <entry name="BB_ID_RSVD25"/>
    <entry name="BB_ID_RSVD26"/>
    <entry name="BB_ID_RSVD27"/>
    <entry name="BB_ID_RSVD28"/>
    <entry name="BB_ID_RSVD29"/>
    <entry name="BB_ID_RSVD30"/>
    <entry name="BB_ID_PAGE_SPY"/>
    <entry name="NB_ID_CTRL"/>
    <entry name="NB_ID_COMMON"/>
    <entry name="NB_ID_INTC"/>
    <entry name="NB_ID_CS"/>
    <entry name="NB_ID_FFT"/>
    <entry name="NB_ID_VITERBI"/>
    <entry name="NB_ID_MEAS"/>
    <entry name="NB_ID_DS_BSEL"/>
    <entry name="NB_ID_TX_PUSCH"/>
    <entry name="NB_ID_TX_CHSC"/>
    <entry name="NB_ID_TX_FE"/>
    <entry name="NB_ID_RSVD43"/>
    <entry name="NB_ID_RSVD44"/>
    <entry name="NB_ID_RSVD45"/>
    <entry name="NB_ID_RSVD46"/>
    <entry name="NB_ID_RSVD47"/>
    <entry name="BB_ID_RF_INTERFACE"/>
    <entry name="NB_ID_RSVD49"/>
    <entry name="BB_ID_DFE"/>
    <entry name="NB_ID_RSVD51"/>
    <entry name="BB_ID_RFFE"/>
    <entry name="BB_ID_ADI2CA_IF"/>
    <entry name="BB_ID_CA"/>
    <entry name="BB_ID_RSVD55"/>
    <entry name="BB_ID_RSVD56"/>
    <entry name="BB_ID_RSVD57"/>
    <entry name="BB_ID_RSVD58"/>
    <entry name="BB_ID_RSVD59"/>
    <entry name="BB_ID_RSVD60"/>
    <entry name="BB_ID_RSVD61"/>
    <entry name="BB_ID_RSVD62"/>
    <entry name="BB_ID_RSVD63"/>
    <entry name="BB_ID_A53"/>
    <entry name="BB_ID_GEA3"/>
    <entry name="BB_ID_F8"/>
    <bound name="BB_NB_PSEL"><comment></comment></bound>
  </enum>


  
  <enum name="BB_Ifc_Request_IDs">
    <entry name="BB_ID_TX_SCI1"/>      
    <entry name="BB_ID_RX_SCI1"/>      
    <entry name="BB_ID_TX_SCI2"/>      
    <entry name="BB_ID_RX_SCI2"/>      
    <entry name="BB_ID_TX_DEBUG_UART"/>
    <entry name="BB_ID_RX_DEBUG_UART"/>
  </enum>


  
  <enum name="BB_Irq_Id">
      <entry name="BB_IRQ_GSM_FRAME0"><comment>Baseband IRQ IDs<br/>Pulse IRQ</comment></entry>
      <entry name="BB_IRQ_NB_FRAME0"/>
      <entry name="BB_IRQ_RFSPI_CONFLICT"/>
      <entry name="BB_IRQ_A53"/>
      <entry name="BB_IRQ_GSM_FRAME1"/>
      <entry name="BB_IRQ_NB_FRAME1"/>
      <entry name="BB_IRQ_RSVD6"/>
      <entry name="BB_IRQ_RSVD7"/>
      <entry name="BB_IRQ_GSM_TCU0"/>
      <entry name="BB_IRQ_GSM_TCU1"/>
      <entry name="BB_IRQ_GSM_TCU2"/>
      <entry name="BB_IRQ_GSM_TCU3"/>
      <entry name="BB_IRQ_GSM_TCU4"/>
      <entry name="BB_IRQ_GSM_TCU5"/>
      <entry name="BB_IRQ_GSM_TCU6"/>
      <entry name="BB_IRQ_GSM_TCU7"/>
      <entry name="BB_IRQ_GSM_TCU8"/>
      <entry name="BB_IRQ_GSM_TCU9"/>
      <entry name="BB_IRQ_GSM_TCU10"/>
      <entry name="BB_IRQ_GSM_TCU11"/>
      <entry name="BB_IRQ_NB_TCU0"/>
      <entry name="BB_IRQ_NB_TCU1"/>
      <entry name="BB_IRQ_NB_TCU2"/>
      <entry name="BB_IRQ_NB_TCU3"/>
      <entry name="BB_IRQ_NB_TCU4"/>
      <entry name="BB_IRQ_NB_TCU5"/>
      <entry name="BB_IRQ_NB_TCU6"/>
      <entry name="BB_IRQ_NB_TCU7"/>
      <entry name="BB_IRQ_NB_TCU8"/>
      <entry name="BB_IRQ_NB_TCU9"/>
      <entry name="BB_IRQ_NB_TCU10"/>
      <entry name="BB_IRQ_NB_TCU11"/>
      <bound name="BB_NB_IRQ_PULSE"><comment>Number of Pulse IRQ</comment></bound>
      <entry name="BB_IRQ_RFIF_DBG"><comment>Level IRQ</comment></entry>
      <entry name="BB_IRQ_RFIF_RX"/>
      <entry name="BB_IRQ_RFIF_TX"/>
      <entry name="BB_IRQ_ITLV"/>
      <entry name="BB_IRQ_VITAC"/>
      <entry name="BB_IRQ_XCOR"/>
      <entry name="BB_IRQ_EXCOR"/>
      <entry name="BB_IRQ_CHOLK"/>
      <entry name="BB_IRQ_NB_RX_MCU"/>
      <entry name="BB_IRQ_NB_RX_DSP"/>
      <entry name="BB_IRQ_NB_TX_DSP"/>
      <entry name="BB_IRQ_NB_ACC_DSP"/>
      <entry name="BB_IRQ_SCI1"/>
      <entry name="BB_IRQ_SCI2"/>
      <entry name="BB_IRQ_GSM_RFSPI"/>
      <entry name="BB_IRQ_GSM_LPS"/>
      <entry name="BB_IRQ_NB_RFSPI"/>
      <entry name="BB_IRQ_NB_LPS"/>
      <entry name="BB_IRQ_NB_TCU_SYNC"/>
      <entry name="BB_IRQ_GEA3_GPRS_IRQ0"/>
      <entry name="BB_IRQ_GEA3_GPRS_IRQ1"/>
      <entry name="BB_IRQ_F8"/>
      <entry name="BB_IRQ_BB_DMA"/>
      <entry name="BB_IRQ_BBTIMER"/>
      <entry name="BB_IRQ_BBTIMER_OS"/>
      <entry name="BB_IRQ_PSRAM8_CTRL"/>
      <entry name="BB_IRQ_MAILBOX"/>
      <entry name="BB_IRQ_BB_REGINT0"/>
      <entry name="BB_IRQ_BB_REGINT1"/>
      <entry name="BB_IRQ_UART3"/>
      <entry name="BB_IRQ_LPUART"/>
      <entry name="BB_IRQ_DEBUG_UART"/>
      <entry name="BB_IRQ_HST_IRQ_BCPU"/>
      <entry name="BB_IRQ_PMUC"/>
      <entry name="BB_IRQ_GPIO"/>
      <entry name="BB_IRQ_LPTIMER"/>
      <entry name="BB_IRQ_LPTIMER_OS"/>
      <entry name="BB_IRQ_AONWDT"/>
      <entry name="BB_IRQ_DFE"/>
      <entry name="BB_IRQ_PAGE_SPY"/>
      <entry name="BB_IRQ_ADIIF"/>
      <entry name="BB_IRQ_RSVD73"/>
      <entry name="BB_IRQ_RSVD74"/>
      <entry name="BB_IRQ_RSVD75"/>
      <entry name="BB_IRQ_RSVD76"/>
      <entry name="BB_IRQ_RSVD77"/>
      <entry name="BB_IRQ_RSVD78"/>
      <entry name="BB_IRQ_RSVD79"/>
      <entry name="BB_IRQ_RSVD80"/>
      <entry name="BB_IRQ_RSVD81"/>
      <entry name="BB_IRQ_RSVD82"/>
      <entry name="BB_IRQ_RSVD83"/>
      <entry name="BB_IRQ_RSVD84"/>
      <entry name="BB_IRQ_RSVD85"/>
      <entry name="BB_IRQ_RSVD86"/>
      <entry name="BB_IRQ_RSVD87"/>
      <entry name="BB_IRQ_RSVD88"/>
      <entry name="BB_IRQ_RSVD89"/>
      <entry name="BB_IRQ_RSVD90"/>
      <entry name="BB_IRQ_RSVD91"/>
      <entry name="BB_IRQ_RSVD92"/>
      <entry name="BB_IRQ_RSVD93"/>
      <entry name="BB_IRQ_RSVD94"/>
      <entry name="BB_IRQ_RSVD95"/>
      <bound name="BB_NB_IRQ"><comment>Number of IRQ</comment></bound>
  </enum>
  <var name="BB_NB_IRQ_LEVEL" value="BB_NB_IRQ - BB_NB_IRQ_PULSE"><comment>Number of Level IRQ</comment></var>


  
  <var name="BB_SYMBOL_SIZE" value="13" ><comment>RF Input samples size (signed)</comment></var>
  <var name="VITAC_MULT_SIZE" value="14" ><comment>Vitac Multipliers size</comment></var>
  <var name="BB_SRAM_ADDR_WIDTH" value="14" ><comment>The Baseband SRam size</comment></var>



  <cjoker>
    /// XHALT macro will send the event 0x4a17 to the debug host and
    /// will stall the XCPU.  The XCPU can be released from Coolwatcher
    /// by issuing a xrbp command.
    #define XHALT { \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        while (hwp_debugHost->event != DEBUG_HOST_EVENT0_SEMA); \
        hwp_debugHost->event = 0x4a17; \
        hwp_sysCtrl->XCpu_Dbg_BKP |= SYS_CTRL_STALLED; \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
        asm("nop "); \
    }
  </cjoker>


</archive>

<archive relative = "global_macros.xml" asm="no">

<cjoker>

#if defined(REG_ADDRESS_FOR_ARM)
#define KSEG0(addr)     (addr)
#define KSEG1(addr)     (addr)
#else
#define KSEG0(addr)     ( (addr) | 0x80000000 )
#define KSEG1(addr)     ( (addr) | 0xA0000000 )
#endif

#define KSEG01_PHY_ADDR(addr)    ((UINT32)(addr) &amp; 0x0fffffff)

#define barrier() __asm__ __volatile__("": : :"memory")
 
#define REG_ACCESS_ADDRESS(addr)    KSEG1(addr)

/* Define access cached or uncached */
#define MEM_ACCESS_CACHED(addr)     ((UINT32*)((UINT32)(addr)&amp;0xdfffffff))
#define MEM_ACCESS_UNCACHED(addr)   ((UINT32*)((UINT32)(addr)|0x20000000))

/* Register access for assembly */
#if defined(REG_ADDRESS_FOR_ARM)
#define BASE_HI(val) (((0x40000000 | val) &amp; 0xfffff000) + (val &amp; 0x1000))
#define BASE_LO(val) (((val) &amp; 0xfff) - (val &amp; 0x1000))
#else
#define BASE_HI(val) (((0xa0000000 | val) &amp; 0xffff8000) + (val &amp; 0x8000))
#define BASE_LO(val) (((val) &amp; 0x7fff) - (val &amp; 0x8000))
#endif



/* to extract bitfield from register value */
#define GET_BITFIELD(dword, bitfield) (((dword) &amp; (bitfield ## _MASK)) &gt;&gt; (bitfield ## _SHIFT))

#define EXP2(n) (1&lt;&lt;(n))


/// XHALT macro will send the event 0x4a17 to the debug host and
/// will stall the XCPU.  The XCPU can be released from Coolwatcher
/// by issuing a xrbp command.
#define XHALT { \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
    while (hwp_debugHost->event != DEBUG_HOST_EVENT0_SEMA); \
    hwp_debugHost->event = 0x4a17; \
    hwp_sysCtrl->XCpu_Dbg_BKP |= SYS_CTRL_STALLED; \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
    asm("nop "); \
}

</cjoker>

</archive>
<archive relative="adi2ca_if.xml">
  <module name="adi2ca_if" category="Baseband">
    <reg protect="rw" name="fifo_ctrl">
      <bits access="r" name="reserved_27" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="rc" name="txfifo_wrclr" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          write 1 to clear Tx FIFO read pointer
        </comment>
      </bits>
      <bits access="rc" name="txfifo_rdclr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          write 1 to clear Tx FIFO write pointer
        </comment>
      </bits>
      <bits access="rc" name="rxfifo_rdclr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          write 1 to clear Rx FIFO read pointer
        </comment>
      </bits>
      <bits access="rc" name="rxfifo_wrclr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          write 1 to clear Rx FIFO write pointer
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cfg">
      <bits access="r" name="reserved_23" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="8" rst="0">
      </bits>
      <bits access="rw" name="oen_mode" pos="7" rst="0">
        <comment>
          0: automatic oen; 1: use tco as oen
        </comment>
      </bits>
      <bits access="rw" name="dbg_sel" pos="6:4" rst="0">
        <comment>
          debug output selection
        </comment>
      </bits>
      <bits access="rw" name="dr_mode" pos="3" rst="0">
        <comment>
          Data rate mode. 0 - ASIC 122.88M to 30.72M; 1 - FPGA 61.44M to 30.72M
        </comment>
      </bits>
      <bits access="rw" name="rf_resetb" pos="2" rst="1">
        <comment>
          reset signal to extenal rf chip low active
        </comment>
      </bits>
      <bits access="rw" name="txclk_pol" pos="1" rst="0">
        <comment>
          tx clock polar
        </comment>
      </bits>
      <bits access="rw" name="rxclk_pol" pos="0" rst="0">
        <comment>
          rx clock polar
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_ctrl">
      <bits access="r" name="reserved_9" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="22" rst="0">
      </bits>
      <bits access="rw" name="rx_delay" pos="21:16" rst="15">
        <comment>
          rx path fifo wr depth before start read
        </comment>
      </bits>
      <bits access="rw" name="zero_pad_cnt" pos="15:0" rst="20993">
        <comment>
          the count of zeros to pad after each Rx burst
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_ctrl">
      <bits access="r" name="reserved_24" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="7" rst="0">
      </bits>
      <bits access="rw" name="force_txclk_on" pos="6" rst="0">
      </bits>
      <bits access="rw" name="tx_delay" pos="5:0" rst="15">
        <comment>
          tx path fifo wr depth before start read
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="irq_clr">
      <bits access="r" name="reserved_27" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="rc" name="txfull" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          tx path fifo empty clear register
        </comment>
      </bits>
      <bits access="rc" name="txempty" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          tx path fifo empty clear register
        </comment>
      </bits>
      <bits access="rc" name="rxfull" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          rx path fifo empty clear register
        </comment>
      </bits>
      <bits access="rc" name="rxempty" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          rx path fifo full clear register
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="irq_mask">
      <bits access="r" name="reserved_27" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="rw" name="txfull_mask" pos="3" rst="0">
        <comment>
          tx path fifo empty mask register
        </comment>
      </bits>
      <bits access="rw" name="txempty_mask" pos="2" rst="0">
        <comment>
          tx path fifo empty mask register
        </comment>
      </bits>
      <bits access="rw" name="rxfull_mask" pos="1" rst="0">
        <comment>
          rx path fifo empty mask register
        </comment>
      </bits>
      <bits access="rw" name="rxempty_mask" pos="0" rst="0">
        <comment>
          rx path fifo full mask register
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="irq_status">
      <bits access="r" name="reserved_27" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="r" name="txempty_status" pos="3" rst="0">
        <comment>
          tx path fifo empty status register
        </comment>
      </bits>
      <bits access="r" name="txfull_status" pos="2" rst="0">
        <comment>
          tx path fifo empty status register
        </comment>
      </bits>
      <bits access="r" name="rxempty_status" pos="1" rst="0">
        <comment>
          rx path fifo empty status register
        </comment>
      </bits>
      <bits access="r" name="rxfull_status" pos="0" rst="0">
        <comment>
          rx path fifo full status register
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="irq_cause">
      <bits access="r" name="reserved_27" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="r" name="txempty_cause" pos="3" rst="0">
        <comment>
          tx path fifo empty cause register
        </comment>
      </bits>
      <bits access="r" name="txfull_cause" pos="2" rst="0">
        <comment>
          tx path fifo empty cause register
        </comment>
      </bits>
      <bits access="r" name="rxempty_cause" pos="1" rst="0">
        <comment>
          rx path fifo empty cause register
        </comment>
      </bits>
      <bits access="r" name="rxfull_cause" pos="0" rst="0">
        <comment>
          rx path fifo full cause register
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "aes_dma.xml">

  <var name="CIOS_RAM_SIZE" value="256*4" />    

  <module name="aes_dma" category="System">
    <reg32 protect="rw" name="dma_ctrl" >
      <bits name="fix_src" pos="0" access="rw" rst="0x00" >
        <comment>
            1 - fix src address
            0 - increament src address
        </comment>
      </bits>
      <bits name="fix_dst" pos="1" access="rw" rst="0x00" >
        <comment>
            1 - fix dst address
            0 - increament dst address
        </comment>
      </bits>
      <bits name="hsizem" pos="4:2" access="rw" rst="0x00" >
        <comment>
            0 - 1 byte
            1 - 2 byte
            2 - 4 byte
        </comment>
      </bits>
      <bits name="cycle2_3" pos="5" access="rw" rst="0x00" >
        <comment>
            write cycles
        </comment>
      </bits>
      <bits name="crc_ce_ctrl" pos="30:28" access="rw" rst="0x00" >
        <comment>
            0 - normal dma mode
            1 - dma aes encode mode
            5 - dma aes decode mode
            2 - dma crc mode
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="dma_src" >
      <bits name="src_addr" pos="31:0" access="rw" rst="0x00" >
        <comment>
            source dma address
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="dma_dst" >
      <bits name="dst_addr" pos="31:0" access="rw" rst="0x00" >
        <comment>
            destination dma address
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="dma_len" >
      <bits name="length" pos="17:0" access="rw" rst="0x3ffff" >
        <comment>
            number of hsizem
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="crc_gen" >
      <bits name="crc_poly" pos="31:0" access="rw" rst="0x04c11db7" >
        <comment>
            crc generator, MSB aligned
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="dma_func_ctrl" >
      <bits name="crc_gen_len" pos="1:0" access="rw" rst="0x3" >
        <comment>
           --no-use 0 - crc8 1 - crc16 3 - crc32
        </comment>
      </bits>
      <bits name="crc_ctrl" pos="19:16" access="rw" rst="0x00" >
        <comment>
            bit0 - input byte reverse
            bit1 - input bit reverse
            bit2 - output byte reverse
            bit3 - output bit reverse
        </comment>
      </bits>
      <bits name="aes_eng_cgen" pos="24" access="rw" rst="0x00" >
        <comment>
            aes engine clk on
        </comment>
      </bits>
      <bits name="aes_keygen_cgen" pos="25" access="rw" rst="0x00" >
        <comment>
            aes key generator clk on
        </comment>
      </bits>
      <bits name="crc_cgen" pos="28" access="rw" rst="0x00" >
        <comment>
            crc engine clk on
        </comment>
      </bits>
      <bits name="trng_cgen" pos="30" access="rw" rst="0x00" >
        <comment>
            trng engine clk on
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_key0" >
      <bits name="aes_key0" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes key bit 31:0
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_key1" >
      <bits name="aes_key1" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes key bit 63:32
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_key2" >
      <bits name="aes_key2" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes key bit 95:64
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_key3" >
      <bits name="aes_key3" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes key bit 127:96
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_iv0" >
      <bits name="aes_iv0" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes iv bit 31:0
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_iv1" >
      <bits name="aes_iv1" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes iv bit 63:32
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_iv2" >
      <bits name="aes_iv2" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes iv bit 95:64
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_iv3" >
      <bits name="aes_iv3" pos="31:0" access="rw" rst="0x00" >
        <comment>
            aes iv bit 127:96
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="aes_mode" >
      <bits name="aes_mode" pos="0" access="rw" rst="0x00" >
        <comment>
            1 - CBC mode
            0 - ECB mode
        </comment>
      </bits>
      <bits name="aes_key_start" pos="1" access="rw" rst="0x00" >
        <comment>
            1 - start aes key calc
            0 - after start calc, need written to 0
        </comment>
      </bits>
      <bits name="aes_key_start_mode" pos="2" access="rw" rst="0x00" >
        <comment>
            1 - aes key calc started by every 32bit key change
            0 - aes key calc started by mode[1] :default
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="cios_ctrl" >
      <bits name="cios_ram_en" pos="0" access="rw" rst="0x00" >
        <comment>
            Not used. The mac rd/wr fifo mem used by cios
        </comment>
      </bits>
      <bits name="cios_mode" pos="3:1" access="rw" rst="0x00" >
        <comment>
            0: 3'b000 - 1k 28bit mode
            4: 3'b100 - 2k 28bit mode
            1: 3'b001 - 1k 31bit mode
            5: 3'b101 - 2k 31bit mode
            2: 3'b010 - 1k 32bit mode
            6: 3'b110 - 2k 32bit mode
        </comment>
      </bits>
      <bits name="cios_force_ram" pos="4" access="rw" rst="0x00" >
        <comment>
            1 - cios ram can be accessed only by ahb bus
            0 - when cios ram input data completely writed by bus, then accessed by cios engine
                when engine accessed completely, then accessed by bus
        </comment>
      </bits>
      <bits name="cios_clk_en" pos="5" access="rw" rst="0x0" >
        <comment>
            cios clk on
        </comment>
      </bits>
      <bits name="cios_start_mode" pos="6" access="rw" rst="0x0" >
        <comment>
            0 - cios start by cios_ctrl[7] 
            1 - cios auto start when mod_N load done.
        </comment>
      </bits>
      <bits name="cios_start_compute" pos="7" access="rw" rst="0x0" >
        <comment>
            1 - write 1'b1 to start cios compute.
            0 - after start compute, need written to 0
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="cios_reg0" >
      <bits name="cios_reg0" pos="31:0" access="rw" rst="0x00" >
        <comment>
            cios reg
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="crc_init_val" >
      <bits name="crc_init" pos="31:0" access="rw" rst="0x00000000" >
        <comment>
            crc initial value, MSB aligned
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="crc_out_xorval" >
      <bits name="crc_xorval" pos="31:0" access="rw" rst="0x00" >
        <comment>
            crc output value xored value, LSB aligned
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="crc_out_val" >
      <bits name="crc_out" pos="31:0" access="ro" rst="0x00" >
        <comment>
            crc output value, LSB aligned
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="crc_size_val" >
      <bits name="crc_size" pos="2:0" access="rw" rst="0x2" >
        <comment>
            crc size:
            3'd0 - 8bit crc
            3'd1 - 16bit crc
            3'd2 - 32bit crc
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="ififo_thr" >
      <bits name="ififo_rd_low_thr" pos="6:0" access="rw" rst="0x4" >
        <comment>
            low threshold to trigger ififo read from ahb
        </comment>
      </bits>
      <bits name="ififo_rd_hight_thr" pos="14:8" access="rw" rst="0x37" >
        <comment>
            high threshold to switch ififo read to ofifo write
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="ofifo_thr" >
      <bits name="ofifo_wr_low_thr" pos="6:0" access="rw" rst="0x4" >
        <comment>
            low threshold to switch ofifo write to ififo read
        </comment>
      </bits>
      <bits name="ofifo_wr_hight_thr" pos="14:8" access="rw" rst="0x37" >
        <comment>
            high threshold to trigger ofifo write to ahb
        </comment>
      </bits>
    </reg32>
    <hole size="9*32" />
    <reg32 protect="rw" name="dma_int_out" >
      <bits name="int_out" pos="5:0" access="ro" rst="0x00" >
        <comment>
            interrupt output, write 1 for clear
            bit0 - ahb dma done
            bit1 - prng alert
            bit2 - trng on fly test failed
            bit3 - trng start test failed
            bit4 - trng data ready
            bit5 - cios done
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="dma_int_mask" >
      <bits name="int_mask" pos="5:0" access="rw" rst="0x00" >
        <comment>
            interrupt mask, 1 for disable interrapt
            bit0 - ahb dma done
            bit1 - prng alert
            bit2 - trng on fly test failed
            bit3 - trng start test failed
            bit4 - trng data ready
            bit5 - cios done
        </comment>
      </bits>
    </reg32>
    <hole size="30*32" />
    <reg32 protect="rw" name="trng_ctrl" >
      <bits name="trng_ctrl" pos="6:0" access="rw" rst="0x0c" >
        <comment>
            bit0 - trng enable
            bit1 - trng mode, 1 for continualy mode, 0 for once
            bit2 - trng start test enable
            bit3 - trng on fly test enable
            bit4 - trng source open
            bit5 - trng test enable
            bit6 - trng data mask enable
        </comment>
      </bits>
      <bits name="trng_mask" pos="23:16" access="rw" rst="0x00" >
        <comment>
            trng source mask
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="prng_ctrl" >
      <bits name="prng_ctrl" pos="3:0" access="rw" rst="0x00" >
        <comment>
            bit0 - prng enable
            bit1 - prng seed load
            bit2 - prng seed mode
            bit3 - prng timer enable
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="prng_seed" >
      <bits name="prng_seed" pos="31:0" access="rw" rst="0x00" >
        <comment>
            prng seed
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="prng_timer_init" >
      <bits name="prng_init" pos="31:1" access="rw" rst="0x00" >
        <comment>
            prng timer initial value * 2
        </comment>
      </bits>
      <bits name="prng_clk_sel" pos="0" access="rw" rst="0x00" >
        <comment>
            0 - use 40m/32=1.25MHz clk to sample input data
            1 - use dma clk to sample input data
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="prng_timer" >
      <bits name="prng_timer" pos="31:0" access="ro" rst="0x00" >
        <comment>
            prng timer value
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="trng_data0" >
      <bits name="trng_data0" pos="31:0" access="ro" rst="0x00" >
        <comment>
            trng data0
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="trng_data0_mask" >
      <bits name="trng_data0_mask" pos="31:0" access="ro" rst="0x00" >
        <comment>
            trng data0 mask
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="trng_data1" >
      <bits name="trng_data1" pos="31:0" access="ro" rst="0x00" >
        <comment>
            trng data1
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="trng_data1_mask" >
      <bits name="trng_data1_mask" pos="31:0" access="ro" rst="0x00" >
        <comment>
            trng data1 mask
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="prng_data" >
      <bits name="prng_data" pos="31:0" access="ro" rst="0x00" >
        <comment>
            prng data
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="trng_hc" >
      <bits name="trng_c_value" pos="15:0" access="ro" rst="0x00" >
        <comment>
            trng c value
        </comment>
      </bits>
      <bits name="trng_h_value" pos="31:16" access="ro" rst="0x01e0" >
        <comment>
            trng h value
        </comment>
      </bits>
    </reg32>
    <hole size="181*32" />
    <reg32 protect="rw" name="sha_command" >
      <bits name="sha_start" pos="0" access="rw" rst="0x00" >
        <comment>
          When written to a one, the calculation starts. The complete and complete error bits 
          are cleared when this bit is written with a one.
        </comment>
      </bits>
      <bits name="sha_complete" pos="1" access="ro" rst="0x00" >
        <comment>
          Set to a one when the operation has completed.
        </comment>
      </bits>
      <bits name="sha_message_end" pos="2" access="rw" rst="0x00" >
        <comment>
          When set, the block of data described by MESSAGE_ADDR and MESSAGE_LENGTH includes the end byte of the message.
        </comment>
      </bits>
      <bits name="sha_message_start" pos="3" access="rw" rst="0x00" >
        <comment>
          When set, the block of data described by MESSAGE_ADDR and MESSAGE_LENGTH includes the starting byte of the message
        </comment>
      </bits>
      <bits name="sha_algorithm" pos="7:4" access="rw" rst="0x00" >
        <comment>
          0x0       - SHA256 processing
          0x1       - SHA1 processing
          0x2 ~ 0xF - SHA1 processing
        </comment>
      </bits>
      <bits name="sha_int_on_completion" pos="8" access="rw" rst="0x00" >
        <comment>
          If set, and interrupt will be generated upon completion of message processing.
        </comment>
      </bits>
      <bits name="sha_msg_endian_mode" pos="9" access="rw" rst="0x00" >
        <comment>
          Swaps intra-word byte order of message words. If set byte addressing is Big Endian.
        </comment>
      </bits>
      <bits name="sha_hash_endian_mode" pos="10" access="rw" rst="0x00" >
        <comment>
          Swaps intra-word byte order of hash values. If set byte addressing is Big Endian.
        </comment>
      </bits>
      <bits name="sha_rev_16_11" pos="16:11" access="ro" rst="0x00" >
        <comment>
          Reserved.
        </comment>
      </bits>
      <bits name="sha_illegal_len" pos="17" access="ro" rst="0x00" >
        <comment>
          The Command register was written with start=1 when the Message Length register held an illegal value. 
          No calculation was executed.
        </comment>
      </bits>
      <bits name="sha_rev_31_18" pos="31:18" access="ro" rst="0x00" >
        <comment>
          Reserved.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_message_addr" >
      <bits name="sha_message_addr" pos="31:0" access="rw" rst="0x00" >
        <comment>
            Starting Byte address of the message block in memory.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_message_len" >
      <bits name="sha_message_len" pos="18:0" access="rw" rst="0x00" >
        <comment>
            Byte Length of Message. Maximum of 256K - Message Address[1:0].
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_rd_counter" >
      <bits name="sha_rd_counter" pos="15:0" access="ro" rst="0x00" >
        <comment>
            HW state. Used for debug only. Umac Interface rd_counter.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_wr_counter" >
      <bits name="sha_wr_counter" pos="15:0" access="ro" rst="0x00" >
        <comment>
            HW state. Used for debug only. Umac Interface wr_counter.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_umac_state_c" >
      <bits name="sha_umac_state_c" pos="1:0" access="ro" rst="0x00" >
        <comment>
            HW state. Used for debug only. Umac Interface umac_state_c.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_state_c" >
      <bits name="sha_state_c" pos="2:0" access="ro" rst="0x00" >
        <comment>
            HW state. Used for debug only. Umac Interface sha_state_c.
        </comment>
      </bits>
    </reg32>
    <hole size="6*32" />
    <reg32 protect="rw" name="sha_int_clr" >
      <bits name="sha_int_clr" pos="0" access="rw" rst="0x00" >
        <comment>
            Write 1 to the bit to clear the Interrupt
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_int_en" >
      <bits name="sha_int_en" pos="0" access="rw" rst="0x00" >
        <comment>
            Write 1 to the bit to enable SHA Interrupt
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_int_status" >
      <bits name="sha_int_status" pos="0" access="ro" rst="0x00" >
        <comment>
            SAM Interrupt status
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="sha_restart" >
      <bits name="sha_restart" pos="0" access="rw" rst="0x1" >
        <comment>
            Write 1 to restart SHA module
        </comment>
      </bits>
    </reg32>
    <hole size="47*32" />
    <reg32 protect="rw" name="hash_value_0" >
      <bits name="hash_value_0" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H0.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_1" >
      <bits name="hash_value_1" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H1.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_2" >
      <bits name="hash_value_2" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H2.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_3" >
      <bits name="hash_value_3" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H3.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_4" >
      <bits name="hash_value_4" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H4.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_5" >
      <bits name="hash_value_5" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H5.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_6" >
      <bits name="hash_value_6" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H6.
        </comment>
      </bits>
    </reg32>
    <reg32 protect="rw" name="hash_value_7" >
      <bits name="hash_value_7" pos="31:0" access="rw" rst="0x00" >
        <comment>
          SHA Hash Values. The resulting message digest is the concatenation of H7.
        </comment>
      </bits>
    </reg32>
    <hole size="8*32" />
    <reg32 protect="rw" name="sha_byte_count" >
      <bits name="sha_byte_count" pos="28:0" access="rw" rst="0x00" >
        <comment>
          Number of Message bytes processed. Maximum of 0x1FFF_FFFF. 
          Read for status or to save context. 
          Written to restore context.
        </comment>
      </bits>
    </reg32>
    
    <hole size="175*32"/>
      
    <memory name="cios_local_ram" size="CIOS_RAM_SIZE">
      <comment>CIOS RAM Space
        <br/> Used for CIOS Only. 
      </comment>
    </memory>

  </module>
</archive>
<archive relative="aon_sleep.xml">
  <module name="aon_sleep" category="BT">
    <hole size="384"/>
    <reg protect="rw" name="deepslcntl">
      <bits access="r" name="deepslcntl_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rw" name="radio_sleep_en" pos="1" rst="0">
        <comment>
          Controls the Radio module 
0: Radio stands in normal active mode 
1: Allow to disable Radio 
        </comment>
      </bits>
      <bits access="rw" name="osc_sleep_en" pos="0" rst="1">
        <comment>
          Controls the RF High frequency crystal oscillator 
0: High frequency crystal oscillator stands in normal active mode 
1: Allow to disable High frequency crystal oscillator 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="deepslwkup">
      <bits access="rw" name="deepsltime" pos="31:0" rst="0">
        <comment>
          Determines the time in low_power_clk clock cycles to spend in Deep Sleep Mode before waking-up the device. This ensures a maximum of 37 hours and 16mn sleep mode capabilities at 32kHz. This ensures a maximum of 36 hours and 16mn sleep mode capabilities at 32.768kHz 
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="enbpreset">
      <bits access="rw" name="twext" pos="31:21" rst="160">
        <comment>
          Time in low power oscillator cycles allowed for stabilization of the high frequency oscillator following an external wake-up request (signal wakeup_req) [0 - 64ms for 32kHz) 
        </comment>
      </bits>
      <bits access="rw" name="twosc" pos="20:10" rst="160">
        <comment>
          Time  in  low  power  oscillator  cycles  allowed  for  stabilization  of  the  high  frequency  oscillator  when  the deep-sleep mode has been left due to sleep-timer expiry (DEEPSLWKUP) [0 - 64ms for 32kHz) 
        </comment>
      </bits>
      <bits access="rw" name="twrm" pos="9:0" rst="32">
        <comment>
          Time in low power oscillator cycles allowed for the radio module to leave low-power mode  [0 - 32ms for 32kHz) 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="emcfg">
      <bits access="r" name="emcfg_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="rw" name="em_cfg" pos="8:0" rst="2">
        <comment>
          [7]:~RET1N    [4:3]:EMAW   [2:0]:EMA  
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="osc_en_ctrl">
      <bits access="r" name="osc_en_ctrl_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="osc_en_stat" pos="1" rst="1">
        <comment>
          status of osc_en. 1 means BT is using clock derived from oscillator
        </comment>
      </bits>
      <bits access="rw" name="osc_en_mask" pos="0" rst="0">
        <comment>
          when set to 1, mask bt2pmu_wakeup output to 0 to avoid unnecessary wakeup
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "bb2g_ram.xml">
  <var name="BB2G_RAM_SIZE"   value="32*4096" />    

  
  <module name="bb2g_ram" category="Baseband">
    <memory name="ram_array" size="BB2G_RAM_SIZE">
      <comment>BB2G Ram Space
        <br/> This RAM is used in 2G mode as ACC buffer and code space.
        <br/> In NB mode, it can also be used as TCM memory space.
      </comment>
    </memory>
  </module>


</archive>
<archive relative = "bb_cp2.xml">
<module name="bb_cp2" category="Baseband">
    <reg name="ctrl" protect="rw">
        <bits name="First Poly" pos="2:0" access="rw" rst="111" display="hex">
            <comment>This field is used for setting the first polynomial to encode 
                     or the CRC computation
                    <br/>First polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
                    <br/>Cyclic code :
                    <br/>000 = D8 + D4 + D3 + D2 + 1
                    <br/>001 = D3 + D + 1
                    <br/>010 = D14 + D13 + D5 + D3 + D2 +1
                    <br/>011 = D6 + D5 + D3 + D2 + D1 + 1
                    <br/>100 = D10 + D8 + D6 + D5 + D4 + D2 + 1
                    <br/>101 = D16 + D12 + D5 + 1
                    <br/>110 = (D23 + 1)*(D17 + D3 + 1)
                    <br/>111 = reserved
            </comment>
        </bits>
        <bits name="Second Poly" pos="5:3" access="rw" rst="111" display="hex">
            <comment>Second polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Third Poly" pos="8:6" access="rw" rst="111" display="hex">
            <comment>Third polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Fourth Poly" pos="11:9" access="rw" rst="111" display="hex">
            <comment>Fourth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Fith Poly" pos="14:12" access="rw" rst="111" display="hex">
            <comment>Fith polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="Sixth Poly" pos="17:15" access="rw" rst="111" display="hex">
            <comment>Sixth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name="RSC Poly" pos="20:18" access="rw" rst="111" display="hex">
            <comment>RSC (Recursive Systematic Convolutional) polynomial code:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No RSC
            </comment>
        </bits>
        <bits name="NB Poly" pos="23:21" access="rw" rst="111" display="hex">
            <comment>Number of polynomial code to process:
                    <br/>0x0 = 0
                    <br/>0x1 = 1 (First Poly)
                    <br/>0x2 = 2 (First poly and second Poly)
                    <br/>0x3 = 3 (First poly, second poly, third Poly)
                    <br/>0x6 = 6 (first Poly to sixth Poly)
                    <br/>0x7 = reserved
            </comment>
        </bits>
        <bits name="Enable Puncturing" pos="24" access="rw" rst="1">
            <comment>Enable Puncturing
                    <br/>0 = No puncturing (puncturing disabled)
                    <br/>1 = Enable puncturing
            </comment>
        </bits>
    </reg>
    
    <reg name="bit number" protect="rw">
        <bits name="Bit number" pos="8:0" access="rw" rst="0x1FF" display="hex">
            <comment>Number of inputs bits to process
                <br/>0x01 = 1
                <br/>0x02 = 2
                <br/>0x03 = 3
                <br/>...
                <br/>0xFD = 253
                <br/>0xFE = 254
                <br/>0xFF = 255
                <br/>0x100 = 256
                <br/>...
                <br/>0x1BF = 447
                <br/>0x1C0 = 448
            </comment>
        </bits>
    </reg>
    
    <reg name="Status" protect="r">
        <bits name="Enable" pos="0:0" access="r" rst="0">
            <comment>When 1 the bb_cp2 is running
            </comment>
        </bits>
    </reg>
    
    <reg name="lram_addr" protect="rw">
        <bits name="LRAM Address" pos="4:0" access="rw" rst="0x0" display="hex">
            <comment>LRAM address for the next access
                <br/>Automatically incremented after each access
            </comment>
        </bits>
        <bits name="LRAM Select" pos="5" access="rw" rst="0x1">
            <comment>Select LRAM for the next access
                <br/>0 = Puncturing LRAM
                <br/>1 = Data LRAM
            </comment>
        </bits>
    </reg>

    <reg name="CRC code LSB" protect="r">
        <bits name="CRC code" pos="31:0" access="r" rst="0xFFFFFFFF" display="hex">
            <comment>CRC code LSB bits
            </comment>
        </bits>
    </reg>

    <reg name="CRC code MSB" protect="r">
        <bits name="CRC code" pos="7:0" access="r" rst="0x03" display="hex">
            <comment>CRC code MSB bits
            </comment>
        </bits>
    </reg>
    
    <hole size="800" />
    
    <reg name="CP2_Select_REG" protect="rw">
        <bits name="CP2 Select" pos="0" access="rw" rst="1">
            <comment>CP2 register access selection bit
                <br/>0= All registers are only accessible through the APB bus
                <br/>1= All registers are only accessible by the BCPU through the CP2 bus
            </comment>
        </bits>
    </reg>

    <reg name="LRAM_Data_REG" protect="rw">
        <bits name="LRAM Data" pos="31:0" access="rw" rst="no" display="hex">
            <comment>LRAM Data. This register is used for access to the 
                     puncturing LRAM or to the Data LRAM.
                <br/>All access into this register, increment the LRAM_ADDR register.
            </comment>
        </bits>
    </reg>

</module>

<cjoker>
#ifdef __mips__
// changing xml generated defines
#undef BB_CP2_ENABLE_PUNCTURING
#undef BB_CP2_LRAM_DATA
#undef BB_CP2_BIT_NUMBER

#define BB_CP2_ENABLE_PUNCTURING(n) (((n)&amp;1)&lt;&lt;24)

/// BB_CP2 address mapping
#define BB_CP2_CTRL                              0
#define BB_CP2_BIT_NUMBER                        1
#define BB_CP2_STATUS                            2
#define BB_CP2_LRAM_ADDR                         3
#define BB_CP2_CRC_CODE_LSB                      4
#define BB_CP2_CRC_CODE_MSB                      5
#define BB_CP2_LRAM_DATA                         0
#define BB_CP2_LRAM_PUNC                         (0&lt;&lt;5)
#define BB_CP2_DATA_LRAM                         (1&lt;&lt;5)

///* BB_CP2 ACCESSES */
//// macro for converting a constant to a string
//#define CT_CONVERT_TO_STRING(x) #x
//// control register -> GPR
//#define CT_BB_CP2_RD_CTRL_REG(regaddr, n)       asm volatile("cfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
////              GPR -> control register
//#define CT_BB_CP2_WR_CTRL_REG(regaddr, n)       asm volatile("ctc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
//// general register -> GPR
//#define CT_BB_CP2_RD_GNRL_REG_GPR(regaddr, n)   asm volatile("mfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
////              GPR -> general register
//#define CT_BB_CP2_WR_GNRL_REG_GPR(regaddr, n)   asm volatile("mtc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
//// general register -> memory
//#define CT_BB_CP2_RD_GNRL_REG_MEM(regaddr, out)	asm volatile("swc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((out)))
////           memory -> general register
//#define CT_BB_CP2_WR_GNRL_REG_MEM(regaddr, in) 	asm volatile("lwc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((in)))


//Base Define
//udi0
#define mips_udi_i_nv(OP, IMM)		\
  do { 								\
    __asm__ __volatile ("udi%0 %1"	\
		 : /* no outputs */		    \
		 : "K" (OP), "n" (IMM)); 	\
  } while (0)

#define mips_udi0(COFUN)  mips_udi_i_nv(0, COFUN)

//udi1/3/5
#define mips_udi_iiri(OP, IS, IT, RD, IMM) 			\
__extension__ ({						            \
  __asm__ __volatile ("udi%1 $%2,$%3,%0,%4" 		\
	   : "=d" (RD) 					                \
	   : "K" (OP), "K" (IS), "K" (IT), "K" (IMM)); 	\
})                                                  \

#define mips_udi1(regaddr, n)  mips_udi_iiri(1, 0, 0, n, regaddr)
#define mips_udi3(regaddr, n)  mips_udi_iiri(3, 0, 0, n, regaddr)
#define mips_udi5(n)  mips_udi_iiri(5, 0, 0, n, 0)

//udi2/4
#define mips_udi_ri_nv(OP, S, IMM)				\
  do { 								\
    __asm__ __volatile ("udi%0 %z1,%2"				\
	       : /* no outputs */				\
	       : "K" (OP), "dJ" (S), "K" (IMM)); 		\
  } while (0)

#define mips_udi2(regaddr, n)  mips_udi_ri_nv(2, n, regaddr)
#define mips_udi4(regaddr, n)  mips_udi_ri_nv(4, n, regaddr)

//       CHANGE0     //////////////////////////////////////////////////////////////////////////////////////////////////////
//cop2->udi0
//old:
//#define SPAL_BB_CP2_START_CONV      asm volatile("cop2 0x1FFFFFF")  // 25 bits command
//#define SPAL_BB_CP2_START_CRC_E     asm volatile("cop2 0x1FFFFFE")  // 25 bits command
//#define SPAL_BB_CP2_START_CRC_D     asm volatile("cop2 0x1FFFFFD")  // 25 bits command
//#define SPAL_BB_CP2_START_FIRE_TRAP asm volatile("cop2 0x1FFFFFC")  // 25 bits command// Length of the puncturing table
//new:
#define SPAL_BB_CP2_START_CONV      mips_udi0(0xFFFFF) 
#define SPAL_BB_CP2_START_CRC_E     mips_udi0(0xFFFFE)
#define SPAL_BB_CP2_START_CRC_D     mips_udi0(0xFFFFD)
#define SPAL_BB_CP2_START_FIRE_TRAP mips_udi0(0xFFFFC)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//       CHANGE1    //////////////////////////////////////////////////////////////////////////////////////////////////////
//mf->udi1
//old:
//#define SPAL_BB_CP2_RD_GNRL_REG_GPR(regaddr, n)   asm volatile("mfc2 %0, $" CONVERT_TO_STRING(regaddr) :"=r"((n)))
//new:
#define SPAL_BB_CP2_RD_GNRL_REG_GPR(regaddr, n) mips_udi1(regaddr, n) 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//       CHANGE2    /////////////////////////////////////////////////////////////////////////////////////////////////////
//mt->udi2
//old:
//#define SPAL_BB_CP2_WR_GNRL_REG_GPR(regaddr, n)   asm volatile("mtc2 %0, $" CONVERT_TO_STRING(regaddr) ::"r"((n)))
//new:
#define SPAL_BB_CP2_WR_GNRL_REG_GPR(regaddr, n) mips_udi2(regaddr, n)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//       CHANGE3    /////////////////////////////////////////////////////////////////////////////////////////////////////
//cf->udi3
//old:
//#define SPAL_BB_CP2_RD_CTRL_REG(regaddr, n)       asm volatile("cfc2 %0, $" CONVERT_TO_STRING(regaddr) :"=r"((n)))
//new:
#define SPAL_BB_CP2_RD_CTRL_REG(regaddr, n) mips_udi3(regaddr, n)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//       CHANGE4    /////////////////////////////////////////////////////////////////////////////////////////////////////
//ct->udi4
//old:
//#define SPAL_BB_CP2_WR_CTRL_REG(regaddr, n)       asm volatile("ctc2 %0, $" CONVERT_TO_STRING(regaddr) ::"r"((n)))
//new:
#define SPAL_BB_CP2_WR_CTRL_REG(regaddr, n) mips_udi4(regaddr, n)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//       CHANGE5    /////////////////////////////////////////////////////////////////////////////////////////////////////
//bc2f->udi5
//old:
//#define set_label(labelname) asm volatile(#labelname ":")
//#define asm_wait(labelname)  asm volatile("bc2f " #labelname)
//new:
#define SPAL_BB_CP2_RD_BRANCH_TAKEN(bt_status) mips_udi5(bt_status)

#define SPAL_WAIT_BBCP2_FUNC_D                  \
    unsigned int bt_status;                     \
    SPAL_BB_CP2_RD_BRANCH_TAKEN(bt_status);     \
    while(bt_status != 0x1){                    \
        SPAL_BB_CP2_RD_BRANCH_TAKEN(bt_status); \
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//       CHANGE6    /////////////////////////////////////////////////////////////////////////////////////////////////////
//swc2/lwc2->mf/mt and lw/sw
//old:
//#define SPAL_BB_CP2_RD_GNRL_REG_MEM(regaddr, out) asm volatile("swc2 $" CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((out)))
//#define SPAL_BB_CP2_WR_GNRL_REG_MEM(regaddr, in)  asm volatile("lwc2 $" CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((in)))
//new:
#define SPAL_BB_CP2_RD_GNRL_REG_MEM(regaddr, out)            \
    {unsigned int store_tmp;                                  \
    SPAL_BB_CP2_RD_GNRL_REG_GPR(regaddr, store_tmp);          \
    asm volatile("sw %0, 0(%1)"                              \
            ::"r"(store_tmp), "r"(out));}

#define SPAL_BB_CP2_WR_GNRL_REG_MEM(regaddr, in)             \
   {unsigned int store_tmp;                                  \
    asm volatile("lw %0, 0(%1)"                              \
            :"=r"(store_tmp)                                 \
            :"r"(in));                                       \
    SPAL_BB_CP2_WR_GNRL_REG_GPR(regaddr, store_tmp);}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//void __attribute__ ((nomicromips)) spal_CapDecodeCrc(SPAL_CAP_CRC_PARAM_T param, UINT32* In, UINT32* Out)
//void __attribute__ ((nomicromips)) spal_CapEncodeCrc(SPAL_CAP_CRC_PARAM_T param, UINT32* In, UINT32* Out)
//void __attribute__ ((nomicromips)) spal_CapConvoluate(SPAL_CAP_CONV_PARAM_T param, UINT32* punctTable, UINT32* In, UINT32* Out)

#endif

</cjoker>

</archive>
<archive relative = "bb_ctrl.xml">

<module name="bb_ctrl" category="System">

  <reg name="bb_revid" protect="r">
    <bits access="r" name="bb_revid" pos="15:0" rst="0x0">
    </bits>
  </reg>

  <reg name="gpio_out" protect="rw">
    <bits access="rw" name="gpio_out" pos="6:0" rst="0x0">
    </bits>
  </reg>

  <reg name="gpio_oen" protect="rw">
    <bits access="rw" name="gpio_oen" pos="6:0" rst="0x7f">
    </bits>
  </reg>

  <reg name="gpio_in" protect="r">
    <bits access="r" name="gpio_in" pos="6:0" rst="0x0">
    </bits>
  </reg>

  <reg name="gpio_pdn" protect="rw">
    <bits access="rw" name="gpio_pdn" pos="6:0" rst="0x0">
    </bits>
  </reg>

  <reg name="gpio_ctrl" protect="rw">
    <bits access="rw" name="gpio_ruen" pos="31:25" rst="0x0">
    </bits>
    <bits access="rw" name="gpio_rden" pos="24:18" rst="0x0">
    </bits>
    <bits access="rw" name="gpio_dsel" pos="17:14" rst="0x0">
    </bits>
    <bits access="rw" name="gpio_ibit" pos="13:0" rst="0x0">
    </bits>
  </reg>

  <reg name="misc_ctrl" protect="rw">
    <bits access="rw" name="ext_xcv_sel" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw" name="dspram_en" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw" name="femio_tco_sel" pos="11:4" rst="0x0">
    </bits>
    <bits access="rw" name="femio_mipi_sel" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="mipi_clk_half_sel" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="rfspi_mux_mode" pos="1:0" rst="0x2">
    </bits>
  </reg>

  <reg name="dbg_ctrl" protect="rw">
    <bits access="rw" name="dbg_hresp_err_mask" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw" name="cmu_clk_en" pos="21:21" rst="0x0">
    </bits>
    <bits access="rw" name="cmu_clk_sel" pos="20:16" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_clk_en" pos="12:12" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_clk_sel" pos="11:8" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_trig_sel" pos="7:4" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_out_sel" pos="3:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg0" protect="rw">
    <bits access="rw" name="disable_acg0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg1" protect="rw">
    <bits access="rw" name="disable_acg1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg2" protect="rw">
    <bits access="rw" name="disable_acg2" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg3" protect="rw">
    <bits access="rw" name="disable_acg3" pos="31:0" rst="0x0">
    </bits>
  </reg>

</module>
</archive>

<archive relative = "bb_ifc.xml">

<include file="globals.xml"/>



<var name="BB_IFC_ADDR_ALIGN" value="0" />

<var name="BB_IFC_TC_LEN" value="23" />

<var name="BB_IFC_STD_CHAN_NB" value="BB_IFC_NB_STD_CHANNEL" /> 

<var name="BB_IFC_RFSPI_CHAN" value="2" />

<module name="bb_ifc" category="Baseband">
  

  <reg protect="r" name="get_ch">
    <bits access="r" name="ch_to_use" pos="3:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />0000 = use Channel0
      <br />0001 = use Channel1
      <br />0010 = use Channel2 
      <br /> ...
      <br />0111 = use Channel7
      <br />1111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="BB_IFC_STD_CHAN_NB+BB_IFC_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />1111_1111 = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="BB_IFC_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="1">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <hole size="32" />

  

  <struct count="BB_IFC_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>


      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Exchange the read data from fifo halfword MSB or LSB
        <br />
    </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Exchange the write data to fifo  halfword MSB or LSB
        <br />
    </comment>
      </bits>


      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="5" rst="0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0x1F" display="hex">
        <options linkenum="BB_Ifc_Request_IDs"> 
          
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
      </bits>

        <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
        <comment>Set the MAX burst length for channel 0,1. 
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.  
        <br /> The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4. 
        <br /> .
        </comment>



        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="BB_IFC_TC_LEN-1:0" rst="0xFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc_threshold">
      <bits access="rw" name="tc_threshold" pos="BB_IFC_TC_LEN-1:0" rst="0x0" display="hex">
        <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.
        </comment>
      </bits>
    </reg>
  </struct>
  
  

  <struct count="BB_IFC_RFSPI_CHAN" name="rfspi_ch">
  <reg protect="rw" name="ch_rfspi_control">
      <bits access="s" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />This channel works only in fifo mode. </comment>
      </bits>

      <bits access="c" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit to disable the channel.
        </comment>
      </bits>
    </reg>

    <reg protect="r" name="ch_rfspi_status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
      
      <bits access="r" name="fifo_level" pos="12:8" rst="0">
        <comment>Internal fifo level </comment>
      </bits>
    </reg>

    <reg protect="rw" name="ch_rfspi_start_addr">
      <bits access="rw" name="start_AHB_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Start Address. <br />This field represent the start address of the fifo.
                 The start address must 32-bit aligned.
        </comment>
      </bits>
    </reg>
    
    <reg protect="rw" name="ch_rfspi_end_addr">
      <bits access="rw" name="end_AHB_addr"
            pos="NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB End Address. <br />This field represent the last address of the fifo (it is the first address not used in the fifo). <br />The end address must 32-bit aligned.
        </comment>
      </bits>
    </reg>


    <reg protect="rw" name="ch_rfspi_tc">
      <bits access="rw" name="tc" pos="13:0" rst="0x0" display="hex">
        <comment>Transfer Count, transfer size in bytes. <br />This bit
        indicated the transfer size in bytes to perform. Up to 16kbytes per
        transfer. <br />During a transfer a write in this register add the new
        value to the current TC. A read of this register return the current
        current transfer count.</comment>
      </bits>
    </reg>
  </struct>
</module>

</archive>
<archive relative = "bb_irq.xml">

<include file="globals.xml"/>

<var name="BB_IRQ_UNIT_NUM"   value="4" />

<module name="bb_irq" category="Baseband">
    <struct count="BB_IRQ_UNIT_NUM" name="irq_unit">
        <reg name="Src0" protect="r">
            <comment>Writing '0' to force the corresponding irq source bit to 0.
                <br/>Reading gives the value of the register.
            </comment>
            <bits name="Src0" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
        </reg>
    
        <reg name="Src1" protect="r">
            <comment>Writing '0' to force the corresponding irq source bit to 0.
                <br/>Reading gives the value of the register.
            </comment>
            <bits name="Src1" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="32"/>
        </reg>

        <reg name="Src2" protect="r">
            <comment>Writing '0' to force the corresponding irq source bit to 0.
                <br/>Reading gives the value of the register.
            </comment>
            <bits name="Src2" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="64"/>
        </reg>
    
        <reg name="SC" protect="">
            <bits name="IntEnable" pos="0" access="rw" rst="1">
                <comment>Interrupt enable semaphore, used for critical section.
                    <br/>Read returns its value and then clears it to '0' disabling interrupts.
                    <br/>Write the read value to restore the previous state, this will exit the critical section.
                </comment>
            </bits>
        </reg>    

        <reg name="Cause0" protect="r">
            <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
                <br/>The cause for the Irq sources, one bit for each module's irq source.
                <br/>The cause is the actual Irq source masked by the mask register.
            </comment>
            <bits name="Cause0" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
        </reg>

        <reg name="Cause1" protect="r">
            <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
                <br/>The cause for the Irq sources, one bit for each module's irq source.
                <br/>The cause is the actual Irq source masked by the mask register.
            </comment>
            <bits name="Cause1" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="32"/>
        </reg>
    
        <reg name="Cause2" protect="r">
            <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
                <br/>The cause for the Irq sources, one bit for each module's irq source.
                <br/>The cause is the actual Irq source masked by the mask register.
            </comment>
            <bits name="Cause2" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="64"/>
        </reg>
    
        <reg name="Status0" protect="r">
            <comment>The status0 for the level Irq sources, one bit for each module's irq source.
                <br/>The status0 reflect the actual Irq source.
            </comment>
            <bits name="Status0" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
        </reg>
    
        <reg name="Status1" protect="r">
            <comment>The status1 for the level Irq sources, one bit for each module's irq source.
                <br/>The status1 reflect the actual Irq source.
            </comment>
            <bits name="Status1" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="32"/>
        </reg>
 
        <reg name="Status2" protect="r">
            <comment>The status1 for the level Irq sources, one bit for each module's irq source.
                <br/>The status1 reflect the actual Irq source.
            </comment>
            <bits name="Status2" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="64"/>
        </reg>
    
        <reg name="Pulse_Status" protect="r">
            <comment>The status for the Pulse Irq sources, one bit for each module's irq source.
                <br/>The status reflect the actual Irq source.
            </comment>
            <bits name="Status" pos="31:0" access="r" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
        </reg>
    
    </struct>

    <reg name="SC_ALL" protect="">
        <bits name="IntEnable" pos="0" access="rw" rst="1">
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>  

    <reg name="Mask_Set0" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set0" pos="31:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>

    <reg name="Mask_Set1" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set1" pos="31:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="32"/>
    </reg>

    <reg name="Mask_Set2" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Set2" pos="31:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="64"/>
    </reg>

    <reg name="Mask_Clear0" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr0" pos="31:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>

    <reg name="Mask_Clear1" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr1" pos="31:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="32"/>
    </reg>

    <reg name="Mask_Clear2" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Mask_Clr2" pos="31:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="64"/>
    </reg>

    <reg name="Pulse_Mask_Set" protect="rw">
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Set" pos="31:0" access="rs" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>

    <reg name="Pulse_Mask_Clr" protect="rw">
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name="Pulse_Mask_Clr" pos="31:0" access="rc" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>

    <reg name="Pulse_Clear" protect="rw">
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name="Pulse_Clr" pos="31:0" access="c" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>

    <reg name="RegInt_Cause" protect="r">
        <bits name="RegInt0_Cause" pos="7:0" access="r" rst="0">
            <comment>When read, this return the cause of interruption, basically the set/clear register RegInt0 part masked with RegInt0_Mask.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="RegInt1_Cause" pos="15:8" access="r" rst="0">
            <comment>When read, this return the cause of interruption, basically the set/clear register RegInt1 part masked with RegInt1_Mask.
            </comment>
            <options><mask/><shift/></options>
        </bits>
   </reg>

   <reg name="RegInt_Set" protect="rw">
        <bits name="RegInt0_Set" pos="7:0" access="rs" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RegInt1_Set" pos="15:8" access="rs" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <reg name="RegInt_Clr" protect="rw">
        <bits name="RegInt0_Clr" pos="7:0" access="rc" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RegInt1_Clr" pos="15:8" access="rc" rst="0">
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>

    <reg name="RegInt_Mask_Set" protect="rw">
        <bits name="RegInt0_Mask_Set" pos="7:0" access="rs" rst="0">
            <comment>When read: returns the value of the RegInt0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the RegInt0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The RegInt0_Mask masks the set/clear register to trigger interrupts.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RegInt1_Mask_Set" pos="15:8" access="rs" rst="0">
            <comment>When read: returns the value of the RegInt1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the RegInt1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The RegInt1_Mask masks the set/clear register to trigger interrupts.
            </comment>
           <options><mask/><shift/><default/></options>
        </bits>
    </reg>

    <reg name="RegInt_Mask_Clr" protect="rw">
        <bits name="RegInt0_Mask_Clr" pos="7:0" access="rc" rst="0">
            <comment>When read: returns the value of the RegInt0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the RegInt0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The RegInt0_Mask masks the set/clear register to trigger interrupts.
             </comment>
            <options><mask/><shift/><default/></options>
         </bits>
        <bits name="RegInt1_Mask_Clr" pos="15:8" access="rc" rst="0">
            <comment>When read: returns the value of the RegInt1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the RegInt1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The RegInt1_Mask masks the set/clear register to trigger interrupts.
             </comment>
             <options><mask/><shift/><default/></options>
        </bits>
    </reg>

    <reg name="WakeUp_Mask0" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
        </comment>
        <bits name="WakeUp_Mask0" pos="31:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="0"/>
    </reg>

    <reg name="WakeUp_Mask1" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
        </comment>
        <bits name="WakeUp_Mask1" pos="31:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="32"/>
    </reg>

    <reg name="WakeUp_Mask2" protect="rw">
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
        </comment>
        <bits name="WakeUp_Mask2" pos="31:0" access="rw" rst="0" cut="1" cutprefix="" cutenum="BB_Irq_Id" cutstart="64"/>
    </reg>

    <reg name="Cpu_Sleep" protect="w">
        <bits name="Sleep" pos="0" access="w" rst="0">
            <comment>Writing '1' to this bit will put the BCPU to sleep (i.e.: Disable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
            </comment>
        </bits>
    </reg>

</module>

</archive>
<archive relative = "bb_rom.xml">
  <var name="BB_ROM_SIZE"   value="608*1024" />            
  <var name="NB_BB_PATCH"   value="16+16" />               
  <var name="BB_PATCH_SIZE" value="NB_BB_PATCH*4" />       

  
  <module name="bb_rom" category="Baseband">
    <memory name="rom_array" size="BB_ROM_SIZE">
      <comment>BB Rom Space
        <br/>This rom is used for BCPU.
      </comment>
    </memory>
  </module>

  
  <module name="bb_rom_ctrl" category="Baseband">
    
    <reg name="rom_patch" count="NB_BB_PATCH" protect="rw">
        <bits name="block_addr" pos="18:4" access="rw" rst = "0">
            <comment>Base address of block in int_Rom patched (corresponding data are read from int_SRam)
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="patch_en"  pos="31"    access="rw" rst="0">
            <options>
                <option name="Enable" value="1"/>
                <option name="Disable" value="0"/>
            </options>
        </bits>
    </reg>
    
    <hole size="1024"/>
      
    <reg name="ram_array" count="BB_PATCH_SIZE" protect="wo">
      <comment>BB Rom patch Ram Space
        <br/> Used for store the patch instead of rom, when patch is valid
      </comment>
    </reg>
  </module>

</archive>
<archive relative="ble_link.xml">
  <module name="ble_link" category="BT">
    <reg protect="rw" name="rwblecntl">
      <bits access="w" name="master_soft_rst" pos="31" rst="0">
        <comment>
          Reset the complete BLE Core except registers, radio controller and timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. &#10;In case of Dual Mode implementation, reset BLE sub-system and common blocks. 
        </comment>
      </bits>
      <bits access="w" name="master_tgsoft_rst" pos="30" rst="0">
        <comment>
          Reset the timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. &#10;Not applicable in case of Dual Mode implementation
        </comment>
      </bits>
      <bits access="w" name="reg_soft_rst" pos="29" rst="0">
        <comment>
          Reset the complete BLE register block, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. 
        </comment>
      </bits>
      <bits access="w" name="radiocntl_soft_rst" pos="28" rst="0">
        <comment>
          Reset the radio controller, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. &#10;Should not be used unless ERRORTYPSTAT-RADIO_EMACC_ERR goes high.&#10;Not applicable in case of Dual Mode implementation
        </comment>
      </bits>
      <bits access="w" name="swint_req" pos="27" rst="0">
        <comment>
          Forces the generation of ble_sw_irq when written with a 1, and proper masking is set. Resets at 0 when action is performed. No action happens if it is written with 0. 
        </comment>
      </bits>
      <bits access="w" name="rftest_abort" pos="26" rst="0">
        <comment>
          Abort the current RF Testing defined as per CS-FORMAT when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. &#10;Note that when RFTEST_ABORT is requested &#10;  1/ In case of infinite Tx, the Packet Controller FSM stops at the end of the current byte in process, and processes accordingly the packet CRC.  &#10;  2/ In case of Infinite Rx, the Packet Controller FSM either stops as the end of the current Packet reception (if Access address has been detected), or simply stop the processing switching off the RF. 
        </comment>
      </bits>
      <bits access="w" name="advert_abort" pos="25" rst="0">
        <comment>
          Abort the current Advertising event when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. 
        </comment>
      </bits>
      <bits access="w" name="scan_abort" pos="24" rst="0">
        <comment>
          Abort the current scan window when written with a  1. Resets at 0 when action is performed. No action happens if it is written with 0. 
        </comment>
      </bits>
      <bits access="r" name="rwblecntl_reserved_0" pos="23:21" rst="0">
      </bits>
      <bits access="rw" name="md_dsb" pos="20" rst="0">
        <comment>
          0: Normal operation of MD bits management &#10;1: MD bit automatic management disabled, means.  &#10;-      value forced by SW from Tx Descriptor &#10;-      normal behavior for received MD
        </comment>
      </bits>
      <bits access="rw" name="sn_dsb" pos="19" rst="0">
        <comment>
          0: Normal operation of Sequence number  &#10;1: Sequence Number Management disabled: &#10;-      value forced by SW from Tx Descriptor &#10;-      value ignored in Rx -&gt; No SN error reported. 
        </comment>
      </bits>
      <bits access="rw" name="nesn_dsb" pos="18" rst="0">
        <comment>
          0: Normal operation of Acknowledge   &#10;1: Acknowledge scheme disabled: &#10;-      value forced by SW from Tx Descriptor &#10;-      value ignored in Rx -&gt; No NESN error reported. 
        </comment>
      </bits>
      <bits access="rw" name="crypt_dsb" pos="17" rst="0">
        <comment>
          0: Normal operation. Encryption / Decryption enabled.  &#10;1: Encryption / Decryption disabled. &#10;Note  that  if  CS-CRYPT_EN  is  set,  then  MIC  is  generated,  and  only  data  encryption  is  disabled, meaning data sent are plain data. 
        </comment>
      </bits>
      <bits access="rw" name="lrpmap_dsb" pos="16" rst="0">
        <comment>
          Has effect only if RW_BLE_LONG_RANGE_INST is defined&#10;0: Normal operation. LR Pattern Mapper/Demapper enabled.&#10;1: LR Pattern Mapper/Demapper disabled.
        </comment>
      </bits>
      <bits access="rw" name="lrfec_dsb" pos="15" rst="0">
        <comment>
          Has effect only if RW_BLE_LONG_RANGE_INST is defined&#10;0: Normal operation. LR FEC encoder/decoder enabled.&#10;1: LR FEC encoder/decoder disabled.
        </comment>
      </bits>
      <bits access="rw" name="whit_dsb" pos="14" rst="0">
        <comment>
          0: Normal operation. Whitening enabled. &#10;1: Whitening disabled. 
        </comment>
      </bits>
      <bits access="rw" name="crc_dsb" pos="13" rst="0">
        <comment>
          0: Normal operation. CRC removed from data stream. &#10;1: CRC stripping disabled on Rx packets, CRC replaced by 0x000 in Tx. 
        </comment>
      </bits>
      <bits access="rw" name="hop_remap_dsb" pos="12" rst="0">
        <comment>
          0: Normal operation. Frequency Hopping Remapping algorithm enabled. &#10;1: Frequency Hopping Remapping algorithm disabled 
        </comment>
      </bits>
      <bits access="r" name="rwblecntl_reserved_1" pos="11" rst="0">
      </bits>
      <bits access="rw" name="anonymous_adv_filt_en" pos="10" rst="0">
        <comment>
          Anonymous Extended Advertising Filtering Enable control. Operate in Extended Active Scanner and Extended Passive Scanner modes only, and when White List is used by Device Filtering Policy&#10;0: RW-BLE Core does not reports anonymous advertiser to RW-BLE Software &#10;1: RW-BLE Core reports anonymous advertiser to RW-BLE Software
        </comment>
      </bits>
      <bits access="rw" name="advertfilt_en" pos="9" rst="0">
        <comment>
          Advertising Channels Error Filtering Enable control &#10;0: RW-BLE Core reports all errors to RW-BLE Software &#10;1: RW-BLE Core reports only correctly received packet, without error to RW-BLE Software 
        </comment>
      </bits>
      <bits access="rw" name="rwble_en" pos="8" rst="0">
        <comment>
          0: Disable RW-BLE Core Exchange Table pre-fetch mechanism. &#10;1: Enable RW-BLE Core Exchange table pre-fetch mechanism.
        </comment>
      </bits>
      <bits access="r" name="rwblecntl_reserved_2" pos="7:4" rst="0">
      </bits>
      <bits access="rw" name="rxwinszdef" pos="3:0" rst="0">
        <comment>
          Default Rx half Window size in us for uncoded PHY, and in multiple of 2us for coded PHY. Used when device &#10;-      is master connected &#10;-      performs second and subsequent receipts.&#10;'0 'is not a valid value. Recommended value is 10 (in decimal, leads to a default synchronization window duration of 20us for uncoded PHY, or 40us for coded PHY). 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="version">
      <bits access="r" name="typ" pos="31:24" rst="9">
        <comment>
          RW-BLE Core Type - 0x9 means BLE v5.0 (i.e. correspond LL version assigned number). Correspond to FS v9.0.26) 
        </comment>
      </bits>
      <bits access="r" name="rel" pos="23:16" rst="0">
        <comment>
          RW-BLE Core version - Major release number. Correspond to FS v9.0.26
        </comment>
      </bits>
      <bits access="r" name="upg" pos="15:8" rst="26">
        <comment>
          RW-BLE Core upgrade - Upgrade number. Correspond to FS v9.0.26
        </comment>
      </bits>
      <bits access="r" name="build_num" pos="7:0" rst="0">
        <comment>
          RW-BLE Core Build - Build number 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rwbleconf">
      <bits access="r" name="dmmode" pos="31" rst="1">
        <comment>
          0: RW-BLE Core is used as a standalone BLE device &#10;1: RW-BLE Core is used in a Dual Mode device 
        </comment>
      </bits>
      <bits access="r" name="rwbleconf_reserved_0" pos="30:29" rst="0">
      </bits>
      <bits access="r" name="correlator" pos="28" rst="1">
        <comment>
          0: Correlator logic is not present (i.e stands outside the RW-BLE Core)&#10;1: Correlator logic is present (i.e stands inside the RW-BLE Core)
        </comment>
      </bits>
      <bits access="r" name="userxlr" pos="27" rst="1">
        <comment>
          0: Long Range receive bit-stream logic is not present &#10;1: Long Range receive bit-stream logic is present 
        </comment>
      </bits>
      <bits access="r" name="usetxlr" pos="26" rst="1">
        <comment>
          0: Long Range transmit bit-stream logic is not present &#10;1: Long Range transmit bit-stream logic is present 
        </comment>
      </bits>
      <bits access="r" name="isoportnb" pos="25:24" rst="0">
        <comment>
          Number of supported Isochronous Channel (0 to 3) &#10;00: No ISO/Audio Channel available &#10;01: One ISO/Audio Channel available &#10;10: Two ISO/Audio Channels available &#10;11: Three ISO/Audio Channels available 
        </comment>
      </bits>
      <bits access="r" name="rwbleconf_reserved_1" pos="23:22" rst="0">
      </bits>
      <bits access="r" name="wlancoex" pos="21" rst="1">
        <comment>
          0: WLAN Coexistence mechanism not present &#10;1: WLAN Coexistence mechanism present (Default Value) 
        </comment>
      </bits>
      <bits access="r" name="rfif" pos="20:16" rst="1">
        <comment>
          RFIF[k]= 0: Control logic supporting radio k not present &#10;RFIF[k]= 1: Control logic supporting radio k present &#10;Index k values are: &#10; 00001: Ripple/Thetis RF. &#10; 00010: External Radio Controller Support &#10; 00100: IcyTRx v1 Radio &#10; 01000: IcyTRx v2 Radio &#10;xxx000: Reserved &#10;Default value is 00001 
        </comment>
      </bits>
      <bits access="r" name="usedbg" pos="15" rst="1">
        <comment>
          0: Diagnostic port not instantiated &#10;1: Diagnostic port instantiated (Default Value) 
        </comment>
      </bits>
      <bits access="r" name="decipher" pos="14" rst="1">
        <comment>
          0: AES deciphering not present &#10;1: AES deciphering present 
        </comment>
      </bits>
      <bits access="r" name="clk_sel" pos="13:8" rst="8">
        <comment>
          Operating Frequency (in MHz) &#10;Default value is 8MHz 
        </comment>
      </bits>
      <bits access="r" name="intmode" pos="7" rst="1">
        <comment>
          0: Interrupts are edge level generated, i.e. pulse.  &#10;1: Interrupts are trigger level generated, i.e. stays active at 1 till acknowledgement (Default Value) 
        </comment>
      </bits>
      <bits access="r" name="bus_type" pos="6" rst="0">
        <comment>
          Processor Bus Type &#10;0: AHB Bus &#10;1: X-Bar Bus 
        </comment>
      </bits>
      <bits access="r" name="data_width" pos="5" rst="1">
        <comment>
          Processor bus width: &#10;0: 16 bits (Default Value) &#10;1: 32 bits  
        </comment>
      </bits>
      <bits access="r" name="addr_width" pos="4:0" rst="16">
        <comment>
          Value of the RW_BLE_ADDRESS_WIDTH parameter concerted into binary. &#10;Default value is 13 (in decimal) 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="intcntl">
      <bits access="r" name="intcntl_reserved_0" pos="31" rst="0">
      </bits>
      <bits access="rw" name="clknintsrmsk" pos="30:28" rst="0">
        <comment>
          CLKN / HALF-Slot interrupt sub rating mask. Valid range is [0:4]
        </comment>
      </bits>
      <bits access="rw" name="clknintsrval" pos="27:24" rst="0">
        <comment>
          CLKN / HALF-Slot interrupt sub rating value.
        </comment>
      </bits>
      <bits access="r" name="intcntl_reserved_1" pos="23:16" rst="0">
      </bits>
      <bits access="rw" name="audioint2msk" pos="15" rst="0">
        <comment>
          Audio channel 2 interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="audioint1msk" pos="14" rst="0">
        <comment>
          Audio channel 1 interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="audioint0msk" pos="13" rst="0">
        <comment>
          Audio channel 0 interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="swintmsk" pos="12" rst="0">
        <comment>
          Software triggered interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="timestamptgtintmsk" pos="11" rst="0">
        <comment>
          Time Stamp Target Timer Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="finetgtimintmsk" pos="10" rst="0">
        <comment>
          Fine Target Timer Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="grosstgtimintmsk" pos="9" rst="0">
        <comment>
          Gross Target Timer Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="errorintmsk" pos="8" rst="0">
        <comment>
          Error Interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="cryptintmsk" pos="7" rst="0">
        <comment>
          Encryption engine Interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="skipevtintmsk" pos="6" rst="0">
        <comment>
          Skipped event interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="endevtintmsk" pos="5" rst="1">
        <comment>
          End of event interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="startevtintmsk" pos="4" rst="1">
        <comment>
          Start of event interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="slpintmsk" pos="3" rst="1">
        <comment>
          Sleep Mode Interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="rxintmsk" pos="2" rst="1">
        <comment>
          Rx Interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="txintmsk" pos="1" rst="1">
        <comment>
          Tx Interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
      <bits access="rw" name="clknintmsk" pos="0" rst="1">
        <comment>
          CLKN / half slot Interrupt Mask &#10;0: Interrupt not generated &#10;1: Interrupt generated 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="intstat">
      <bits access="r" name="intstat_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="audioint2stat" pos="15" rst="0">
        <comment>
          Audio channel 2 interrupt status (masking applied)&#10;0: No Audio interrupt. &#10;1: An Audio interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="audioint1stat" pos="14" rst="0">
        <comment>
          Audio channel 1 interrupt status (masking applied) &#10;0: No Audio interrupt. &#10;1: An Audio interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="audioint0stat" pos="13" rst="0">
        <comment>
          Audio channel 0 interrupt status (masking applied) &#10;0: No Audio interrupt. &#10;1: An Audio interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="swintstat" pos="12" rst="0">
        <comment>
          SW triggered interrupt status (masking applied) &#10;0: No SW triggered interrupt. &#10;1: A SW triggered interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="timestamptgtintstat" pos="11" rst="0">
        <comment>
          Masked Time Stamp Target Timer interrupt status (masking applied) &#10;0: No Time Stamp Target Timer interrupt. &#10;1: A Time Stamp Target Timer interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="finetgtimintstat" pos="10" rst="0">
        <comment>
          Masked Fine Target Timer interrupt status (masking applied) &#10;0: No Fine Target Timer interrupt. &#10;1: A Fine Target Timer interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="grosstgtimintstat" pos="9" rst="0">
        <comment>
          Masked Gross Target Timer interrupt status (masking applied) &#10;0: No Gross Target Timer interrupt. &#10;1: A Gross Target Timer interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="errorintstat" pos="8" rst="0">
        <comment>
          Masked Error interrupt status (masking applied) &#10;0: No Error interrupt. &#10;1: An Error interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="cryptintstat" pos="7" rst="0">
        <comment>
          Masked Encryption engine interrupt status (masking applied) &#10;0: No Encryption / Decryption interrupt. &#10;1: An Encryption / Decryption interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="skipevtintstat" pos="6" rst="0">
        <comment>
          Masked Skipped event interrupt status (masking applied)&#10;0: No Skiped Event interrupt. &#10;1: An Skiped Event interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="endevtintstat" pos="5" rst="0">
        <comment>
          Masked End of Event interrupt status (masking applied) &#10;0: No End of Advertising / Scanning / Connection interrupt. &#10;1: An End of Advertising / Scanning / Connection interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="startevtintstat" pos="4" rst="0">
        <comment>
          Masked Start of Event interrupt status (masking applied) &#10;0: No Start of Advertising / Scanning / Connection interrupt. &#10;1: An Start of Advertising / Scanning / Connection interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="slpintstat" pos="3" rst="0">
        <comment>
          Masked Sleep interrupt status (masking applied) &#10;0: No End of Sleep Mode interrupt. &#10;1: An End of Sleep Mode interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="rxintstat" pos="2" rst="0">
        <comment>
          Masked Packet Reception interrupt status (masking applied) &#10;0: No Rx interrupt. &#10;1: An Rx interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="txintstat" pos="1" rst="0">
        <comment>
          Masked Packet Transmit interrupt status (masking applied) &#10;0: No Tx interrupt. &#10;1: An Tx interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="clknintstat" pos="0" rst="0">
        <comment>
          Masked CLKN / half slot interrupt status (masking applied) &#10;0: No half slot interrupt. &#10;1: A No half slot interrupt. 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="intrawstat">
      <bits access="r" name="intrawstat_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="audioint2rawstat" pos="15" rst="0">
        <comment>
          Audio channel 2 interrupt raw status (masking not applied) &#10;0: No Audio interrupt. &#10;1: An Audio interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="audioint1rawstat" pos="14" rst="0">
        <comment>
          Audio channel 1 interrupt raw status (masking not applied) &#10;0: No Audio interrupt. &#10;1: An Audio interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="audioint0rawstat" pos="13" rst="0">
        <comment>
          Audio channel 0 interrupt raw status (masking not applied) &#10;0: No Audio interrupt. &#10;1: An Audio interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="swintrawstat" pos="12" rst="0">
        <comment>
          SW triggered interrupt raw status (masking not applied) &#10;0: No SW triggered interrupt. &#10;1: A SW triggered interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="timestamptgtimintstat" pos="11" rst="0">
        <comment>
          Time Stamp Target interrupt raw status (masking not applied) &#10;0: No Time Stamp Target Timer interrupt. &#10;1: A Time Stamp Target Timer interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="finetgtimintrawstat" pos="10" rst="0">
        <comment>
          Fine Target Timer interrupt raw status (masking not applied) &#10;0: No Fine Target Timer interrupt. &#10;1: A Fine Target Timer interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="grosstgtimintrawstat" pos="9" rst="0">
        <comment>
          Gross Target Timer interrupt raw status (masking not applied) &#10;0: No Gross Target Timer interrupt. &#10;1: A Gross Target Timer interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="errorintrawstat" pos="8" rst="0">
        <comment>
          Error interrupt raw status (masking not applied) &#10;0: No Error interrupt. &#10;1: An Error interrupt is pending.
        </comment>
      </bits>
      <bits access="r" name="cryptintrawstat" pos="7" rst="0">
        <comment>
          Encryption engine interrupt raw status (masking not applied) &#10;0: No Encryption / Decryption interrupt. &#10;1: An Encryption / Decryption interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="skipevtintrawstat" pos="6" rst="0">
        <comment>
          Skiped Event interrupt raw status (masking not applied) &#10;0: No Skipped Event interrupt. &#10;1: An Skipped Event interrupt is pending.
        </comment>
      </bits>
      <bits access="r" name="endevtintrawstat" pos="5" rst="0">
        <comment>
          End of Event interrupt raw status (masking not applied) &#10;0: No End of Advertising / Scanning / Connection interrupt. &#10;1: An End of Advertising / Scanning / Connection interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="startevtintrawstat" pos="4" rst="0">
        <comment>
          Start of Event interrupt raw status (masking not applied) &#10;0: No Start of Advertising / Scanning / Connection interrupt. &#10;1: An Start of Advertising / Scanning / Connection interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="slpintrawstat" pos="3" rst="0">
        <comment>
          Sleep interrupt raw status (masking not applied) &#10;0: No End of Sleep Mode interrupt. &#10;1: An End of Sleep Mode interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="rxintrawstat" pos="2" rst="0">
        <comment>
          Packet Reception interrupt raw status (masking not applied) &#10;0: No Rx interrupt. &#10;1: An Rx interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="txintrawstat" pos="1" rst="0">
        <comment>
          Packet Transmit interrupt raw status (masking not applied) &#10;0: No Tx interrupt. &#10;1: An Tx interrupt is pending. 
        </comment>
      </bits>
      <bits access="r" name="clknintrawstat" pos="0" rst="0">
        <comment>
          CLKN / half slot interrupt raw status (masking not applied) &#10;0: No half slot interrupt. &#10;1: A half slot interrupt is pending. 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="intack">
      <bits access="r" name="intack_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="s" name="audioint2ack" pos="15" rst="0">
        <comment>
        bit type is changed from wos to s.

          Audio channel 2 interrupt acknowledgement bit &#10;Software  writing  1  acknowledges  the  Audio  channel  2  interrupt.  This  bit  resets  AUDIOINT2STAT  and AUDIOINT2RAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="audioint1ack" pos="14" rst="0">
        <comment>
        bit type is changed from wos to s.

          Audio channel 1 interrupt acknowledgement bit &#10;Software  writing  1  acknowledges  the  Audio  channel  1  interrupt.  This  bit  resets  AUDIOINT1STAT  and AUDIOINT1RAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="audioint0ack" pos="13" rst="0">
        <comment>
        bit type is changed from wos to s.

          Audio channel 0 interrupt acknowledgement bit &#10;Software  writing  1  acknowledges  the  Audio  channel  0  interrupt.  This  bit  resets  AUDIOINT0STAT  and AUDIOINT0RAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="swintack" pos="12" rst="0">
        <comment>
        bit type is changed from wos to s.

          SW triggered interrupt acknowledgement bit &#10;Software   writing   1   acknowledges   the   SW   triggered   interrupt.   This   bit   resets   SWINTSTAT   and SWINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="timestamptgtimintack" pos="11" rst="0">
        <comment>
        bit type is changed from wos to s.

          Time Stamp Target interrupt acknowledgement bit &#10;Software  writing  1  acknowledges  the Fine Timer  interrupt.  This  bit resets TIMESTAMPTGTINTSTAT and TIMESTAMPTGTINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="finetgtimintack" pos="10" rst="0">
        <comment>
        bit type is changed from wos to s.

          Fine Target Timer interrupt acknowledgement bit &#10;Software  writing  1  acknowledges  the  Fine  Timer  interrupt.  This  bit  resets  FINETGTIMINTSTAT  and FINETGTIMINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="grosstgtimintack" pos="9" rst="0">
        <comment>
        bit type is changed from wos to s.

          Gross Target Timer interrupt acknowledgement bit &#10;Software writing  1 acknowledges the Gross Timer interrupt. This bit resets  GROSSTGTIMINTSTAT and GROSSTGTIMINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="errorintack" pos="8" rst="0">
        <comment>
        bit type is changed from wos to s.

          Error interrupt acknowledgement bit &#10;Software   writing   1   acknowledges   the   Error   interrupt.   This   bit   resets   ERRORINTSTAT   and ERRORINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="cryptintack" pos="7" rst="0">
        <comment>
        bit type is changed from wos to s.

          Encryption  engine  interrupt  acknowledgement  bit  Software  writing  1  acknowledges  the  Encryption engine interrupt. This bit resets CRYPTINTSTAT and CRYPTINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="skipevtintack" pos="6" rst="0">
        <comment>
        bit type is changed from wos to s.

          Skipped Event interrupt acknowledgment bit &#10;Software  writing  1  acknowledges  the  Skipped Event  interrupt.  This  bit resets SKIPEVTINTSTAT and SKIPEVTINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="endevtintack" pos="5" rst="0">
        <comment>
        bit type is changed from wos to s.

          End of Event interrupt acknowledgment bit &#10;Software  writing  1  acknowledges  the  End  of  Advertising  /  Scanning  /  Connection  interrupt.  This  bit resets EVENTINTSTAT and EVENTINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="startevtintack" pos="4" rst="0">
        <comment>
        bit type is changed from wos to s.

          Start of Event interrupt acknowledgment bit &#10;Software  writing  1  acknowledges  the  Start  of  Advertising  /  Scanning  /  Connection  interrupt.  This  bit resets STARTEVTINTSTAT and STARTEVTINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="slpintack" pos="3" rst="0">
        <comment>
        bit type is changed from wos to s.

          End of Deep Sleep interrupt acknowledgment bit &#10;Software  writing  1  acknowledges  the  End  of  Sleep  Mode  interrupt.  This  bit  resets  SLPINTSTAT  and SLPINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="rxintack" pos="2" rst="0">
        <comment>
        bit type is changed from wos to s.

          Packet Reception interrupt acknowledgment bit &#10;Software writing 1 acknowledges the Rx interrupt. This bit resets RXINTSTAT and RXINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="txintack" pos="1" rst="0">
        <comment>
        bit type is changed from wos to s.

          Packet Transmit interrupt acknowledgment bit &#10;Software writing 1 acknowledges the Rx interrupt. This bit resets TXINTSTAT and TXINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
      <bits access="s" name="clkntintack" pos="0" rst="0">
        <comment>
        bit type is changed from wos to s.

          CLKN / half slot interrupt acknowledgment bit &#10;Software writing 1 acknowledges the CLKN interrupt. This bit resets CLKNINTSTAT and CLKNINTRAWSTAT flags. &#10;Resets at 0 when action is performed 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="slotclk">
      <bits access="w" name="samp" pos="31" rst="0">
        <comment>
          Writing  a  1  samples  the  CLKN  Counter  value  in SCLK  register  field.  Resets  at  0  when action is performed 
        </comment>
      </bits>
      <bits access="w" name="clkn_upd" pos="30" rst="0">
        <comment>
          Update CLKN counter, when written with a 1.  Resets  at  0  when action is performed. No action happens if it is written with 0.
        </comment>
      </bits>
      <bits access="r" name="slotclk_reserved_0" pos="29:28" rst="0">
      </bits>
      <bits access="r" name="sclk" pos="27:0" rst="0">
        <comment>
          Value of the 312.5us CLKN counter. Updated each time SAMP field is written. Used by the SW in order to synchronize with the HW. This value does not change until the next writing of SAMP bit, and can therefore be safely accessed with 8-, 16- or 32-bits accesses.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="finetimecnt">
      <bits access="r" name="finetimecnt_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="finecnt" pos="9:0" rst="0">
        <comment>
          Value of the current half us fine time reference counter. Updated each time SLOTCLK-SAMP field is written WITH A &apos;1&apos;. Used by the SW in order to synchronize with the HW, and obtain a more precise sleep duration 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="et_currentrxdescptr">
      <bits access="rw" name="etptr" pos="31:16" rst="0">
        <comment>
          Exchange Table Pointer that determines the starting point of the Exchange Table 
        </comment>
      </bits>
      <bits access="r" name="et_currentrxdescptr_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="currentrxdescptr" pos="14:0" rst="0">
        <comment>
          Rx Descriptor Pointer that determines the starting point of the Receive Buffer Chained List 
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="deepslcntl">
      <bits access="rw" name="extwkupdsb" pos="31" rst="0">
        <comment>
          External Wake-Up disable  &#10;0: RW-BLE Core can be woken by external wake-up  &#10;1: RW-BLE Core cannot be woken up by external wake-up 
        </comment>
      </bits>
      <bits access="r" name="deepslcntl_reserved_0" pos="30:16" rst="0">
      </bits>
      <bits access="r" name="deep_sleep_stat" pos="15" rst="0">
        <comment>
          Indicator of current Deep Sleep clock mux status: &#10;0: RW-BLE Core is not yet in Deep Sleep Mode &#10;1: RW-BLE Core is in Deep Sleep Mode (only low_power_clk is running) 
        </comment>
      </bits>
      <bits access="r" name="deepslcntl_reserved_1" pos="14:5" rst="0">
      </bits>
      <bits access="w" name="soft_wakeup_req" pos="4" rst="0">
        <comment>
          Wake Up Request from RW-BLE Software. Applies when system is in Deep Sleep Mode. It wakes up the RW-BT Core when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. 
        </comment>
      </bits>
      <bits access="w" name="deep_sleep_corr_en" pos="3" rst="0">
        <comment>
          Half slot counter integer  and  fractional  part  correction.  Applies  when system has been woken-up from Deep Sleep Mode. It enables Fine Counter and CLKN counter when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. 
        </comment>
      </bits>
      <bits access="w" name="deep_sleep_on" pos="2" rst="0">
        <comment>
          RW-BLE Core sleep mode request control &#10;0: RW-BLE Core in normal active mode &#10;1: Request RW-BLE Core to switch in deep sleep mode. &#10;This bit is reset on DEEP_SLEEP_STAT falling edge. 
        </comment>
      </bits>
      <bits access="rw" name="radio_sleep_en" pos="1" rst="0">
        <comment>
          Controls the Radio module &#10;0: Radio stands in normal active mode &#10;1: Allow to disable Radio 
        </comment>
      </bits>
      <bits access="rw" name="osc_sleep_en" pos="0" rst="0">
        <comment>
          Controls the RF High frequency crystal oscillator &#10;0: High frequency crystal oscillator stands in normal active mode &#10;1: Allow to disable High frequency crystal oscillator 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="deepslwkup">
      <bits access="rw" name="deepsltime" pos="31:0" rst="0">
        <comment>
          Determines the time in low_power_clk clock cycles to spend in Deep Sleep Mode before waking-up the device. This ensures a maximum of 37 hours and 16mn sleep mode capabilities at 32kHz. This ensures a maximum of 36 hours and 16mn sleep mode capabilities at 32.768kHz 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="deepslstat">
      <bits access="r" name="deepsldur" pos="31:0" rst="0">
        <comment>
          Actual duration of the last deep sleep phase measured in low power oscillator cycles. DEEPSLDUR is set to zero at the beginning of the deep sleep phase, and is incremented at each low power clock tick until the end of the deep sleep phase. 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="enbpreset">
      <bits access="rw" name="twext" pos="31:21" rst="160">
        <comment>
          Time in low power oscillator cycles allowed for stabilization of the high frequency oscillator following an external wake-up request (signal wakeup_req) [0...64ms] for 32kHz; [0...62.5ms] for 32.768kHz
        </comment>
      </bits>
      <bits access="rw" name="twosc" pos="20:10" rst="160">
        <comment>
          Time  in  low  power  oscillator  cycles  allowed  for  stabilization  of  the  high  frequency  oscillator  when  the deep-sleep mode has been left due to sleep-timer expiry (DEEPSLWKUP-DEEPSLTIME) [0...64ms] for 32kHz; [0...62.5ms] for 32.768kHz
        </comment>
      </bits>
      <bits access="rw" name="twrm" pos="9:0" rst="32">
        <comment>
          Time in low power oscillator cycles allowed for the radio module to leave low-power mode [0...32ms] for 32kHz; [0...31.25ms] for 32.768kHz
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="finecntcorr">
      <bits access="r" name="finecntcorr_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="finecntcorr" pos="9:0" rst="0">
        <comment>
          Phase correction value for the 312.5us reference counter (i.e. Fine Counter) in half us.  
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clkncntcorr">
      <bits access="rw" name="abs_delta" pos="31" rst="0">
        <comment>
          Determines whether CLNCNTCORR is an absolute correction or a signed "delta" increment correction &#10;0: Absolute correction &#10;1: Signed "delta" increment correction 
        </comment>
      </bits>
      <bits access="r" name="clkncntcorr_reserved_0" pos="30:28" rst="0">
      </bits>
      <bits access="rw" name="clkncntcorr" pos="27:0" rst="0">
        <comment>
          CLKN Counter correction value
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="diagcntl">
      <bits access="rw" name="diag3_en" pos="31" rst="0">
        <comment>
          0: Disable diagnostic port 3 output. All outputs are set to 0. &#10;1: Enable diagnostic port 3 output. 
        </comment>
      </bits>
      <bits access="rw" name="diag3" pos="30:24" rst="0">
        <comment>
          Only relevant when DIAGEN3 = 1. &#10;Selection of the outputs that are driven to the diagnostic port 3.  
        </comment>
      </bits>
      <bits access="rw" name="diag2_en" pos="23" rst="0">
        <comment>
          0: Disable diagnostic port 2 output. All outputs are set to 0. &#10;1: Enable diagnostic port 2 output. 
        </comment>
      </bits>
      <bits access="rw" name="diag2" pos="22:16" rst="0">
        <comment>
          Only relevant when DIAGEN2 = 1. &#10;Selection of the outputs that are driven to the diagnostic port 2.  
        </comment>
      </bits>
      <bits access="rw" name="diag1_en" pos="15" rst="0">
        <comment>
          0: Disable diagnostic port 1 output. All outputs are set to 0. &#10;1: Enable diagnostic port 1 output. 
        </comment>
      </bits>
      <bits access="rw" name="diag1" pos="14:8" rst="0">
        <comment>
          Only relevant when DIAGEN1 = 1. &#10;Selection of the outputs that are driven to the diagnostic port 1.  
        </comment>
      </bits>
      <bits access="rw" name="diag0_en" pos="7" rst="0">
        <comment>
          0: Disable diagnostic port 0 output. All outputs are set to 0. &#10;1: Enable diagnostic port 0 output. 
        </comment>
      </bits>
      <bits access="rw" name="diag0" pos="6:0" rst="0">
        <comment>
          Only relevant when DIAGEN0 = 1. &#10;Selection of the outputs that are driven to the diagnostic port 0.  
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="diagstat">
      <bits access="r" name="diag3stat" pos="31:24" rst="0">
        <comment>
          Directly connected to ble_dbg3[7:0] output. Debug use only 
        </comment>
      </bits>
      <bits access="r" name="diag2stat" pos="23:16" rst="0">
        <comment>
          Directly connected to ble_dbg2[7:0] output. Debug use only 
        </comment>
      </bits>
      <bits access="r" name="diag1stat" pos="15:8" rst="0">
        <comment>
          Directly connected to ble_dbg1[7:0] output. Debug use only 
        </comment>
      </bits>
      <bits access="r" name="diag0stat" pos="7:0" rst="0">
        <comment>
          Directly connected to ble_dbg0[7:0] output. Debug use only 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="debugaddmax">
      <bits access="rw" name="reg_addmax" pos="31:16" rst="0">
        <comment>
          Upper limit for the Register zone indicated by the reg_inzone flag (see section 2.16). 
        </comment>
      </bits>
      <bits access="rw" name="em_addmax" pos="15:0" rst="0">
        <comment>
          Upper limit for the Exchange Memory zone indicated by the em_inzone flag (see section 2.16). 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="debugaddmin">
      <bits access="rw" name="reg_addmin" pos="31:16" rst="0">
        <comment>
          Lower limit for the Register zone indicated by the reg_inzone flag (see section 2.16) 
        </comment>
      </bits>
      <bits access="rw" name="em_addmin" pos="15:0" rst="0">
        <comment>
          Lower limit for the Exchange Memory zone indicated by the em_inzone flag (see section 2.16) 
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="errortypestat">
      <bits access="r" name="errortypestat_reserved_0" pos="31:21" rst="0">
      </bits>
      <bits access="r" name="phy_error" pos="20" rst="0">
        <comment>
          Indicates that the programmed CS-&lt;AUX/TX/RX&gt;RATE fields are not matching with the RADIOCNTL2-PHYMSK fields which indicate which PHY the radio is currently supporting.&#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="txaeheader_ptr_error" pos="19" rst="0">
        <comment>
          Indicates Tx pointer to the Extended Advertising Packet that has to be sent is null, while the Extended Header Length is not null and the packet to be sent is an Extended Advertising packet (valid in Extended Advertising modes only)&#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="tmafs_underrun" pos="18" rst="0">
        <comment>
          Indicates T_MAFS is smaller than 300us in between a transmitted Advertising packet containing an AuxPtr field and its chained packet: this comes from bad setting of Aux_Offset and/or Offset_Unit values&#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="ral_underrun" pos="17" rst="0">
        <comment>
          Indicates  Resolving  Address  List  engine  Under  run  issue,  happens  when  RAL  List  parsing  not finished on time &#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="ral_error" pos="16" rst="0">
        <comment>
          Indicates Resolving Address List engine faced a bad setting (e.g CS-RAL_EN = 1 and null RALPTR, or RALPTR &gt; CS-PEER_RALPTR).  &#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="rxdata_ptr_error" pos="15" rst="0">
        <comment>
          Indicates whether Rx data buffer pointer value programmed is null during Test Mode events: this is a major programming failure. During Master/Slave connections, it forces the system to fake reception. Please refer to section 3.4.4.3 for details. During Advertising/Scanning/Initiating(including Extended Modes), it forces to stop the event.&#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="txdata_ptr_error" pos="14" rst="0">
        <comment>
          Indicates whether Tx data buffer pointer value programmed is null during Advertising / Scanning /  Initiating  events,  or  during  Master  /  Slave  connections  with  non-null  packet  length:  this  is  a major programming failure.  &#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="rxdesc_empty_error" pos="13" rst="0">
        <comment>
          Indicates  whether  Rx  Descriptor  pointer  value  programmed  in  register  is  null:  this  is  a  major programming failure.  &#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="txdesc_empty_error" pos="12" rst="0">
        <comment>
          Indicates  whether  Tx  Descriptor  pointer  value  programmed  in  Control  Structure  is  null  during Advertising / Scanning / Initiating events: this is a major programming failure.  &#10;0: No error  &#10;1: Error occurred  
        </comment>
      </bits>
      <bits access="r" name="csformat_error" pos="11" rst="0">
        <comment>
          Indicates  whether  CS-FORMAT  has  been  programmed  with  an  invalid  value:  this  is  a  major software programming failure.  &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="llchmap_error" pos="10" rst="0">
        <comment>
          Indicates Link Layer Channel Map error, happens when actual number of CS-LLCHMAP bit set to one is strictly lower than 2 at the beginning of Frequency Hopping process &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="adv_underrun" pos="9" rst="0">
        <comment>
          Indicates  Advertising  Interval  Under  run,  occurs  if  time  between  two  consecutive  Advertising packet (in Advertising mode) is lower than described in Table 3-20 with ADVINT timer elapsing while Advertising FSM state is either in TXADVERT or T_IFS1.  &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="ifs_underrun" pos="8" rst="0">
        <comment>
          Indicates  Inter  Frame  Space  Under  run,  occurs  if  IFS  time  is  not  enough  to  update  and  read Control Structure/Descriptors, and/or White List parsing is not finished and/or Decryption time is too long to be finished on time &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="list_error" pos="7" rst="0">
        <comment>
          Indicates a Software programming issue (White List or Periodic Advertiser List or ADI List search request with empty list, or null base pointer)&#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="evt_cntl_apfm_error" pos="6" rst="0">
        <comment>
          Indicates  Anticipated  Pre-Fetch  Mechanism  error:  happens  when  2  consecutive  events  are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.  &#10;0: No error &#10;1: Error occured 
        </comment>
      </bits>
      <bits access="r" name="evt_schdl_apfm_error" pos="5" rst="0">
        <comment>
          Indicates  Anticipated  Pre-Fetch  Mechanism  error:  happens  when  2  consecutive  events  are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.  &#10;0: No error &#10;1: Error occured 
        </comment>
      </bits>
      <bits access="r" name="evt_schdl_entry_error" pos="4" rst="0">
        <comment>
          Indicates Event Scheduler faced Invalid timing programing on two consecutive ET entries (e.g first one with 624us offset and second one with no offset) &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="radio_emacc_error" pos="3" rst="0">
        <comment>
          Indicates  Radio  Controller  Exchange  Memory  access  error,  happens  when  Exchange  Memory accesses are not served in time and data are corrupted.  &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="pktcntl_emacc_error" pos="2" rst="0">
        <comment>
          Indicates  Packet  Controller  Exchange  Memory  access  error,  happens  when  Exchange  Memory accesses are not served in time and Tx/Rx data are corrupted &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="rxcrypt_error" pos="1" rst="0">
        <comment>
          Indicates real time decryption error, happens when AES-CCM decryption is too slow compared to  Packet  Controller  requests.  A  16-bytes  block  has  to  be  decrypted  prior  the  next  block  is received by the Packet Controller &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
      <bits access="r" name="txcrypt_error" pos="0" rst="0">
        <comment>
          Indicates Real Time encryption error, happens when AES-CCM encryption is too slow compared to  Packet  Controller  requests.  A  16-bytes  block  has  to  be  encrypted  and  prepared  on  Packet Controller request, and needs to be ready before the Packet Controller has to send ti &#10;0: No error &#10;1: Error occurred 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="swprofiling">
      <bits access="rw" name="swprof" pos="31:0" rst="0">
        <comment>
          Software Profiling register: used by RW-BLE Software for profiling purpose: this value is copied on Diagnostic port (Please refer to section 2.16 for details) 
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="radiocntl0">
      <bits access="rw" name="spiptr" pos="31:16" rst="0">
        <comment>
          SW driven SPI structure pointer. Value set by the RW-BLE Software
        </comment>
      </bits>
      <bits access="r" name="radiocntl0_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="spicfg" pos="7" rst="0">
        <comment>
          SPI Configuration used for SW-driven access and SPI structure interpretation. Interpretation is radio dependent
        </comment>
      </bits>
      <bits access="r" name="radiocntl0_reserved_1" pos="6" rst="0">
      </bits>
      <bits access="rw" name="spifreq" pos="5:4" rst="0">
        <comment>
          SPI clock frequency&#10;00: SPI clock is master1_gclk / 2&#10;01: SPI clock is master1_gclk / 4&#10;10: SPI clock is master1_gclk / 8&#10;11: Do not use&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiocntl0_reserved_2" pos="3:2" rst="0">
      </bits>
      <bits access="r" name="spicomp" pos="1" rst="1">
        <comment>
          SW driven SPI Access completion&#10;0: SW driven SPI Access pending or on-going&#10;1: SW driven SPI Access completed
        </comment>
      </bits>
      <bits access="w" name="spigo" pos="0" rst="0">
        <comment>
          SW driven SPI Access triggered when written with a &apos;1&apos;. Always read as 0.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiocntl1">
      <bits access="rw" name="forceagc_en" pos="31" rst="0">
        <comment>
          Control AGC force mode based on FORCEAGC_LENGTH value&#10;0: Disable&#10;1: Enable&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="forceiq" pos="30" rst="0">
        <comment>
          Control modulation mode in between FM and I&amp;Q&#10;0: FM modulation mode&#10;1: I&amp;Q modulation mode&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="rxdnsl" pos="29" rst="0">
        <comment>
          Do not send Length (over SPI) during Rx operation&#10;0: Normal Operations&#10;1: Prevent from sending valid reception length indication to the RF over SPI
        </comment>
      </bits>
      <bits access="rw" name="txdnsl" pos="28" rst="0">
        <comment>
          Do not send Length (over SPI) during Tx operation&#10;0: Normal Operations&#10;1: Prevent from sending valid transmit length indication to the RF over SPI
        </comment>
      </bits>
      <bits access="rw" name="forceagc_length" pos="27:16" rst="0">
        <comment>
          Defines Rx window time threshold (in us) that forces AGC to max gain&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="sync_pulse_mode" pos="15" rst="0">
        <comment>
          Determines whether Access Code Synchoronization detection is a pulse or a level.&#10;0: Synchoronization detection is a pulse&#10;1: Synchoronization detection is a level&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="sync_pulse_src" pos="14" rst="0">
        <comment>
          Determines whether Access Code Synchoronization detection is generated internally or comes from the Radio&#10;0: Internal detection&#10;1: External detection&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="dpcorr_en" pos="13" rst="0">
        <comment>
          Enables the use of the delayed DC offset compensated data path in Radio Correlator block (i.e 20us delay).&#10;0: Disabled&#10;1: Enabled&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="jef_select" pos="12" rst="0">
        <comment>
          Select Jitter Elimination FIFO&#10;0: Not selected&#10;1: Selected&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiocntl1_reserved_0" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="xrfsel" pos="9:4" rst="0">
        <comment>
          Radio Selection&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="subversion" pos="3:0" rst="0">
        <comment>
          Radio sub-version&#10;To be defined by the user
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiocntl2">
      <bits access="rw" name="lrsynccompmode" pos="31:30" rst="3">
        <comment>
          Long Range Synchronization compensation operating mode&#10;Bit 0 controls 125kbps LR packet part uses Synchro Tracking (0: disabled 1: enabled)&#10;Bit 1 controls 500kbps LR packet part uses Synchro Tracking (0: disabled 1: enabled)
        </comment>
      </bits>
      <bits access="rw" name="rxcitermbypass" pos="29" rst="0">
        <comment>
          Long Range CI bit[1] and TERM1 bypass mode. Allow to receive only CI bit 0 and then wait for RX payload directly
        </comment>
      </bits>
      <bits access="rw" name="lrvtbflush" pos="28:24" rst="8">
        <comment>
          Indicates Long Range Viterbi flush instant. This value corresponds to the Viterbi trace Back depth used in the selected design, hence corresponding to the number of remaining samples flush out just before the end of the packet. Valid value are in [4:27] range
        </comment>
      </bits>
      <bits access="rw" name="phymsk" pos="23:22" rst="0">
        <comment>
          Indicates selected Radio PHY support capabilities, in addition to 1Mbps that is mandatory.&#10;Bit 0 indicates 2Mbps support when set.&#10;Bit 1 indicates Coded PHY support when set.
        </comment>
      </bits>
      <bits access="rw" name="lrsyncerr" pos="21:20" rst="0">
        <comment>
          Number of errors allowed during Long Range Rx steam detection (when performed internally). Value set by the RW-BLE Software
        </comment>
      </bits>
      <bits access="r" name="radiocntl2_reserved_0" pos="19" rst="0">
      </bits>
      <bits access="rw" name="syncerr" pos="18:16" rst="0">
        <comment>
          Number of error allowed during Access Code detection (when performed internally), used for debug purpose only. Has to be set to 0x0 for normal operations.
        </comment>
      </bits>
      <bits access="rw" name="freqtable_ptr" pos="15:0" rst="256">
        <comment>
          Frequency Table pointer. Value set by the RW-BT Software
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiocntl3">
      <bits access="rw" name="rxrate3cfg" pos="31:30" rst="3">
        <comment>
          Rate out programmable value in Rx when CS-RXRATE is set to 0x3 (i.e 500kbps Long Range)
        </comment>
      </bits>
      <bits access="rw" name="rxrate2cfg" pos="29:28" rst="2">
        <comment>
          Rate out programmable value in Rx when CS-RXRATE is set to 0x2 (i.e 125kbps Long Range)
        </comment>
      </bits>
      <bits access="rw" name="rxrate1cfg" pos="27:26" rst="1">
        <comment>
          Rate out programmable value in Rx when CS-RXRATE is set to 0x1 (i.e 2Mbps)
        </comment>
      </bits>
      <bits access="rw" name="rxrate0cfg" pos="25:24" rst="0">
        <comment>
          Rate out programmable value in Rx when CS-RXRATE is set to 0x0 (i.e 1Mbps)
        </comment>
      </bits>
      <bits access="r" name="radiocntl3_reserved_0" pos="23:19" rst="0">
      </bits>
      <bits access="rw" name="rxsync_routing" pos="18" rst="0">
        <comment>
          Access Address detection information routing&#10;0: Uses radio_in[16] (i.e sync_p) &#10;1: Uses first radio_in[3] edge (Rx Valid)&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="rxvalid_beh" pos="17:16" rst="0">
        <comment>
          Defines radio_in[3] expected behavior&#10;00: Rx data aligned on radio_in[3] rising edges&#10;01: Rx data aligned on radio_in[3] falling edges&#10;10: Rx data aligned on radio_in[3] edges (toggle mode)&#10;11: reserved&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="txrate3cfg" pos="15:14" rst="3">
        <comment>
          Rate out programmable value in Tx when CS-&lt;TX/AUX&gt;RATE is set to 0x3 (i.e 500kbps Long Range)
        </comment>
      </bits>
      <bits access="rw" name="txrate2cfg" pos="13:12" rst="2">
        <comment>
          Rate out programmable value in Tx when CS-&lt;TX/AUX&gt;RATE is set to 0x2 (i.e 125kbps Long Range)
        </comment>
      </bits>
      <bits access="rw" name="txrate1cfg" pos="11:10" rst="1">
        <comment>
          Rate out programmable value in Tx when CS-&lt;TX/AUX&gt;RATE is set to 0x1 (i.e 2Mbps)
        </comment>
      </bits>
      <bits access="rw" name="txrate0cfg" pos="9:8" rst="0">
        <comment>
          Rate out programmable value in Tx when CS-&lt;TX/AUX&gt;RATE is set to 0x0 (i.e 1Mbps)
        </comment>
      </bits>
      <bits access="r" name="radiocntl3_reserved_1" pos="7:2" rst="0">
      </bits>
      <bits access="rw" name="txvalid_beh" pos="1:0" rst="0">
        <comment>
          Defines radio_out[3] expected behavior&#10;00: Tx data aligned on radio_out[3] rising edges&#10;01: Tx data aligned on radio_out[3] falling edges&#10;10: Tx data aligned on radio_out[3] edges (toggle mode)&#10;11: reserved&#10;To be defined by the user
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiopwrupdn0">
      <bits access="rw" name="sync_position0" pos="31:24" rst="0">
        <comment>
          Access Address detection pulse/level position for uncoded PHY at 1Mbps.&#10;If RW_BLE_CORRELATOR_INST is set, value expressed in clock cycles and used for sync_p_out (i.e radio_out[16]) positioning.&#10;If RW_BLE_CORRELATOR_INST is not set, value expressed in microsecond and used for sync_p_in (i.e radio_in[16]) positioning.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="rxpwrup0" pos="23:16" rst="210">
        <comment>
          Radio Rx Power Up (in us) for uncoded PHY at 1Mbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiopwrupdn0_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="txpwrdn0" pos="14:8" rst="3">
        <comment>
          Radio Tx Power Down (in us) for uncoded PHY at 1Mbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="txpwrup0" pos="7:0" rst="210">
        <comment>
          Radio Tx Power Up (in us) for uncoded PHY at 1Mbps.&#10;To be defined by the user
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiopwrupdn1">
      <bits access="rw" name="sync_position1" pos="31:24" rst="0">
        <comment>
          Access Address detection pulse/level position for uncoded PHY at 2Mbps.&#10;If RW_BLE_CORRELATOR_INST is set, value expressed in clock cycles and used for sync_p_out (i.e radio_out[16]) positioning.&#10;If RW_BLE_CORRELATOR_INST is not set, value expressed in microsecond and used for sync_p_in (i.e radio_in[16]) positioning.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="rxpwrup1" pos="23:16" rst="210">
        <comment>
          Radio Rx Power Up (in us) for uncoded PHY at 2Mbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiopwrupdn1_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="txpwrdn1" pos="14:8" rst="3">
        <comment>
          Radio Tx Power Down (in us) for uncoded PHY at 2Mbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="txpwrup1" pos="7:0" rst="210">
        <comment>
          Radio Tx Power Up (in us) for uncoded PHY at 2Mbps.&#10;To be defined by the user
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiopwrupdn2">
      <bits access="rw" name="sync_position2" pos="31:24" rst="0">
        <comment>
          Access Address detection pulse/level position for coded PHY at 125kbps and 500kbps.&#10;If RW_BLE_CORRELATOR_INST is set, value expressed in clock cycles and used for sync_p_out (i.e radio_out[16]) positioning.&#10;If RW_BLE_CORRELATOR_INST is not set, value expressed in microsecond and used for sync_p_in (i.e radio_in[16]) positioning.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="rxpwrup2" pos="23:16" rst="210">
        <comment>
          Radio Rx Power Up (in us) for coded PHY at 125kbps and 500kbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiopwrupdn2_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="txpwrdn2" pos="14:8" rst="3">
        <comment>
          Radio Tx Power Down (in us) for coded PHY at 125kbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="txpwrup2" pos="7:0" rst="210">
        <comment>
          Radio Tx Power Up (in us) for coded PHY at 125kbps.&#10;To be defined by the user
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiopwrupdn3">
      <bits access="r" name="radiopwrupdn3_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="txpwrdn3" pos="14:8" rst="3">
        <comment>
          Radio Tx Power Down (in us) for coded PHY at 500kbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="txpwrup3" pos="7:0" rst="210">
        <comment>
          Radio Tx Power Up (in us) for coded PHY at 500kbps.&#10;To be defined by the user
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiotxrxtim0">
      <bits access="r" name="radiotxrxtim0_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="rw" name="rfrxtmda0" pos="22:16" rst="0">
        <comment>
          RF Rx Test Mode Delay Adjustment for uncoded PHY at 1Mbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim0_reserved_1" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rxpathdly0" pos="14:8" rst="0">
        <comment>
          Rx path delay (in us) for uncoded PHY at 1Mbps.&#10;To be defined by the user. Used for IFS compensation, Rx Power up, and Sync window position timing alignment
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim0_reserved_2" pos="7" rst="0">
      </bits>
      <bits access="rw" name="txpathdly0" pos="6:0" rst="0">
        <comment>
          Tx path delay (in us) for uncoded PHY at 1Mbps.&#10;To be defined by the user. Used for IFS compensation
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiotxrxtim1">
      <bits access="r" name="radiotxrxtim1_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="rw" name="rfrxtmda1" pos="22:16" rst="0">
        <comment>
          RF Rx Test Mode Delay Adjustment for uncoded PHY at 2Mbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim1_reserved_1" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rxpathdly1" pos="14:8" rst="0">
        <comment>
          Rx path delay (in us) for uncoded PHY at 2Mbps.&#10;To be defined by the user. Used for IFS compensation, Rx Power up, and Sync window position timing alignment
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim1_reserved_2" pos="7" rst="0">
      </bits>
      <bits access="rw" name="txpathdly1" pos="6:0" rst="0">
        <comment>
          Tx path delay (in us) for uncoded PHY at 2Mbps.&#10;To be defined by the user. Used for IFS compensation
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiotxrxtim2">
      <bits access="rw" name="rxflushpathdly2" pos="31:24" rst="0">
        <comment>
          RF flush path delay (in us) for coded PHY at 125kbps.&#10;To be defined by the user. Used for IFS compensation
        </comment>
      </bits>
      <bits access="rw" name="rfrxtmda2" pos="23:16" rst="0">
        <comment>
          RF Rx Test Mode Delay Adjustment for coded PHY at 125kbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="rw" name="rxpathdly2" pos="15:8" rst="0">
        <comment>
          Rx path delay (in us) for coded PHY at 125kbps and 500kbps.&#10;To be defined by the user. Used for Rx Power up, and Sync window position timing alignment
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim2_reserved_0" pos="7" rst="0">
      </bits>
      <bits access="rw" name="txpathdly2" pos="6:0" rst="0">
        <comment>
          Tx path delay (in us) for coded PHY at 125kbps.&#10;To be defined by the user. Used for IFS compensation
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="radiotxrxtim3">
      <bits access="rw" name="rxflushpathdly3" pos="31:24" rst="0">
        <comment>
          RF flush path delay (in us) for coded PHY at 500kbps.&#10;To be defined by the user. Used for IFS compensation
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim3_reserved_0" pos="23" rst="0">
      </bits>
      <bits access="rw" name="rfrxtmda3" pos="22:16" rst="0">
        <comment>
          RF Rx Test Mode Delay Adjustment for coded PHY at 500kbps.&#10;To be defined by the user
        </comment>
      </bits>
      <bits access="r" name="radiotxrxtim3_reserved_1" pos="15:7" rst="0">
      </bits>
      <bits access="rw" name="txpathdly3" pos="6:0" rst="0">
        <comment>
          Tx path delay (in us) for coded PHY at 500kbps.&#10;To be defined by the user. Used for IFS compensation
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="spiptrcntl0">
      <bits access="rw" name="txoffptr" pos="31:16" rst="0">
        <comment>
          Pointer to the Tx Off sequence address section&#10;Value set by the RW-BLE software
        </comment>
      </bits>
      <bits access="rw" name="txonptr" pos="15:0" rst="0">
        <comment>
          Pointer to the Tx On sequence address section&#10;Value set by the RW-BLE software
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="spiptrcntl1">
      <bits access="rw" name="rxoffptr" pos="31:16" rst="0">
        <comment>
          Pointer to the Rx Off sequence address section&#10;Value set by the RW-BLE software
        </comment>
      </bits>
      <bits access="rw" name="rxonptr" pos="15:0" rst="0">
        <comment>
          Pointer to the Rx On sequence address section&#10;Value set by the RW-BLE software
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="spiptrcntl2">
      <bits access="rw" name="rxlengthptr" pos="31:16" rst="0">
        <comment>
          Pointer to the Received Length write sequence address section. Used in Long Range only.&#10;Value set by the RW-BLE software
        </comment>
      </bits>
      <bits access="rw" name="rssiptr" pos="15:0" rst="0">
        <comment>
          Pointer to the RSSI read sequence address section.&#10;Value set by the RW-BLE software
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="spiptrcntl3">
      <bits access="r" name="spiptrcntl3_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rxpkttypptr" pos="15:0" rst="0">
        <comment>
          Pointer to the Received Packet Type indication sequence address section&#10;Value set by the RW-BLE software
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aescntl">
      <bits access="r" name="aescntl_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rw" name="aes_mode" pos="1" rst="0">
        <comment>
          0: Cipher mode &#10;1: Decipher mode 
        </comment>
      </bits>
      <bits access="w" name="aes_start" pos="0" rst="0">
        <comment>
          Writing a 1 starts AES-128 ciphering/deciphering process. &#10;This bit is reset once the process is finished (i.e. ble_crypt_irq interrupt occurs, even masked) 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aeskey31_0">
      <bits access="rw" name="aeskey31_0" pos="31:0" rst="0">
        <comment>
          AES encryption 128-bit key. Bit 31 down to 0 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aeskey63_32">
      <bits access="rw" name="aeskey63_32" pos="31:0" rst="0">
        <comment>
          AES encryption 128-bit key. Bit 63 down to 32 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aeskey95_64">
      <bits access="rw" name="aeskey95_64" pos="31:0" rst="0">
        <comment>
          AES encryption 128-bit key. Bit 95 down to 64 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aeskey127_96">
      <bits access="rw" name="aeskey127_96" pos="31:0" rst="0">
        <comment>
          AES encryption 128-bit key. Bit 127 down to 96 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aesptr">
      <bits access="r" name="aesptr_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="aesptr" pos="15:0" rst="0">
        <comment>
          Pointer to the memory zone where the block to cipher using AES-128 is stored.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="txmicval">
      <bits access="r" name="txmicval" pos="31:0" rst="0">
        <comment>
          AES-CCM plain MIC value. Valid on when MIC has been calculated (in Tx)
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxmicval">
      <bits access="r" name="rxmicval" pos="31:0" rst="0">
        <comment>
          AES-CCM plain MIC value. Valid on when MIC has been extracted from Rx packet
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rftestcntl">
      <bits access="rw" name="infiniterx" pos="31" rst="0">
        <comment>
          Applicable to all event type&#10;0: Normal mode of operation &#10;1: Infinite Rx window 
        </comment>
      </bits>
      <bits access="r" name="rftestcntl_reserved_0" pos="30:28" rst="0">
      </bits>
      <bits access="rw" name="rxpktcnten" pos="27" rst="0">
        <comment>
          Applicable in RF Direct Rx Test mode only&#10;0: Rx packet count disabled&#10;1: Rx packet count enabled, and reported in CS-RXCCMPKTCNT and RFTESTRXSTAT-RXPKTCNT on RF abort command
        </comment>
      </bits>
      <bits access="r" name="rftestcntl_reserved_1" pos="26" rst="0">
      </bits>
      <bits access="rw" name="percount_mode" pos="25:24" rst="0">
        <comment>
          Applicable in RF Direct Rx Test mode only, and when RXPKTCNTEN equals to 1&#10;00: Counts number of correctly received packets (no error)&#10;01: Counts number of Access Address error detection only&#10;10: Counts number of CRC Error detection only (or any error leading to CRC error, such as length error or Rx time error)&#10;11: Counts Reception Error detected
        </comment>
      </bits>
      <bits access="r" name="rftestcntl_reserved_2" pos="23:16" rst="0">
      </bits>
      <bits access="rw" name="infinitetx" pos="15" rst="0">
        <comment>
          Applicable to all event type&#10;0: Normal mode of operation &#10;1: Infinite Tx packet. Normal start of a packet but endless payload
        </comment>
      </bits>
      <bits access="rw" name="txlengthsrc" pos="14" rst="0">
        <comment>
          Applicable to all event type&#10;0: Normal mode of operation: TxDESC-&lt;TXADVLEN/TXLEN&gt; controls the Tx packet payload size&#10;1: Uses RFTESTCNTL-TXLENGTH packet length (can support up to 512 bytes transmit)
        </comment>
      </bits>
      <bits access="rw" name="prbstype" pos="13" rst="0">
        <comment>
          Defines the PRBS type in use &#10;0: Tx Packet Payload are PRBS9 type &#10;1: Tx Packet Payload are PRBS15 type 
        </comment>
      </bits>
      <bits access="rw" name="txpldsrc" pos="12" rst="0">
        <comment>
          Applicable to all event type&#10;0: Tx Packet Payload source is the Control Structure &#10;1: Tx Packet Payload are PRBS generator 
        </comment>
      </bits>
      <bits access="rw" name="txpktcnten" pos="11" rst="0">
        <comment>
          Applicable in RF Direct Tx Test mode only&#10;0: Tx packet count disabled&#10;1: Tx packet count enabled, and reported in CS-TXCCMPKTCNT and RFTESTTXSTAT-TXPKTCNT on RF abort command
        </comment>
      </bits>
      <bits access="r" name="rftestcntl_reserved_3" pos="10:9" rst="0">
      </bits>
      <bits access="rw" name="txlength" pos="8:0" rst="0">
        <comment>
          Applicable to all event type, valid when RFTESTCNTL-TXLENGTHSRC=1&#10;Tx packet length in number of byte
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rftesttxstat">
      <bits access="rw" name="txpktcnt" pos="31:0" rst="0">
        <comment>
          Reports number of transmitted packet during Test Modes.&#10;Value is valid if RFTESTCNTL-TXPKTCNTEN is set
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rftestrxstat">
      <bits access="rw" name="rxpktcnt" pos="31:0" rst="0">
        <comment>
          Reports number of correctly received packet during Test Modes (no sync error, no CRC error).&#10;Value is valid if RFTESTCNTL-RXPKTCNTEN is set
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="timgencntl">
      <bits access="r" name="timgencntl_reserved_0" pos="31:26" rst="0">
      </bits>
      <bits access="rw" name="prefetchabort_time" pos="25:16" rst="510">
        <comment>
          Defines the instant in half us at which immediate abort is required after anticipated pre-fetch abort 
        </comment>
      </bits>
      <bits access="r" name="timgencntl_reserved_1" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="prefetch_time" pos="8:0" rst="0">
        <comment>
          Defines Exchange Table pre-fetch instant in half us 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="grosstimtgt">
      <bits access="r" name="grosstimtgt_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="rw" name="grosstarget" pos="22:0" rst="0">
        <comment>
          Gross Timer Target value on which a ble_grosstgtim_irq must be generated. &#10;This timer has a precision of 10ms: interrupt is generated only when GROSSTARGET = CLKN[27:5] and CLKN[4:0] = 0. 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="finetimtgt">
      <bits access="r" name="finetimtgt_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="finetarget" pos="27:0" rst="0">
        <comment>
          Fine Timer Target value on which a ble_finetgtim_irq must be generated. &#10;This timer has a precision of 312.5us: interrupt is generated only when FINETARGET = CLKN
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clkntgt">
      <bits access="r" name="clkntgt_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="clkntarget" pos="27:0" rst="0">
        <comment>
          CLKN Target value. &#10;This timer has a precision of 312.5us: interrupt is generated only when CLKNTGT = CLKN and HMICROSECTGT = FINECNT
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="hmicrosectgt">
      <bits access="r" name="hmicrosectgt_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="hmicrosectarget" pos="9:0" rst="0">
        <comment>
          Half microsecond Target value. &#10;This timer has a precision of 0.5us: interrupt is generated only when CLKNTGT = CLKN and HMICROSECTGT = FINECNT
        </comment>
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="rw" name="leschcntl">
      <bits access="s" name="start_evt" pos="31" rst="0">
        <comment>
        bit type is changed from wos to s.

          Request the RW-BLE Core to start an event, when written with a 1. Resets at 0 when action is  performed. No action happens if it is written with 0.
        </comment>
      </bits>
      <bits access="r" name="leschcntl_reserved_0" pos="30:4" rst="0">
      </bits>
      <bits access="rw" name="entry_idx" pos="3:0" rst="0">
        <comment>
          Indicates the Frame scheduler entry index which has to be used when START_EVT is set. This value is taken into account only when there is no new pending entry to process
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="startevtclkn">
      <bits access="r" name="startevtclkn_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="r" name="startevtclknts" pos="27:0" rst="0">
        <comment>
          Value of the CLKN counter when ble_start_irq is generated
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="startevtfinecnt">
      <bits access="r" name="startevtfinecnt_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="startevtfinecntts" pos="9:0" rst="0">
        <comment>
          Value of the fine counter when ble_start_irq is generated
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="endevtclkn">
      <bits access="r" name="endevtclkn_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="r" name="endevtclknts" pos="27:0" rst="0">
        <comment>
          Value of the CLKN counter when ble_end_irq is generated
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="endevtfinecnt">
      <bits access="r" name="endevtfinecnt_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="endevtfinecntts" pos="9:0" rst="0">
        <comment>
          Value of the fine counter when ble_end_irq is generated
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="skipevtclkn">
      <bits access="r" name="skipevtclkn_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="r" name="skipevtclknts" pos="27:0" rst="0">
        <comment>
          Value of the CLKN counter when ble_skip_irq is generated
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="skipevtfinecnt">
      <bits access="r" name="skipevtfinecnt_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="skipevtfinecntts" pos="9:0" rst="0">
        <comment>
          Value of the fine counter when ble_skip_irq is generated
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="advtim">
      <bits access="rw" name="tx_auxptr_thr" pos="31:24" rst="0">
        <comment>
          Extended Advertising AuxPtr threshold value (granularity 16us).&#10;Used to determine whether RW-BLE Core has to manage AuxPtr automatically in Tx, or to stop the event and let the RW-BLE Software reschedule chained packet later on a new event.&#10;If set at 0x00, then disables automatic AuxPtr management.
        </comment>
      </bits>
      <bits access="rw" name="rx_auxptr_thr" pos="23:16" rst="0">
        <comment>
          Extended Advertising AuxPtr threshold value (granularity 16us).&#10;Used to determine whether RW-BLE Core has to manage AuxPtr automatically in Rx, or to stop the event and let the RW-BLE Software reschedule chained packet later on a new event.&#10;If set at 0x00, then disables automatic AuxPtr management.
        </comment>
      </bits>
      <bits access="r" name="advtim_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="advint" pos="13:0" rst="0">
        <comment>
          Advertising Packet Interval defines the time interval in between two ADV_xxx packet sent. &#10;Value is in us. &#10;Value  to  program  depends  on  the  used  Advertising  Packet  type  and  the  device  filtering  policy. &#10;Please refer to Table 3-20 for details about ADVINT programming range.  
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="actscancntl">
      <bits access="r" name="actscancntl_reserved_0" pos="31:25" rst="0">
      </bits>
      <bits access="r" name="backoff" pos="24:16" rst="1">
        <comment>
          Active scan mode back-off counter initialization value.  
        </comment>
      </bits>
      <bits access="r" name="actscancntl_reserved_1" pos="15:9" rst="0">
      </bits>
      <bits access="r" name="upperlimit" pos="8:0" rst="1">
        <comment>
          Active scan mode upper limit counter value. 
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="wlcntl">
      <bits access="r" name="wlcntl_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="wlnbdev" pos="23:16" rst="0">
        <comment>
          Number of devices in the White List
        </comment>
      </bits>
      <bits access="rw" name="wlbaseptr" pos="15:0" rst="0">
        <comment>
          Base address pointer of the White List
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wlcurrent">
      <bits access="r" name="wlcurrent_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="wlcurrentptr" pos="15:0" rst="0">
        <comment>
          Current pointer in use for the White List.  
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="peradvlcntl">
      <bits access="r" name="peradvlcntl_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="peradvlnbdev" pos="23:16" rst="0">
        <comment>
          Number of devices in the Periodic Advertiser List
        </comment>
      </bits>
      <bits access="rw" name="peradvlbaseptr" pos="15:0" rst="0">
        <comment>
          Base address pointer of the Periodic Advertiser List
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="peradvlcurrent">
      <bits access="r" name="peradvlcurrent_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="peradvlcurrentptr" pos="15:0" rst="0">
        <comment>
          Current pointer in use for the Periodic Advertiser List
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adilcntl">
      <bits access="r" name="adilcntl_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="nbadi" pos="23:16" rst="0">
        <comment>
          Number of devices in the ADI List
        </comment>
      </bits>
      <bits access="rw" name="adilbaseptr" pos="15:0" rst="0">
        <comment>
          Base address pointer of the ADI List
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adilcurrent">
      <bits access="r" name="adilcurrent_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="adilcurrentptr" pos="15:0" rst="0">
        <comment>
          Current pointer in use for the ADI List
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="search_to">
      <bits access="r" name="search_to_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="search_timeout" pos="5:0" rst="16">
        <comment>
          RAL and List Search engines timeout delay in us. To be counted from the end of packet reception. Force current search procedure to stop when elapses.
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="coexifcntl0">
      <bits access="r" name="coexifcntl0_reserved_0" pos="31:22" rst="0">
      </bits>
      <bits access="rw" name="mwsscanfreqmsk" pos="21:20" rst="0">
        <comment>
          Determines how mws_scan_frequency impacts BLE Tx and Rx &#10;00: mws_scan_frequency has no impact (default mode) &#10;01: mws_scan_frequency can stop BLE Tx, no impact on BT Rx  &#10;10: mws_scan_frequency can stop BLE Rx, no impact on BT Tx &#10;11: mws_scan_frequency can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="wlcrxpriomode" pos="19:18" rst="0">
        <comment>
          Defined Bluetooth Rx ble_rx mode behavior &#10;00: Rx indication including Rx power up delay (starts when correlator is enabled) &#10;01: Rx indication including Rx power up delay &#10;10: Rx High priority indicator  &#10;11: n/a 
        </comment>
      </bits>
      <bits access="rw" name="wlctxpriomode" pos="17:16" rst="0">
        <comment>
          Defined Bluetooth Tx ble_tx mode behavior &#10;00: Tx indication including Tx power up delay &#10;01: Tx indication including Tx power up delay &#10;10: Tx High priority indicator  &#10;11: n/a 
        </comment>
      </bits>
      <bits access="rw" name="mwstxfreqmsk" pos="15:14" rst="0">
        <comment>
          Determines how MWS Tx Frequency impacts BLE Tx and Rx &#10;00: MWS Tx Frequency has no impact (default mode) &#10;01: MWS Tx Frequency can stop BLE Tx, no impact on BLE Rx  &#10;10: MWS Tx Frequency can stop BLE Rx, no impact on BLE Tx &#10;11: MWS Tx Frequency can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="mwsrxfreqmsk" pos="13:12" rst="0">
        <comment>
          Determines how MWS Rx Frequency impacts BLE Tx and Rx &#10;00: MWS Rx Frequency has no impact (default mode) &#10;01: MWS Rx Frequency can stop BLE Tx, no impact on BLE Rx  &#10;10: MWS Rx Frequency can stop BLE Rx, no impact on BLE Tx &#10;11: MWS Rx Frequency can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="mwstxmsk" pos="11:10" rst="0">
        <comment>
          Determines how mws_tx impacts BLE Tx and Rx &#10;00: mws_tx has no impact (default mode) &#10;01: mws_tx can stop BLE Tx, no impact on BLE Rx &#10;10: mws_tx can stop BLE Rx, no impact on BLE Tx &#10;11: mws_tx can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="mwsrxmsk" pos="9:8" rst="0">
        <comment>
          Determines how mws_rx impacts BLE Tx and Rx &#10;00: mws_rx has no impact &#10;01: mws_rx can stop BLE Tx, no impact on BLE Rx (default mode) &#10;10: mws_rx can stop BLE Rx, no impact on BLE Tx &#10;11: mws_rx can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="wlantxmsk" pos="7:6" rst="0">
        <comment>
          Determines how wlan_tx impacts BLE Tx and Rx &#10;00: wlan_tx has no impact (default mode) &#10;01: wlan_tx can stop BLE Tx, no impact on BLE Rx &#10;10: wlan_tx can stop BLE Rx, no impact on BLE Tx &#10;11: wlan_tx can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="wlanrxmsk" pos="5:4" rst="1">
        <comment>
          Determines how wlan_rx impacts BLE Tx and Rx &#10;00: wlan_rx has no impact &#10;01: wlan_rx can stop BLE Tx, no impact on BLE Rx (default mode) &#10;10: wlan_rx can stop BLE Rx, no impact on BLE Tx &#10;11: wlan_rx can stop both BLE Tx and BLE Rx 
        </comment>
      </bits>
      <bits access="rw" name="mwswci_en" pos="3" rst="0">
        <comment>
          Enable  /  Disable  control  of  the  WCI MWS  Coexistence interface. Valid in Dual Mode only. &#10;0: MWS WCI interface disabled &#10;1: MWS WCI interface enabled 
        </comment>
      </bits>
      <bits access="rw" name="mwscoex_en" pos="2" rst="0">
        <comment>
          Enable / Disable control of the MWS Coexistence control. Valid in Dual Mode only.&#10;0: MWS Coexistence interface disabled &#10;1: MWS Coexistence interface enabled 
        </comment>
      </bits>
      <bits access="rw" name="syncgen_en" pos="1" rst="0">
        <comment>
          Determines whether ble_sync is generated or not. &#10;0: ble_sync pulse not generated &#10;1: ble_sync pulse generated 
        </comment>
      </bits>
      <bits access="rw" name="wlancoex_en" pos="0" rst="0">
        <comment>
          Enable / Disable control of the WLAN Coexistence control. &#10;0: WLAN Coexistence interface disabled &#10;1: WLAN Coexistence interface enabled 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="coexifcntl1">
      <bits access="r" name="coexifcntl1_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="rw" name="wlcprxthr" pos="28:24" rst="0">
        <comment>
          Applies on ble_rx if WLCRXPRIOMODE equals "10" &#10;Determines the threshold for Rx priority setting.  &#10;If ble_pti[3:0] output value is greater than WLCRXTHR, then Rx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface 
        </comment>
      </bits>
      <bits access="r" name="coexifcntl1_reserved_1" pos="23:21" rst="0">
      </bits>
      <bits access="rw" name="wlcptxthr" pos="20:16" rst="0">
        <comment>
          Applies on ble_tx if WLCTXPRIOMODE equals "10" &#10;Determines the threshold for Tx priority setting.  &#10;If ble_pti[3:0] output value is greater than WLCTXTHR, then Tx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface 
        </comment>
      </bits>
      <bits access="r" name="coexifcntl1_reserved_2" pos="15" rst="0">
      </bits>
      <bits access="rw" name="wlcpduration" pos="14:8" rst="0">
        <comment>
          Applies on ble_tx when WLCTXPRIOMODE equals to "10" &#10;Applies on ble_rx when WLCRXPRIOMODE equals to "10" &#10;Determines how many us the priority information must be maintained  &#10;Note that if WLCPRURATION = 0x00, then Tx/Rx priority levels are maintained till Tx/Rx EN are deasserted. 
        </comment>
      </bits>
      <bits access="r" name="coexifcntl1_reserved_3" pos="7" rst="0">
      </bits>
      <bits access="rw" name="wlcpdelay" pos="6:0" rst="0">
        <comment>
          Applies on ble_tx when WLCTXPRIOMODE equals to "10" &#10;Applies on ble_rx when WLCRXPRIOMODE equals to "10" &#10;Determines the delay (in us) in Tx/Rx enables rises the time Bluetooth Low Energy Tx/Rx priority has to be provided 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="coexifcntl2">
      <bits access="r" name="coexifcntl2_reserved_0" pos="31:12" rst="0">
      </bits>
      <bits access="rw" name="rx_ant_delay" pos="11:8" rst="0">
        <comment>
          Applies if WLCRXPRIOMODE equals to "01" &#10;Time  (in  us)  by  which  is  anticipated  ble_rx  to  be  provided  before  effective  Radio  receipt operation 
        </comment>
      </bits>
      <bits access="r" name="coexifcntl2_reserved_1" pos="7:4" rst="0">
      </bits>
      <bits access="rw" name="tx_ant_delay" pos="3:0" rst="0">
        <comment>
          Applies if WLCTXPRIOMODE equals to "01" &#10;Time  (in  us)  by  which  is  anticipated  ble_tx  to  be  provided  before  effective  Radio  transmit operation 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="blemprio0">
      <bits access="rw" name="blem7" pos="31:28" rst="3">
        <comment>
          Set Priority value for Passive Scanning
        </comment>
      </bits>
      <bits access="rw" name="blem6" pos="27:24" rst="4">
        <comment>
          Set Priority value for Non-Connectable Advertising
        </comment>
      </bits>
      <bits access="rw" name="blem5" pos="23:20" rst="8">
        <comment>
          Set Priority value for Connectable Advertising BLE message
        </comment>
      </bits>
      <bits access="rw" name="blem4" pos="19:16" rst="9">
        <comment>
          Set Priority value for Active Scanning BLE message
        </comment>
      </bits>
      <bits access="rw" name="blem3" pos="15:12" rst="10">
        <comment>
          Set Priority value for Initiating (Scanning) BLE message
        </comment>
      </bits>
      <bits access="rw" name="blem2" pos="11:8" rst="13">
        <comment>
          Set Priority value for Data Channel transmission BLE message
        </comment>
      </bits>
      <bits access="rw" name="blem1" pos="7:4" rst="14">
        <comment>
          Set Priority value for LLCP BLE message
        </comment>
      </bits>
      <bits access="rw" name="blem0" pos="3:0" rst="15">
        <comment>
          Set Priority value for Initiating (Connection Indication Response) BLE Message 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="blemprio1">
      <bits access="rw" name="blemdefault" pos="31:28" rst="3">
        <comment>
          Set default priority value for other BLE message than those defined above
        </comment>
      </bits>
      <bits access="r" name="blemprio1_reserved_0" pos="27:8" rst="0">
      </bits>
      <bits access="rw" name="blem9" pos="7:4" rst="13">
        <comment>
          Set Priority value for ISO Channel subsequent Tx/Rx attempt
        </comment>
      </bits>
      <bits access="rw" name="blem8" pos="3:0" rst="12">
        <comment>
          Set Priority value for ISO Channel first Tx/Rx attempt
        </comment>
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="rw" name="ralcntl">
      <bits access="r" name="ralcntl_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="ralnbdev" pos="23:16" rst="0">
        <comment>
          Number of devices in RAL Structure 
        </comment>
      </bits>
      <bits access="rw" name="ralbaseptr" pos="15:0" rst="0">
        <comment>
          Start address pointer of the RAL structure 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ralcurrent">
      <bits access="r" name="ralcurrent_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="ralcurrentptr" pos="15:0" rst="0">
        <comment>
          Current pointer of the RAL structure 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ral_local_rnd">
      <bits access="w" name="lrnd_init" pos="31" rst="0">
        <comment>
          Writing a 1 initializes of Local RPA random number generation LFSR &#10;This bit is reset once the LFSR is loaded 
        </comment>
      </bits>
      <bits access="r" name="ral_local_rnd_reserved_0" pos="30:22" rst="0">
      </bits>
      <bits access="rw" name="lrnd_val" pos="21:0" rst="4132623">
        <comment>
          Initialization value for  Local RPA random generation when LRDN_INIT is set to 1, else reports the current Local RPA random number LFSR value 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ral_peer_rnd">
      <bits access="w" name="prnd_init" pos="31" rst="0">
        <comment>
          Writing a 1 initializes of Peer RPA random number generation LFSR &#10;This bit is reset once the LFSR is loaded 
        </comment>
      </bits>
      <bits access="r" name="ral_peer_rnd_reserved_0" pos="30:22" rst="0">
      </bits>
      <bits access="rw" name="prnd_val" pos="21:0" rst="3207408">
        <comment>
          Initialization  value  for  Peer  RPA  random  generation  when  PRDN_INIT  is  set  to  1,  else  reports the current Peer RPA random number LFSR value 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isochancntl0">
      <bits access="r" name="isochancntl0_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="retxacken0" pos="4" rst="0">
        <comment>
          0: No Tx ACK generation in re-Tx&#10;1: Tx ACK generation in re-Tx
        </comment>
      </bits>
      <bits access="rw" name="syncgen0" pos="3" rst="0">
        <comment>
          0: Disable audio_sync0_p generation&#10;1: enable audio_sync0_p generation
        </comment>
      </bits>
      <bits access="rw" name="isochanen0" pos="2" rst="0">
        <comment>
          0: Disable ISO Channel (LLID=0 invalid)&#10;1: Enable ISO Channel (LLID=0 valid)
        </comment>
      </bits>
      <bits access="rw" name="isotype0" pos="1:0" rst="0">
        <comment>
          ISO Channel Type&#10;0x0: Audio Mode 0&#10;0x1-0x3: Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isomutecntl0">
      <bits access="r" name="tog0" pos="31" rst="0">
        <comment>
          Indicates which buffer is in use (direct copy of ET-ISOBUFSEL)
        </comment>
      </bits>
      <bits access="r" name="isomutecntl0_reserved_0" pos="30:22" rst="0">
      </bits>
      <bits access="rw" name="mute_sink0" pos="21" rst="0">
        <comment>
          HW mute control:&#10;0: Do not mute on bad reception of an ISO packet&#10;1: Mute after data or bad reception, with the pattern stored in MUTE_PATTERN0
        </comment>
      </bits>
      <bits access="rw" name="mute_source0" pos="20" rst="0">
        <comment>
          HW mute control:&#10;0: Provides Source buffer to the Packet Controller for Tx operations&#10;1: Forces null length packet to be sent as a replacement of ISO Packets
        </comment>
      </bits>
      <bits access="rw" name="invl0_1" pos="19:18" rst="2">
        <comment>
          SW mute status for Audio buffer 0 (i.e updated when ET-ISOBUFSEL=0)&#10;Mute if not null. Please refer to Table 3-18 for details
        </comment>
      </bits>
      <bits access="rw" name="invl0_0" pos="17:16" rst="2">
        <comment>
          SW mute status for Audio buffer 0 (i.e updated when ET-ISOBUFSEL=1)&#10;Mute if not null. Please refer to Table 3-18 for details
        </comment>
      </bits>
      <bits access="r" name="isomutecntl0_reserved_1" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="mute_pattern0" pos="7:0" rst="0">
        <comment>
          Value of the ISO channel 0 Mute Pattern to be used when HW muting is enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isocurrenttxptr0">
      <bits access="rw" name="iso0txptr0" pos="31:16" rst="0">
        <comment>
          Tx ISO Buffer pointer 0 of ISO Channel 0.&#10;Used by Packet controller when ET-ISOBUFSEL=0
        </comment>
      </bits>
      <bits access="rw" name="iso0txptr1" pos="15:0" rst="0">
        <comment>
          Tx ISO Buffer pointer 1 of ISO Channel 0.&#10;Used by Packet controller when ET-ISOBUFSEL=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isocurrentrxptr0">
      <bits access="rw" name="iso0rxptr0" pos="31:16" rst="0">
        <comment>
          Rx ISO Buffer pointer 0 of ISO Channel 0.&#10;Used by Packet controller when ET-ISOBUFSEL=0
        </comment>
      </bits>
      <bits access="rw" name="iso0rxptr1" pos="15:0" rst="0">
        <comment>
          Rx ISO Buffer pointer 1 of ISO Channel 0.&#10;Used by Packet controller when ET-ISOBUFSEL=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isotrcntl0">
      <bits access="r" name="isotrcntl0_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="iso0rxlen" pos="23:16" rst="0">
        <comment>
          Negotiated, maximum expected number of bytes for ISO Channel 0 Rx payloads
        </comment>
      </bits>
      <bits access="r" name="isotrcntl0_reserved_1" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="iso0txlen" pos="7:0" rst="0">
        <comment>
          Negotiated, number of bytes for ISO Channel 0 Tx payloads
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isoevtcntoffsetl0">
      <bits access="rw" name="evt_cnt_offsetl0" pos="31:0" rst="0">
        <comment>
          LSB part of EVT_CNT_OFFSET0[39:0] field
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isoevtcntoffsetu0">
      <bits access="r" name="isoevtcntoffsetu0_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="evt_cnt_offsetu0" pos="6:0" rst="0">
        <comment>
          MSB part of EVT_CNT_OFFSET0[39:0] field
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="isochancntl1">
      <bits access="r" name="isochancntl1_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="retxacken1" pos="4" rst="0">
        <comment>
          0: No Tx ACK generation in re-Tx&#10;1: Tx ACK generation in re-Tx
        </comment>
      </bits>
      <bits access="rw" name="syncgen1" pos="3" rst="0">
        <comment>
          0: Disable audio_sync1_p generation&#10;1: enable audio_sync1_p generation
        </comment>
      </bits>
      <bits access="rw" name="isochanen1" pos="2" rst="0">
        <comment>
          0: Disable ISO Channel (LLID=0 invalid)&#10;1: Enable ISO Channel (LLID=0 valid)
        </comment>
      </bits>
      <bits access="rw" name="isotype1" pos="1:0" rst="0">
        <comment>
          ISO Channel Type&#10;0x0: Audio Mode 0&#10;0x1-0x3: Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isomutecntl1">
      <bits access="r" name="tog1" pos="31" rst="0">
        <comment>
          Indicates which buffer is in use (direct copy of ET-ISOBUFSEL)
        </comment>
      </bits>
      <bits access="r" name="isomutecntl1_reserved_0" pos="30:22" rst="0">
      </bits>
      <bits access="rw" name="mute_sink1" pos="21" rst="0">
        <comment>
          HW mute control:&#10;0: Do not mute on bad reception of an ISO packet&#10;1: Mute after data or bad reception, with the pattern stored in MUTE_PATTERN0
        </comment>
      </bits>
      <bits access="rw" name="mute_source1" pos="20" rst="0">
        <comment>
          HW mute control:&#10;0: Provides Source buffer to the Packet Controller for Tx operations&#10;1: Forces null length packet to be sent as a replacement of ISO Packets
        </comment>
      </bits>
      <bits access="rw" name="invl1_1" pos="19:18" rst="2">
        <comment>
          SW mute status for Audio buffer 1 (i.e updated when ET-ISOBUFSEL=0)&#10;Mute if not null. Please refer to Table 3-18 for details
        </comment>
      </bits>
      <bits access="rw" name="invl1_0" pos="17:16" rst="2">
        <comment>
          SW mute status for Audio buffer 1 (i.e updated when ET-ISOBUFSEL=1)&#10;Mute if not null. Please refer to Table 3-18 for details
        </comment>
      </bits>
      <bits access="r" name="isomutecntl1_reserved_1" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="mute_pattern1" pos="7:0" rst="0">
        <comment>
          Value of the ISO channel 1 Mute Pattern to be used when HW muting is enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isocurrenttxptr1">
      <bits access="rw" name="iso1txptr0" pos="31:16" rst="0">
        <comment>
          Tx ISO Buffer pointer 0 of ISO Channel 1.&#10;Used by Packet controller when ET-ISOBUFSEL=0
        </comment>
      </bits>
      <bits access="rw" name="iso1txptr1" pos="15:0" rst="0">
        <comment>
          Tx ISO Buffer pointer 1 of ISO Channel 1.&#10;Used by Packet controller when ET-ISOBUFSEL=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isocurrentrxptr1">
      <bits access="rw" name="iso1rxptr0" pos="31:16" rst="0">
        <comment>
          Rx ISO Buffer pointer 0 of ISO Channel 1.&#10;Used by Packet controller when ET-ISOBUFSEL=0
        </comment>
      </bits>
      <bits access="rw" name="iso1rxptr1" pos="15:0" rst="0">
        <comment>
          Rx ISO Buffer pointer 1 of ISO Channel 1.&#10;Used by Packet controller when ET-ISOBUFSEL=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isotrcntl1">
      <bits access="r" name="isotrcntl1_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="iso1rxlen" pos="23:16" rst="0">
        <comment>
          Negotiated, maximum expected number of bytes for ISO Channel 1 Rx payloads
        </comment>
      </bits>
      <bits access="r" name="isotrcntl1_reserved_1" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="iso1txlen" pos="7:0" rst="0">
        <comment>
          Negotiated, number of bytes for ISO Channel 1 Tx payloads
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isoevtcntoffsetl1">
      <bits access="rw" name="evt_cnt_offsetl1" pos="31:0" rst="0">
        <comment>
          LSB part of EVT_CNT_OFFSET1[39:0] field
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isoevtcntoffsetu1">
      <bits access="r" name="isoevtcntoffsetu1_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="evt_cnt_offsetu1" pos="6:0" rst="0">
        <comment>
          MSB part of EVT_CNT_OFFSET1[39:0] field
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="isochancntl2">
      <bits access="r" name="isochancntl2_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="retxacken2" pos="4" rst="0">
        <comment>
          0: No Tx ACK generation in re-Tx&#10;1: Tx ACK generation in re-Tx
        </comment>
      </bits>
      <bits access="rw" name="syncgen2" pos="3" rst="0">
        <comment>
          0: Disable audio_sync2_p generation&#10;1: enable audio_sync2_p generation
        </comment>
      </bits>
      <bits access="rw" name="isochanen2" pos="2" rst="0">
        <comment>
          0: Disable ISO Channel (LLID=0 invalid)&#10;1: Enable ISO Channel (LLID=0 valid)
        </comment>
      </bits>
      <bits access="rw" name="isotype2" pos="1:0" rst="0">
        <comment>
          ISO Channel Type&#10;0x0: Audio Mode 0&#10;0x1-0x3: Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isomutecntl2">
      <bits access="r" name="tog2" pos="31" rst="0">
        <comment>
          Indicates which buffer is in use (direct copy of ET-ISOBUFSEL)
        </comment>
      </bits>
      <bits access="r" name="isomutecntl2_reserved_0" pos="30:22" rst="0">
      </bits>
      <bits access="rw" name="mute_sink2" pos="21" rst="0">
        <comment>
          HW mute control:&#10;0: Do not mute on bad reception of an ISO packet&#10;1: Mute after data or bad reception, with the pattern stored in MUTE_PATTERN0
        </comment>
      </bits>
      <bits access="rw" name="mute_source2" pos="20" rst="0">
        <comment>
          HW mute control:&#10;0: Provides Source buffer to the Packet Controller for Tx operations&#10;1: Forces null length packet to be sent as a replacement of ISO Packets
        </comment>
      </bits>
      <bits access="rw" name="invl2_1" pos="19:18" rst="2">
        <comment>
          SW mute status for Audio buffer 2 (i.e updated when ET-ISOBUFSEL=0)&#10;Mute if not null. Please refer to Table 3-18 for details
        </comment>
      </bits>
      <bits access="rw" name="invl2_0" pos="17:16" rst="2">
        <comment>
          SW mute status for Audio buffer 2 (i.e updated when ET-ISOBUFSEL=1)&#10;Mute if not null. Please refer to Table 3-18 for details
        </comment>
      </bits>
      <bits access="r" name="isomutecntl2_reserved_1" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="mute_pattern2" pos="7:0" rst="0">
        <comment>
          Value of the ISO channel 2 Mute Pattern to be used when HW muting is enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isocurrenttxptr2">
      <bits access="rw" name="iso2txptr0" pos="31:16" rst="0">
        <comment>
          Tx ISO Buffer pointer 0 of ISO Channel 2.&#10;Used by Packet controller when ET-ISOBUFSEL=0
        </comment>
      </bits>
      <bits access="rw" name="iso2txptr1" pos="15:0" rst="0">
        <comment>
          Tx ISO Buffer pointer 1 of ISO Channel 2.&#10;Used by Packet controller when ET-ISOBUFSEL=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isocurrentrxptr2">
      <bits access="rw" name="iso2rxptr0" pos="31:16" rst="0">
        <comment>
          Rx ISO Buffer pointer 0 of ISO Channel 2.&#10;Used by Packet controller when ET-ISOBUFSEL=0
        </comment>
      </bits>
      <bits access="rw" name="iso2rxptr1" pos="15:0" rst="0">
        <comment>
          Rx ISO Buffer pointer 1 of ISO Channel 2.&#10;Used by Packet controller when ET-ISOBUFSEL=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isotrcntl2">
      <bits access="r" name="isotrcntl2_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="iso2rxlen" pos="23:16" rst="0">
        <comment>
          Negotiated, maximum expected number of bytes for ISO Channel 2 Rx payloads
        </comment>
      </bits>
      <bits access="r" name="isotrcntl2_reserved_1" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="iso2txlen" pos="7:0" rst="0">
        <comment>
          Negotiated, number of bytes for ISO Channel 2 Tx payloads
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isoevtcntoffsetl2">
      <bits access="rw" name="evt_cnt_offsetl2" pos="31:0" rst="0">
        <comment>
          LSB part of EVT_CNT_OFFSET2[39:0] field
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="isoevtcntoffsetu2">
      <bits access="r" name="isoevtcntoffsetu2_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="evt_cnt_offsetu2" pos="6:0" rst="0">
        <comment>
          MSB part of EVT_CNT_OFFSET2[39:0] field
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="bt_core.xml">
  <module name="bt_core" category="BT">
    <reg protect="rw" name="common_ctrl">
      <bits access="r" name="typ" pos="31:28" rst="2">
        <comment>
          Version type of bt_core. 1 for BTDM old version. 2 for BTDM new version. 3 for BLE only.
        </comment>
      </bits>
      <bits access="r" name="rel" pos="27:24" rst="1">
        <comment>
          Major release number of bt_core
        </comment>
      </bits>
      <bits access="r" name="upg" pos="23:20" rst="0">
        <comment>
          Upgrade number of bt_core
        </comment>
      </bits>
      <bits access="r" name="common_ctrl_reserved_0" pos="19:2" rst="0">
      </bits>
      <bits access="rw" name="rf_ext_slave" pos="1" rst="0">
        <comment>
          Set to 1 when working as a plug-in RF&amp;modem board. Set to 0 in all other modes
        </comment>
      </bits>
      <bits access="rw" name="rf_ext_master" pos="0" rst="0">
        <comment>
          Set to 1 when using plug-in RF&amp;modem board. Set to 0 in all other modes
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tport_ctrl">
      <bits access="r" name="tport_ctrl_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="tport_clk_sel" pos="27:24" rst="0">
        <comment>
          select tport clock
        </comment>
      </bits>
      <bits access="r" name="tport_ctrl_reserved_1" pos="23:20" rst="0">
      </bits>
      <bits access="rw" name="tport_trig_sel" pos="19:16" rst="0">
        <comment>
          select tport trigger
        </comment>
      </bits>
      <bits access="r" name="tport_ctrl_reserved_2" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="tport_data1_sel" pos="11:8" rst="0">
        <comment>
          select tport data1
        </comment>
      </bits>
      <bits access="r" name="tport_ctrl_reserved_3" pos="7:4" rst="0">
      </bits>
      <bits access="rw" name="tport_data0_sel" pos="3:0" rst="9">
        <comment>
          select tport data0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rf_pllfreq_sel_0">
      <bits access="rw" name="pllfreq_sel_31_0" pos="31:0" rst="0">
        <comment>
          select pll frequency for rf/modem for channel 0~31
1 for 214.5MHz and 0 for 208MHz
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rf_pllfreq_sel_1">
      <bits access="rw" name="pllfreq_sel_63_32" pos="31:0" rst="0">
        <comment>
          select pll frequency for rf/modem for channel 32~63
1 for 214.5MHz and 0 for 208MHz
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rf_pllfreq_sel_2">
      <bits access="r" name="rf_pllfreq_sel_2_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="pllfreq_sel_78_64" pos="14:0" rst="0">
        <comment>
          select pll frequency for rf/modem for channel 64~78
1 for 214.5MHz and 0 for 208MHz
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="trx_on_force">
      <bits access="r" name="trx_on_force_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="tx_cal_en" pos="5" rst="0">
        <comment>
          tx calibration enable
        </comment>
      </bits>
      <bits access="rw" name="rx_cal_en" pos="4" rst="0">
        <comment>
          rx calibration enable
        </comment>
      </bits>
      <bits access="rw" name="txon_force" pos="3" rst="0">
        <comment>
          force txon for rf to txon_value when txon_force is 1
        </comment>
      </bits>
      <bits access="rw" name="txon_value" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rxon_force" pos="1" rst="0">
        <comment>
          force rxon for rf to rxon_value when rxon_force is 1
        </comment>
      </bits>
      <bits access="rw" name="rxon_value" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="trx_on_timing">
      <bits access="rw" name="modem_txon_delay" pos="31:24" rst="32">
        <comment>
          delay time in us to enable modem tx after link layer txon enable
        </comment>
      </bits>
      <bits access="rw" name="modem_rf_txoff_delay" pos="23:16" rst="5">
        <comment>
          delay time in us to disable modem&amp;rf tx after link layer txon disable
        </comment>
      </bits>
      <bits access="rw" name="modem_rxon_delay" pos="15:8" rst="32">
        <comment>
          delay time in us to enable modem rx after link layer rxon enable
        </comment>
      </bits>
      <bits access="rw" name="modem_rf_rxoff_delay" pos="7:0" rst="0">
        <comment>
          delay time in us to disable modem&amp;rf rx after link layer rxon disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rccal_ctrl">
      <bits access="r" name="rccal_ctrl_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="rccal_length" pos="15:8" rst="32">
        <comment>
          number of rc clock cycles when doing rc calibration
        </comment>
      </bits>
      <bits access="r" name="rccal_ctrl_reserved_1" pos="7:2" rst="0">
      </bits>
      <bits access="rw" name="rccal_auto" pos="1" rst="1">
        <comment>
          enable automatic rc calibration when BT wakeup
        </comment>
      </bits>
      <bits access="rs" name="rccal_start" pos="0" rst="0">
        <comment>
        bit type is changed from w1s to rs.

          rc calibration start by software
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rccal_output">
      <bits access="r" name="rccal_done" pos="31" rst="0">
        <comment>
          indicate rc caliration done
        </comment>
      </bits>
      <bits access="r" name="rccal_output_reserved_0" pos="30:18" rst="0">
      </bits>
      <bits access="r" name="rccal_result" pos="17:0" rst="0">
        <comment>
          number of reference clock cycles when doing rc calibration.
F(rc) = F(ref) * rccal_length / rccal_result
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="coex_ctrl">
      <bits access="r" name="coex_ctrl_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="bt_active_mode" pos="5:4" rst="0">
        <comment>
          BT active indicater:
0: rf_txon
1: rf_rxon
2: rf_txon | rf_rxon
3: modem_txon | modem_rxon
        </comment>
      </bits>
      <bits access="r" name="coex_ctrl_reserved_1" pos="3" rst="0">
      </bits>
      <bits access="rw" name="mws_mask_bt_en" pos="2" rst="0">
        <comment>
          0: BT tx will not be masked
1: BT tx will be masked
        </comment>
      </bits>
      <bits access="rw" name="mws_mask_bt_mode" pos="1:0" rst="0">
        <comment>
          BT tx will be masked when:
0: mws_tx
1: mws_rx
2: mws_tx | mws_rx
3: mws_tx &amp; mws_rx
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="bt_modem.xml">
  <module name="bt_modem" category="BT">
    <reg protect="rw" name="bypass_ctrl">
      <bits access="r" name="bypass_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="bypass_dccancel1" pos="15" rst="0">
        <comment>
          Bypass DC Cancel1
1'h0:: not_bypass: RX DC Cancel is not bypassed
1'h1:: bypass: RX DC Cancel is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_dccancel2" pos="14" rst="1">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="bypass_mixer" pos="13" rst="0">
        <comment>
          Bypass Mixer
1'h0:: not_bypass: RX Mixer is not bypassed
1'h1:: bypass: RX Mixer is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_srrc" pos="12" rst="0">
        <comment>
          Bypass Square-root-raised-cosine Filter
1'h0:: not_bypass: RX SRRC filter is not bypassed
1'h1:: bypass: RX SRRC filter is bypassed
        </comment>
      </bits>
      <bits access="r" name="bypass_ctrl_reserved_1" pos="11:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="bypass_derr1_gfsk" pos="8" rst="0">
        <comment>
          Bypass GFSK Derr1
1'h0:: not_bypass: RX GFSK Derr1 is not bypassed
1'h1:: bypass: RX GFSK Derr1 is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_derr2_gfsk" pos="7" rst="0">
        <comment>
          Bypass GFSK Derr2
1'h0:: not_bypass: RX GFSK Derr2 is not bypassed
1'h1:: bypass: RX GFSK Derr2 is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_patch_gfsk" pos="6" rst="0">
        <comment>
          Bypass GFSK Patch
1'h0:: not_bypass: GFSK Patch is not bypassed
1'h1:: bypass: GFSK Patch is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_smppt_gfsk" pos="5" rst="0">
        <comment>
          Bypass GFSK Sample Step
1'h0:: not_bypass: RX GFSK Sample Step is 1
1'h1:: bypass: RX GFSK Sample Step is 0
        </comment>
      </bits>
      <bits access="rw" name="bypass_derr1_dpsk" pos="4" rst="0">
        <comment>
          Bypass DPSK Derr1
1'h0:: not_bypass: RX DPSK Derr1 is not bypassed
1'h1:: bypass: RX DPSK Derr1 is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_derr2_dpsk" pos="3" rst="0">
        <comment>
          Bypass DPSK Derr2
1'h0:: not_bypass: RX DPSK Derr2 is not bypassed
1'h1:: bypass: RX DPSK Derr2 is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_patch_dpsk" pos="2" rst="0">
        <comment>
          Bypass DPSK Patch
1'h0:: not_bypass: DPSK Patch is not bypassed
1'h1:: bypass: DPSK Patch is bypassed
        </comment>
      </bits>
      <bits access="rw" name="bypass_smppt_dpsk" pos="1" rst="0">
        <comment>
          Bypass DPSK Sample Step
1'h0:: not_bypass: RX DPSK Sample Step is 1
1'h1:: bypass: RX DPSK Sample Step is 0
        </comment>
      </bits>
      <bits access="r" name="bypass_ctrl_reserved_2" pos="0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sw_swap_dccal">
      <bits access="r" name="sw_swap_dccal_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="swch_clk_saradc" pos="15" rst="0">
        <comment>
          Switch SAR ADC Sample Clock Edge
1'h0:: not_switch: SAR ADC clock edge is not switched
1'h1:: switch: SAR ADC clock edge is switched
        </comment>
      </bits>
      <bits access="rw" name="swch_clk_adc" pos="14" rst="0">
        <comment>
          Switch ADC Clock Edge
1'h0:: not_switch: ADC clock edge is not switched
1'h1:: switch: ADC clock edge is switched
        </comment>
      </bits>
      <bits access="rw" name="sel_sync" pos="13" rst="0">
        <comment>
          Select New Packet
1'h0:: from_LL: newpacket_dsp is from baseband
1'h1:: from_reg: newpacket_dsp is from newpacket_reg
        </comment>
      </bits>
      <bits access="rw" name="swch_clk_am_dac" pos="12" rst="1">
        <comment>
          Switch AM DAC Clock Edge
1'h0:: not_switch: AM DAC clock edge is not switched
1'h1:: switch: AM DAC clock edge is switched
        </comment>
      </bits>
      <bits access="rw" name="swch_clk_pm_dac" pos="11" rst="1">
        <comment>
          Switch PM DAC Clock Edge
1'h0:: not_switch: PM DAC clock edge is not switched
1'h1:: switch: PM DAC clock edge is switched
        </comment>
      </bits>
      <bits access="rw" name="lpf_dwidth_sel" pos="10:9" rst="1">
        <comment>
          LPF Data Width Select
2'h0:: shift_9bits
2'h1:: shift_8bits
2'h2:: shift_7bits
2'h3:: shift_6bits
        </comment>
      </bits>
      <bits access="rw" name="swch_sign_am" pos="8" rst="0">
        <comment>
          Switch TX AM DAC datai sign
1'h0:: unsigned: TX AM DAC datai is unsigned; analog common format
1'h1:: signed: TX AM DAC datai is signed
        </comment>
      </bits>
      <bits access="rw" name="swch_sign_pm" pos="7" rst="0">
        <comment>
          Switch TX PM DAC dataq sign
1'h0:: unsigned: TX PM DAC dataq is unsigned; analog common format
1'h1:: signed: TX PM DAC dataq is signed
        </comment>
      </bits>
      <bits access="rw" name="swch_sign_rx" pos="6" rst="0">
        <comment>
          Switch RX ADC IQ data sign
1'h0:: unsigned: RX ADC data is unsigned; analog common format
1'h1:: signed: RX ADC data is signed
        </comment>
      </bits>
      <bits access="rw" name="iq_sel_pol" pos="5" rst="0">
        <comment>
          IQ_SEL Polarity
1'h0:: iq_sel_inv
1'h1:: iq_sel_raw
        </comment>
      </bits>
      <bits access="rw" name="swch_clk_52m_tx" pos="4" rst="1">
        <comment>
          TX link 52M clk edge switch
1'h0:: Not_Switch
1'h1:: Switch
        </comment>
      </bits>
      <bits access="r" name="sw_swap_dccal_reserved_1" pos="3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sel_sumerr_range" pos="2:0" rst="3">
        <comment>
          Sum Error Range Control
3'h0 Left shift 3 bits of sum err and limit sumerr within [-2^-4, 2^-4]
3'h1 Left shift 2 bits of sum err and limit sumerr within [-2^-3, 2^-3]
3'h2 Left shift 1 bits of sum err and limit sumerr within [-2^-2, 2^-2]
3'h3 Hold the sum err
3'h4 Right shift 1 bits of sum err
3'h5 Right shift 2 bits of sum err
3'h6 Right shift 3 bits of sum err
3'h7 Right shift 4 bits of sum err;
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dem750_afc_freq">
      <bits access="r" name="dem750_afc_freq_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="afc_smtif" pos="15:0" rst="58075">
        <comment>
          Set the AFC frequency of dem750 of rx link
dec2hex(2^16-round(2*740/13e3*2^16))
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dpsk_gfsk_tx_ctrl">
      <bits access="r" name="dpsk_gfsk_tx_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_gain_dpsk" pos="15:8" rst="196">
        <comment>
          DPSK TX Gain in EDR
        </comment>
      </bits>
      <bits access="rw" name="delay_gfsk" pos="7:4" rst="4">
        <comment>
          Set the delay of input gfsk symbol, delay unit is 13MHz clock cycle.
        </comment>
      </bits>
      <bits access="rw" name="delay_dpsk" pos="3:0" rst="8">
        <comment>
          Set the delay of input dpsk symbol, delay unit is 13MHz clock cycle.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_gain_ctrl">
      <bits access="r" name="tx_gain_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="cnt_guard_ini" pos="15:10" rst="40">
        <comment>
          Control the guard time length of bt frame
Guard time = (55-cnt_guard_ini)*T13Mclk
        </comment>
      </bits>
      <bits access="rw" name="tx_power_gain_sel" pos="9" rst="1">
        <comment>
          LL tx_power and debug tx_apc selection.
1'h1:: selected LL tx_power
1'h0::selected debug tx_apc
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_bypass" pos="8" rst="0">
        <comment>
          according to tx_power mapping digital gain.
1'h1:: bypass auto gain mapping function
1'h0:: no bypass
        </comment>
      </bits>
      <bits access="rw" name="tx_gain_gfsk" pos="7:0" rst="124">
        <comment>
          GFSK TX Gain in BR
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_out1">
      <bits access="r" name="rssi_out1_reserved_0" pos="31:26" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_out_post" pos="25:16" rst="0">
        <comment>
          RSSI post SRRC Output.
        </comment>
      </bits>
      <bits access="r" name="rssi_out1_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_out_pre" pos="9:0" rst="0">
        <comment>
          RSSI pre SRRC Output.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sw_ctrl">
      <bits access="r" name="sw_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_lock_by_agc_pre" pos="15" rst="0">
        <comment>
          Receiver Strength Signal Indicator lock by agc done signal
        </comment>
      </bits>
      <bits access="rw" name="swap_iq" pos="14" rst="0">
        <comment>
          Swap I/Q
1'h0:: no_swap: I/Q is not swaped
1'h1:: swap: I/Q is swaped
        </comment>
      </bits>
      <bits access="rw" name="swap_iq_dccl_0" pos="13" rst="0">
        <comment>
          Swap I/Q of ddcl input data
1'h0:: no_swap: I/Q of ddcl input data is not swaped
1'h1:: swap: I/Q of ddcl input data is swaped
        </comment>
      </bits>
      <bits access="rw" name="rssi_lock_by_agc_post" pos="12" rst="0">
        <comment>
          Receiver Strength Signal Indicator lock by agc done signal
        </comment>
      </bits>
      <bits access="rw" name="swap_iq_mixer_0" pos="11" rst="0">
        <comment>
          Swap I/Q of Mixer output data
1'h0:: no_swap: I/Q of mixer output data is not swaped
1'h1:: swap: I/Q of mixer output data is swaped
        </comment>
      </bits>
      <bits access="rw" name="swap_pn_i_dccl_0" pos="10" rst="0">
        <comment>
          Swap ddcl input I data polarity
1'h0:: no_swap: I data polarity of ddcl input is not swaped
1'h1:: swap: I data polarity of ddcl input is swaped
        </comment>
      </bits>
      <bits access="rw" name="swap_pn_q_dccl_0" pos="9" rst="0">
        <comment>
          Swap ddcl input Q data polarity
1'h0:: no_swap: Q data polarity of ddcl input is not swaped
1'h1:: swap: Q data polarity of ddcl input is swaped
        </comment>
      </bits>
      <bits access="rw" name="notch_disb" pos="8" rst="1">
        <comment>
          Disable the ramping for edr guard time in ramp_gain_tx
        </comment>
      </bits>
      <bits access="rw" name="tx_gain_gfsk_edr" pos="7:0" rst="108">
        <comment>
          GFSK TX Gain in EDR
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adcclk_sw_ctrl">
      <bits access="r" name="adcclk_sw_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="adcclk_sw_ctrl_reserved_1" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="en_bbpkg_flg" pos="14" rst="1">
        <comment>
          BB Newpacket flag enable
1'h0:: Disable: the BB Newpacket flag enable
1'h1:: Enable: the BB Newpacket flag enable
        </comment>
      </bits>
      <bits access="rw" name="pckt_sel" pos="13" rst="0">
        <comment>
          Packet select
1'h0:: packet72
1'h1:: new_packet
        </comment>
      </bits>
      <bits access="rw" name="ct_u_gfsk" pos="12:9" rst="10">
        <comment>
          gfsk u_err 10/32
        </comment>
      </bits>
      <bits access="rw" name="ct_u_1_gfsk" pos="8:4" rst="28">
        <comment>
          gfsk u_dc 4/512
        </comment>
      </bits>
      <bits access="rw" name="ct_u_sp_gfsk" pos="3:0" rst="9">
        <comment>
          gfsk ct_u_sp for rx demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dpsk_demod_sw">
      <bits access="r" name="dpsk_demod_sw_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ct_u_patch" pos="15:13" rst="1">
        <comment>
          Switch err_in_patch for bt_dsp rx demod
        </comment>
      </bits>
      <bits access="rw" name="ct_u_dpsk" pos="12:9" rst="8">
        <comment>
          dpsk u_err 8/32
        </comment>
      </bits>
      <bits access="rw" name="ct_u_1_dpsk" pos="8:4" rst="5">
        <comment>
          dpsk u_dc 5/64
        </comment>
      </bits>
      <bits access="rw" name="ct_u_sp_dpsk" pos="3:0" rst="9">
        <comment>
          Switch dpsk ct_u for bt_dsp rx demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="min_phase_err">
      <bits access="r" name="min_phase_err_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="min_error_th" pos="15:0" rst="3318">
        <comment>
          Set the minimum phase error for  rx demod.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="afc_ctrl">
      <bits access="r" name="afc_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sel_afc_gfskdem" pos="15:14" rst="2">
        <comment>
          Select the GFSK AFC of demod
        </comment>
      </bits>
      <bits access="rw" name="sel_afc_dpskseek" pos="13:12" rst="2">
        <comment>
          Select the DPSK AFC of demod
        </comment>
      </bits>
      <bits access="rw" name="rsvd1" pos="11:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="th_gfsk_dem" pos="9:0" rst="41">
        <comment>
          GFSK demod threshold
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dpsk_gfsk_smp_th">
      <bits access="r" name="dpsk_gfsk_smp_th_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="diff_enable_dpsk" pos="15" rst="0">
        <comment>
          DPSK diff enable
1'h0:: Disable
1'h1:: Enable
        </comment>
      </bits>
      <bits access="rw" name="diff_enable_gfsk" pos="14" rst="0">
        <comment>
          GFSK diff enable
1'h0:: Disable
1'h1:: Enable
        </comment>
      </bits>
      <bits access="rw" name="sp_th_sel_dpsk" pos="13:12" rst="0">
        <comment>
          DPSK sample threshold for demod
        </comment>
      </bits>
      <bits access="rw" name="sp_th_sel_gfsk" pos="11:10" rst="0">
        <comment>
          GFSK sample threshold for demod
        </comment>
      </bits>
      <bits access="rw" name="th_gfsk_dem2" pos="9:0" rst="10">
        <comment>
          GFSK sample 2nd threshold for demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dpsk_gfsk_smp_th_1">
      <bits access="r" name="dpsk_gfsk_smp_th_1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="dpsk_gfsk_smp_th_1_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_a2_sek" pos="9:0" rst="111">
        <comment>
          gfsk sample reference a2 for demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_smp_ref_ctrl">
      <bits access="r" name="gfsk_smp_ref_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_a1_sek" pos="15:8" rst="25">
        <comment>
          GFSK sample reference a1 for demod
        </comment>
      </bits>
      <bits access="rw" name="ref_a3_sek" pos="7:0" rst="25">
        <comment>
          GFSK sample reference a3 for demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_smp_ref_ctrl_1">
      <bits access="r" name="gfsk_smp_ref_ctrl_1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rsvd2" pos="15:14" rst="1">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="guard_time_conf" pos="13:9" rst="6">
        <comment>
          tx guard timing delay to switch amp in ramp_gain_tx; counter in 13M
        </comment>
      </bits>
      <bits access="rw" name="dc_ct2" pos="8:0" rst="32">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rateconv_ctrl1">
      <bits access="r" name="rateconv_ctrl1_reserved_0" pos="31:17" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_test_en" pos="16" rst="0">
        <comment>
          DAC Test Enable
1'h0 dac data is 52m_tx IQ
1'h1 dac data depends on dac_data_sel
        </comment>
      </bits>
      <bits access="rw" name="dc_ct1" pos="15:7" rst="136">
        <comment>
          DC Cancle ct code for demod
        </comment>
      </bits>
      <bits access="rw" name="dac_data_sel" pos="6:0" rst="0">
        <comment>
          DAC Data Mux Select
6'b000000:: tx_52m_i:      tx_52m_q
6'b000001:: tx_26m_i:     tx_26m_q
6'b000010:: iqim_cancel_i:      iqim_cancel_q
6'b000011:: tx_13m_i:      tx_13m_q
6'b000100:: mixer_tx_i:      mixer_tx_q
6'b000101:: accu_tx:     blend_tx
6'b000110:: gfilter_tx:     diff_tx
6'b000111:: ampm_am:     ampm_pm
6'b001000:: cordic_tx_amp:     cordic_tx_ang
6'b001001:: symbol2iq_tx_i:     symbol2iq_tx_q
6'b001010:: tx_test_data0:      tx_test_data1
6'b100000:: angle:       angle_rc
6'b100001:: adc_data_i:       adc_data_q
6'b100010:: adc_din_i:       adc_din_q
6'b100011:: lpf_i:       lpf_q
6'b100100:: rateconv_i:      rateconv_q
6'b100101:: calib_i:         calib_q
6'b100110:: dc_calib_i:      dc_calib_q
6'b100111:: cancel_flt_i:       cancel_flt_q
6'b101000:: notch_i:       notch_q
6'b101001:: gain_i:        gain_q
6'b101010:: ble_mux_i:     ble_mux_q
6'b101011:: mixer_i:      mixer_q
6'b101100:: srrc_i:     srrc_q
6'b101101:: mixer_i_13_0:    mixer_q[13:0]
6'b101110:: srrc_i_11_0:     srrc_q[11:0]
6'b101111:: err_gfsk:       err_dpsk
6'b110000:: afc_gfsk:       afc_in
6'b110001:: angle_offset:      angle_offset1
6'b110010:: rssi_out:      rssi_out
6'b110011:: rx_test_data0:       rx_test_data1
6'b110100:: rx_test_data2:      rx_test_data3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rateconv_ctrl2">
      <bits access="r" name="rateconv_ctrl2_reserved_0" pos="31:17" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_din_sel_post" pos="16" rst="0">
        <comment>
          rssi din select post
0:: srrc
1:: mixer
        </comment>
      </bits>
      <bits access="rw" name="rssi_sel" pos="15:14" rst="0">
        <comment>
          rssi selection for LL
2'h0:: rssi_locked_pre
2'h1:: rssi_locked_post
2'h2:: rssi_pre
2'h3:: rssi_post
        </comment>
      </bits>
      <bits access="rw" name="rssi_tm_th_post" pos="13:8" rst="60">
        <comment>
          RSSI threshold post srrc
        </comment>
      </bits>
      <bits access="rw" name="rssi_din_sel_pre" pos="7" rst="1">
        <comment>
          rssi din select pre
0:: srrc
1:: mixer
        </comment>
      </bits>
      <bits access="rw" name="dc_hold_edr_en" pos="6" rst="1">
        <comment>
          DC cancle1 edr dc hold enable
        </comment>
      </bits>
      <bits access="rw" name="rssi_tm_th_pre" pos="5:0" rst="60">
        <comment>
          RSSI threshold pre srrc
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="demod_smp_ctrl">
      <bits access="r" name="demod_smp_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ini_rst_th" pos="15:10" rst="1">
        <comment>
          Count sample threshold reset for demod.
        </comment>
      </bits>
      <bits access="rw" name="ref_ready_th" pos="9:4" rst="0">
        <comment>
          GFSK iph th reference for demod.
        </comment>
      </bits>
      <bits access="rw" name="cnt_sample_ini" pos="3:0" rst="5">
        <comment>
          Sample point initial value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_ctrl">
      <bits access="r" name="agc_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="mix_guard_th" pos="15:10" rst="1">
        <comment>
          Guard time length threshold for demod
        </comment>
      </bits>
      <bits access="rw" name="dpsk_seek_st_cnt" pos="9:5" rst="10">
        <comment>
          DPSK Seek Start Count
        </comment>
      </bits>
      <bits access="rw" name="agc_en_fix7" pos="4" rst="1">
        <comment>
          Fix7 enable during demod
1'h0:: Disable
1'h1:: Enable
        </comment>
      </bits>
      <bits access="rw" name="agc_mod_fix7" pos="3" rst="0">
        <comment>
          Fix7 mode select during bt dsp demod
1'h0:: threshold_2
1'h1:: threshold_3
        </comment>
      </bits>
      <bits access="rw" name="agc_sinc_over_en" pos="2" rst="0">
        <comment>
          Rounding enable after sinc.
1'h0:: Disable
1'h1:: Enable
        </comment>
      </bits>
      <bits access="rw" name="agc_sinc_over_th" pos="1:0" rst="1">
        <comment>
          Threshold of Rounding after sinc.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_th_ctrl1">
      <bits access="r" name="agc_th_ctrl1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="agc_th_max" pos="15:8" rst="96">
        <comment>
          AGC maximum threshold for demod
        </comment>
      </bits>
      <bits access="rw" name="agc_th_min" pos="7:0" rst="24">
        <comment>
          AGC minimum threshold for demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_th_ctrl2">
      <bits access="r" name="agc_th_ctrl2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="agc_th_max_lg" pos="15:8" rst="220">
        <comment>
          AGC maximum large threshold for demod
        </comment>
      </bits>
      <bits access="rw" name="agc_th_min_lg" pos="7:0" rst="40">
        <comment>
          AGC minimum large threshold for demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_ctrl1">
      <bits access="r" name="agc_ctrl1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="agc_ctrl1_reserved_1" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="agc_ct_th_min" pos="14" rst="0">
        <comment>
          AGC minimum threshold for demod
        </comment>
      </bits>
      <bits access="rw" name="agc_en_lg_stp" pos="13" rst="1">
        <comment>
          AGC logarithmic step enable for demod
1'h0:: Disable
1'h1:: Enable
        </comment>
      </bits>
      <bits access="rw" name="agc_step_mode" pos="12:11" rst="1">
        <comment>
          AGC step mode for demod
2'b00:: AGC_step_1
2'b01:: AGC_step_2
2'b10:: AGC_step_3
2'b11:: AGC_step_4
        </comment>
      </bits>
      <bits access="rw" name="agc_step_over" pos="10:9" rst="2">
        <comment>
          AGC step over
        </comment>
      </bits>
      <bits access="rw" name="agc_en_dly" pos="8:6" rst="6">
        <comment>
          Delay timer count enable
3'b000:: Delay_0us
3'b001:: Delay_0p5us
3'b010:: Delay_1us
3'b011:: Delay_2us
3'b100:: Delay_3us
3'b101:: Delay_4us
3'b110:: Delay_6us
3'b111:: Delay_8us
        </comment>
      </bits>
      <bits access="r" name="agc_ctrl1_reserved_2" pos="5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="agc_index_ini_dsp" pos="4:2" rst="7">
        <comment>
          AGC gain index initial value for bt dsp
        </comment>
      </bits>
      <bits access="rw" name="agc_mod_dem" pos="1:0" rst="3">
        <comment>
          Demod mode select
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_ctrl2">
      <bits access="r" name="agc_ctrl2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="agc_th_min_gn" pos="15:14" rst="1">
        <comment>
          AGC minimum threshold gain select for demod
2'b00:: Gain_2
2'b01:: Gain_4
2'b10:: Gain_8
2'b11:: Gain_16

        </comment>
      </bits>
      <bits access="rw" name="agc_tm_intv" pos="13:7" rst="24">
        <comment>
          AGCtm_intv_int initial value for demod
        </comment>
      </bits>
      <bits access="rw" name="agc_tm_intv_lg" pos="6:0" rst="48">
        <comment>
          AGC tm_intv_int logarithmic initial value for demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_dgc_ctrl">
      <bits access="r" name="agc_dgc_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sel_reg_agc" pos="15" rst="1">
        <comment>
          AGC index select
1'h0:: dgc_index_dsp
1'h1:: dgc_index_mx
        </comment>
      </bits>
      <bits access="rw" name="dgc_index_dsp" pos="14:12" rst="0">
        <comment>
          DGC gain index
        </comment>
      </bits>
      <bits access="rw" name="dgc_index_max" pos="11:9" rst="4">
        <comment>
          Maximum agc gain index
        </comment>
      </bits>
      <bits access="rw" name="pass_newpacket_sel" pos="8" rst="0">
        <comment>
          Newpacket select for demod
1'h0 If newpacket from BB has one zero byte, select GID for demod, else select newpacket from BB
1'h1 Select newpacket from BB
        </comment>
      </bits>
      <bits access="rw" name="newpacket_zero_wd_cnt" pos="7:6" rst="0">
        <comment>
          Newpacket zero bytes number
2'b00 If the 1st  byte of newpacket  is zero, 
newpacket_bb_sel is logic high, else low
2'b01 If the 1st &amp; 2nd  byte of newpacket  is zero, 
newpacket_bb_sel is logic high, else low
2'b10 If the 1st &amp; 2nd &amp; 3rd byte of newpacket  is zero,
newpacket_bb_sel is logic high, else low
2'b11 If the 1st &amp; 2nd &amp; 3rd &amp;4th byte of newpacket  is zero, newpacket_bb_sel is logic high, else low
        </comment>
      </bits>
      <bits access="r" name="bt_rf_rx_gain" pos="5:3" rst="7">
        <comment>
          agc gain in use
        </comment>
      </bits>
      <bits access="rw" name="agc_mode_dsp" pos="2:0" rst="4">
        <comment>
          AGC mode for dsp
3'h0:: Normal
3'h1:: reserved
3'h2:: Hold_after_timer
3'h3:: fix_to_index_ini
3'h4:: Hold_by_FSM
3'h5:: Th_large_mode: select by FSM
others reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="agc_dccal_ctrl">
      <bits access="r" name="agc_dccal_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="agc_tm_wait" pos="15:11" rst="7">
        <comment>
          AGC hold waiting time length
        </comment>
      </bits>
      <bits access="rw" name="agc_tm_hold" pos="10:6" rst="10">
        <comment>
          AGC hold time length
        </comment>
      </bits>
      <bits access="r" name="agc_dccal_ctrl_reserved_1" pos="5:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rx_dc_cal_done" pos="3" rst="0">
        <comment>
          RX DC Calibration Done
        </comment>
      </bits>
      <bits access="rw" name="dc_cal_rx_dly" pos="2:1" rst="1">
        <comment>
          RX DC Calibration Delay for 1 loop
2'h0:: 0p6ms
2'h1:: 1p2ms
2'h2:: 2p4ms
2'h3:: 4p8ms
        </comment>
      </bits>
      <bits access="rw" name="rx_fix_dcofst" pos="0" rst="0">
        <comment>
          DC offset fix select for rx
1'h0:: by_calib: DC offset data set by calibration
1'h1:: by_reg: DC offset data set by register
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rx_dccal_ctrl">
      <bits access="r" name="rx_dccal_ctrl_reserved_0" pos="31:26" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rx_dc_cali_i_fix" pos="25:16" rst="0">
        <comment>
          RX DC fixed offset data for I path when if_fix_dcofst is 1; otherwise use the auto calc values.
        </comment>
      </bits>
      <bits access="r" name="rx_dccal_ctrl_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rx_dc_cali_q_fix" pos="9:0" rst="0">
        <comment>
          RX DC fixed offset data for Q path when if_fix_dcofst is 1; otherwise use the auto calc values.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rx_dcofst_inuse">
      <bits access="r" name="rx_dcofst_inuse_reserved_0" pos="31:26" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rx_dcoffset_i" pos="25:16" rst="0">
        <comment>
          rx dc offset for dc calibration; selected from dc_cali_i_fix &amp; dc_i2d_work_i
        </comment>
      </bits>
      <bits access="r" name="rx_dcofst_inuse_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rx_dcoffset_q" pos="9:0" rst="0">
        <comment>
          rx dc offset for dc calibration; selected from dc_cali_q_fix &amp; dc_i2d_work_q
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_path_ctrl">
      <bits access="r" name="tx_path_ctrl_reserved_0" pos="31:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_edr_am_apf_bypass" pos="10" rst="0">
      </bits>
      <bits access="rw" name="br_tp_mod_enable" pos="9" rst="0">
        <comment>
          two point modulation mode
0:: single point modulation
1:: two point modulation
        </comment>
      </bits>
      <bits access="rw" name="edr_tp_mod_enable" pos="8" rst="1">
        <comment>
          two point modulation mode
0:: single point modulation
1:: two point modulation
        </comment>
      </bits>
      <bits access="rw" name="tx_br_am_apf_bypass" pos="7" rst="1">
      </bits>
      <bits access="rw" name="tx_pm_apf_bypass" pos="6" rst="1">
      </bits>
      <bits access="rw" name="tx_pm_dac_apf_sel" pos="5" rst="1">
      </bits>
      <bits access="rw" name="tx_pm_52m_dly_sel" pos="4" rst="0">
      </bits>
      <bits access="rw" name="bt_mod" pos="3" rst="1">
        <comment>
          Bluetooth GFSK modulation filter select
        </comment>
      </bits>
      <bits access="rw" name="tx_apc" pos="2:0" rst="7">
        <comment>
          TX Gain Table Pointer during work
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_vco_gain">
      <bits access="r" name="tx_vco_gain_reserved_0" pos="31:25" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sdm_gain" pos="24:16" rst="256">
        <comment>
          tx sdm freq gain compensation, positive 1.8
        </comment>
      </bits>
      <bits access="r" name="tx_vco_gain_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="vco_gain" pos="9:0" rst="256">
        <comment>
          tx vco gain compensation, s2.8
        </comment>
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="rw" name="rssi_gain_ctrl1">
      <bits access="r" name="rssi_gain_ctrl1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain0" pos="15:8" rst="251">
        <comment>
          RSSI ana gain 0
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain1" pos="7:0" rst="8">
        <comment>
          RSSI ana gain 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rssi_gain_ctrl2">
      <bits access="r" name="rssi_gain_ctrl2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain2" pos="15:8" rst="17">
        <comment>
          RSSI ana gain 2
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain3" pos="7:0" rst="26">
        <comment>
          RSSI ana gain 3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rssi_gain_ctrl3">
      <bits access="r" name="rssi_gain_ctrl3_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain4" pos="15:8" rst="35">
        <comment>
          RSSI ana gain 4
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain5" pos="7:0" rst="44">
        <comment>
          RSSI ana gain 5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rssi_gain_ctrl4">
      <bits access="r" name="rssi_gain_ctrl4_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain6" pos="15:8" rst="54">
        <comment>
          RSSI ana gain 6
        </comment>
      </bits>
      <bits access="rw" name="rssi_ana_gain7" pos="7:0" rst="63">
        <comment>
          RSSI ana gain 7
        </comment>
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="modem_tpd_sel">
      <bits access="r" name="modem_tpd_sel_reserved_0" pos="31:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_clk_force_en" pos="9" rst="0">
        <comment>
          DAC Clock Force Enable while rx data to dac
        </comment>
      </bits>
      <bits access="rw" name="tpd_clk_sel" pos="8" rst="0">
        <comment>
          Test Ports Clock Select
0:: clk_rx
1:: clk_tx 
        </comment>
      </bits>
      <bits access="rw" name="tpd_data_sel" pos="7:4" rst="0">
        <comment>
          Test Ports Data Select
4'h0::  dac_data_i
4'h1::  dac_data_q
4'h2::  dout_tx_i_sum
4'h3::  dout_tx_q_sum
4'h4::  dout_tx_dac_i: depends on dac_data_sel
4'h5::  dout_tx_dac_q
4'h6::  dout_rx_dac_i
4'h7::  dout_rx_dac_q
4'h8::  dout_tx_dac_i_13m: by en_tx_13m
4'h9::  dout_tx_dac_q_13m: by en_tx_13m
4'ha::  dout_rx_dac_i_13m: by en_rx_13m
4'hb::  dout_rx_dac_q_13m: by en_rx_13m
4'hc::  dout_rx_dac_i_14m: by en_rx_14m
4'hd::  dout_rx_dac_q_14m: by en_rx_14m
4'he::  dout_tx_dac_i_26m: by en_tx_26m
4'hf::  dout_tx_dac_q_26m: by en_tx_26m
        </comment>
      </bits>
      <bits access="rw" name="tpd_trig_sel" pos="3:0" rst="0">
        <comment>
          Test Ports Trigger Select
4'h0::  dem_st_chg
4'h1::  agc_st_chg
4'h2::  agc_flg_dem
4'h3::  ble_access_rb
4'h4::  if_peak
4'h5::  if_seeked_all
4'h6::  seek_en
4'h7::  flg_getsymbol
4'h8::  tx_symbol_off_gfsk
4'h9::  tx_amp_sel
4'ha::  tx_flg_start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="demod_smp_th_ctrl">
      <bits access="r" name="demod_smp_th_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dem_sp_th2" pos="15:8" rst="162">
        <comment>
          Demod sample threshold2
        </comment>
      </bits>
      <bits access="rw" name="dem_sp_th1" pos="7:0" rst="64">
        <comment>
          Demod sample threshold1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="newpacket_byte4">
      <bits access="r" name="newpacket_byte4_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="newpacket_4" pos="15:0" rst="49152">
        <comment>
          The 4th byte newpacket for demod when sel_sync(register_41[13]) is 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="newpacket_byte3">
      <bits access="r" name="newpacket_byte3_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="newpacket_3" pos="15:0" rst="26214">
        <comment>
          The 3rd byte newpacket for demod when sel_sync(register_41[13]) is 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="newpacket_byte2">
      <bits access="r" name="newpacket_byte2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="newpacket_2" pos="15:0" rst="13107">
        <comment>
          The 2nd byte newpacket for demod when sel_sync(register_41[13]) is 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="newpacket_byte1">
      <bits access="r" name="newpacket_byte1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="newpacket_1" pos="15:0" rst="21845">
        <comment>
          The 1st byte newpacket for demod when sel_sync(register_41[13]) is 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_mod_ctrl">
      <bits access="r" name="gfsk_mod_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rssi_ct_u_post" pos="15:13" rst="4">
        <comment>
          RSSI post SRRC gain control
        </comment>
      </bits>
      <bits access="rw" name="rssi_ct_u_pre" pos="12:10" rst="4">
        <comment>
          RSSI pre SRRC gain control
        </comment>
      </bits>
      <bits access="rw" name="ref_a2_dem" pos="9:0" rst="117">
        <comment>
          GFSK demod a2 reference for rx demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_mod_ref_ctrl">
      <bits access="r" name="gfsk_mod_ref_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_a1_dem" pos="15:8" rst="22">
        <comment>
          GFSK demod a1 reference for rx demod
        </comment>
      </bits>
      <bits access="rw" name="ref_a3_dem" pos="7:0" rst="22">
        <comment>
          GFSK demod a3 reference for rx demod
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sym_dly_ctrl">
      <bits access="r" name="sym_dly_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="sym_dly_ctrl_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ramp_speed_gfsk" pos="13" rst="0">
        <comment>
          GFSK ramp speed select
1'h0:: Slow
1'h1:: Fast
        </comment>
      </bits>
      <bits access="rw" name="delay_gfsk_off" pos="12:9" rst="7">
        <comment>
          GFSK symbol end flag delay, with 13MHz clk step
        </comment>
      </bits>
      <bits access="rw" name="delay_gfsk_off_1m" pos="8:6" rst="4">
        <comment>
          GFSK symbol end flag delay, with 1MHz clk step
        </comment>
      </bits>
      <bits access="rw" name="delay_dpsk_1m" pos="5:3" rst="0">
        <comment>
          DPSK symbol delay, with 1MHz clk step
        </comment>
      </bits>
      <bits access="rw" name="delay_gfsk_1m" pos="2:0" rst="0">
        <comment>
          GFSK symbol delay, with 1MHz clk step
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_out2">
      <bits access="r" name="rssi_out2_reserved_0" pos="31:26" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_noise_out_post" pos="25:16" rst="0">
        <comment>
          RSSI post SRRC locked noise out 
        </comment>
      </bits>
      <bits access="r" name="rssi_out2_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_noise_out_pre" pos="9:0" rst="0">
        <comment>
          RSSI pre SRRC locked noise out 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="trx_clk_ctrl">
      <bits access="r" name="trx_clk_ctrl_reserved_0" pos="31:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_rx_dir" pos="13" rst="0">
        <comment>
          TX/RX direction
1'h0:: by_hw: TX/RX flag setting by deleying resetn_dsp_tx
1'h1:: by_reg: TX/RX flag setting by register
        </comment>
      </bits>
      <bits access="rw" name="tx_rx_reg" pos="12" rst="0">
        <comment>
          TX/RX flag
1'h0:: RX
1'h1:: TX
        </comment>
      </bits>
      <bits access="r" name="trx_clk_ctrl_reserved_1" pos="11:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="iq_swap_ctrl">
      <bits access="r" name="iq_swap_ctrl_reserved_0" pos="31:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="iq_swap_lpf" pos="8" rst="0">
        <comment>
          Rate converter LPF filter output I/Q swap
1'h0:: Not_Swap
1'h1:: Swap
        </comment>
      </bits>
      <bits access="r" name="iq_swap_ctrl_reserved_1" pos="7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="lpf_en_1" pos="6" rst="1">
        <comment>
          Low Pass Filter Enable in Channel Group1
1'h0:: bypass
1'h1:: enable
        </comment>
      </bits>
      <bits access="rw" name="rate_conv_en_1" pos="5" rst="1">
        <comment>
          Rate Converter Enable in Channel Group1
1'h0:: bypass
1'h1:: enable
        </comment>
      </bits>
      <bits access="rw" name="notch_en_1" pos="4" rst="1">
        <comment>
          Notch Filter Enable in Channel Group1
1'h0:: bypass
1'h1:: enable
        </comment>
      </bits>
      <bits access="r" name="iq_swap_ctrl_reserved_2" pos="3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="lpf_en_0" pos="2" rst="1">
        <comment>
          Low Pass Filter Enable in Channel Group0
1'h0:: bypass
1'h1:: enable
        </comment>
      </bits>
      <bits access="rw" name="rate_conv_en_0" pos="1" rst="0">
        <comment>
          Rate Converter Enable in Channel Group0
1'h0:: bypass
1'h1:: enable
        </comment>
      </bits>
      <bits access="rw" name="notch_en_0" pos="0" rst="0">
        <comment>
          Notch Filter Enable in Channel Group0
1'h0:: bypass
1'h1:: enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_sync_ctrl">
      <bits access="r" name="gfsk_sync_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="gfsk_sync_ctrl_reserved_1" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dynamic_sync_en" pos="10" rst="0">
        <comment>
          Dynamic sync enable for demod of rx link
1'h0:: static
1'h1:: Dynamic
        </comment>
      </bits>
      <bits access="rw" name="dynamic_sync_th" pos="9:0" rst="0">
        <comment>
          Dynamic sync threshold
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_demod_ctrl">
      <bits access="r" name="gfsk_demod_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="min_error_th2" pos="15:0" rst="0">
        <comment>
          The 2nd minimum sync phase error threshold
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_mod_idx">
      <bits access="r" name="gfsk_mod_idx_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="h_gain" pos="15:0" rst="12704">
        <comment>
          GFSK modulation index
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_delay_ctrl">
      <bits access="r" name="tx_delay_ctrl_reserved_0" pos="31:17" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dly_ct_pm_52m_bypass" pos="16" rst="0">
      </bits>
      <bits access="rw" name="dly_ct_pm_52m" pos="15:13" rst="1">
        <comment>
          delay 1~8 of 52M on PM
        </comment>
      </bits>
      <bits access="rw" name="dly_ct_am_52m_bypass" pos="12" rst="0">
      </bits>
      <bits access="rw" name="dly_ct_am_52m" pos="11:9" rst="2">
        <comment>
          delay 1~8 of 52M on AM
        </comment>
      </bits>
      <bits access="rw" name="dly_ct_am_13m_bypass" pos="8" rst="0">
      </bits>
      <bits access="rw" name="dly_ct_am_13m" pos="7:4" rst="4">
        <comment>
          delay 1~16 of 13M on AM
        </comment>
      </bits>
      <bits access="rw" name="dly_ct_gfsk_13m_bypass" pos="3" rst="0">
      </bits>
      <bits access="rw" name="dly_ct_gfsk_13m" pos="2:0" rst="6">
        <comment>
          delay 1~8 of 13M on gfsk
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="modem_dbm_sel">
      <bits access="r" name="modem_dbm_sel_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="modem_dbm_sel_reserved_1" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dbm_data_sel" pos="4:0" rst="0">
        <comment>
          Debug Master Data Select
5'h0::  gfilter_tx_dout
5'h1::  symbol2iq_tx_dout_q: symbol2iq_tx_dout_i
5'h2::  cordic_tx_amp_dout: cordic_tx_angle_dout
5'h3::  ampm_tx_dout_am: ampm_tx_dout_pm
5'h4::  diff_tx_dout
5'h5::  freq_blend_tx_dout
5'h6::  intigrate_tx_dout
5'h7::  cordic_iq_tx_dout_q: cordic_iq_tx_dout_i
5'h8::  dout_tx_13m_q: dout_tx_13m_i
5'h9::  iqim_cancel_dout_q: iqim_cancel_dout_i
5'ha::  dout_tx_26m_q: dout_tx_26m_i
5'hb::  dout_tx_52m_q: dout_tx_52m_i
5'hc:: dac_grp_bit_q_outp: dac_grp_bit_i_outp
5'h10:: adc_data_q: adc_data_i
5'h11:: adc_din_q: adc_din_i
5'h12:: lpf_q: lpf_i
5'h13:: rateconv_q: rateconv_i
5'h14:: calib_q: calib_i
5'h15:: dc_calib_q: dc_calib_i
5'h16:: cancel_flt_i: cancel_flt_q
5'h17:: notch_q: notch_i
5'h18:: gain_q: gain_i
5'h19:: ble_mux_q: ble_mux_i
5'h1a:: mixer_q: mixer_i
5'h1b:: srrc_q: srrc_i
5'h1c:: rssi_out
5'h1d:: angle_rc: angle
5'h1e:: angle_offset1: angle_offset
5'h1f:: err_dpsk: err_gfsk
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="gfsk_mod_idx_le">
      <bits access="r" name="gfsk_mod_idx_le_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="h_gain_le" pos="15:0" rst="20165">
        <comment>
          GFSK modulation index for BLE mode
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="newpacket_byte4_inuse">
      <bits access="r" name="newpacket_byte4_inuse_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="newpacket_dsp4" pos="15:0" rst="32368">
        <comment>
          newpacket byte 4 inuse; selected from newpacket_reg, GID &amp; newpacket_bb
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="newpacket_byte3_inuse">
      <bits access="r" name="newpacket_byte3_inuse_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="newpacket_dsp3" pos="15:0" rst="16867">
        <comment>
          newpacket byte 3 inuse; selected from newpacket_reg, GID &amp; newpacket_bb
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="newpacket_byte2_inuse">
      <bits access="r" name="newpacket_byte2_inuse_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="newpacket_dsp2" pos="15:0" rst="16384">
        <comment>
          newpacket byte 2 inuse; selected from newpacket_reg, GID &amp; newpacket_bb
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="newpacket_byte1_inuse">
      <bits access="r" name="newpacket_byte1_inuse_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="newpacket_dsp1" pos="15:0" rst="13">
        <comment>
          newpacket byte 1 inuse; selected from newpacket_reg, GID &amp; newpacket_bb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="le_mode_ctrl1">
      <bits access="r" name="le_mode_ctrl1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_a1_sek_le" pos="15:8" rst="40">
        <comment>
          ??
        </comment>
      </bits>
      <bits access="rw" name="ref_a1_dem_le" pos="7:0" rst="35">
        <comment>
          ??
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="le_mode_ctrl2">
      <bits access="r" name="le_mode_ctrl2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_a2_sek_le" pos="15:8" rst="176">
        <comment>
          ??
        </comment>
      </bits>
      <bits access="rw" name="ref_a2_dem_le" pos="7:0" rst="186">
        <comment>
          ??
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="le_mode_ctrl3">
      <bits access="r" name="le_mode_ctrl3_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_a3_sek_le" pos="15:8" rst="40">
        <comment>
          ??
        </comment>
      </bits>
      <bits access="rw" name="ref_a3_dem_le" pos="7:0" rst="35">
        <comment>
          ??
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="le_mode_ctrl4">
      <bits access="r" name="le_mode_ctrl4_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="min_error_th_le" pos="15:0" rst="2334">
        <comment>
          ??
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="le_mode_ctrl5">
      <bits access="r" name="le_mode_ctrl5_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rsvd5" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ref_point_sel_le" pos="13:12" rst="2">
        <comment>
          ??
        </comment>
      </bits>
      <bits access="rw" name="mix_guard_th_le" pos="11:6" rst="4">
        <comment>
          ??
        </comment>
      </bits>
      <bits access="rw" name="ref_ready_th_le" pos="5:0" rst="3">
        <comment>
          ??
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rf_ctrl">
      <bits access="r" name="rf_ctrl_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rf_ctrl_reserved_1" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sync_shift_mode" pos="0" rst="0">
        <comment>
          ??
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="tx_am_p0">
      <bits access="r" name="tx_am_p0_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p0_reserved_1" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_shift" pos="14:12" rst="0">
        <comment>
          PM Compensation Shift
        </comment>
      </bits>
      <bits access="rw" name="pm_comp_bypass" pos="11" rst="1">
        <comment>
          PM Compensation Bypass
1'b0:: enable
1'b1:: bypass
        </comment>
      </bits>
      <bits access="rw" name="am_comp_bypass" pos="10" rst="1">
        <comment>
          AM Compensation Bypass
1'b0:: enable
1'b1:: bypass
        </comment>
      </bits>
      <bits access="rw" name="am_p0" pos="9:0" rst="0">
        <comment>
          AMAM Compensation Coef0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p1">
      <bits access="r" name="tx_am_p1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p1_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p1" pos="9:0" rst="32">
        <comment>
          AMAM Compensation Coef1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p2">
      <bits access="r" name="tx_am_p2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p2_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p2" pos="9:0" rst="64">
        <comment>
          AMAM Compensation Coef2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p3">
      <bits access="r" name="tx_am_p3_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p3_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p3" pos="9:0" rst="96">
        <comment>
          AMAM Compensation Coef3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p4">
      <bits access="r" name="tx_am_p4_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p4_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p4" pos="9:0" rst="128">
        <comment>
          AMAM Compensation Coef4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p5">
      <bits access="r" name="tx_am_p5_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p5_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p5" pos="9:0" rst="160">
        <comment>
          AMAM Compensation Coef5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p6">
      <bits access="r" name="tx_am_p6_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p6_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p6" pos="9:0" rst="192">
        <comment>
          AMAM Compensation Coef6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p7">
      <bits access="r" name="tx_am_p7_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p7_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p7" pos="9:0" rst="224">
        <comment>
          AMAM Compensation Coef7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p8">
      <bits access="r" name="tx_am_p8_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p8_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p8" pos="9:0" rst="256">
        <comment>
          AMAM Compensation Coef8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p9">
      <bits access="r" name="tx_am_p9_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p9_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p9" pos="9:0" rst="288">
        <comment>
          AMAM Compensation Coef9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p10">
      <bits access="r" name="tx_am_p10_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p10_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p10" pos="9:0" rst="320">
        <comment>
          AMAM Compensation Coef10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p11">
      <bits access="r" name="tx_am_p11_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p11_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p11" pos="9:0" rst="352">
        <comment>
          AMAM Compensation Coef11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p12">
      <bits access="r" name="tx_am_p12_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p12_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p12" pos="9:0" rst="384">
        <comment>
          AMAM Compensation Coef12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p13">
      <bits access="r" name="tx_am_p13_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p13_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p13" pos="9:0" rst="416">
        <comment>
          AMAM Compensation Coef13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p14">
      <bits access="r" name="tx_am_p14_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p14_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p14" pos="9:0" rst="448">
        <comment>
          AMAM Compensation Coef14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p15">
      <bits access="r" name="tx_am_p15_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p15_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p15" pos="9:0" rst="480">
        <comment>
          AMAM Compensation Coef15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_p16">
      <bits access="r" name="tx_am_p16_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_am_p16_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="am_p16" pos="9:0" rst="511">
        <comment>
          AMAM Compensation Coef16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p0">
      <bits access="r" name="tx_pm_p0_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p0_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p0" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p1">
      <bits access="r" name="tx_pm_p1_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p1_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p1" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p2">
      <bits access="r" name="tx_pm_p2_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p2_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p2" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p3">
      <bits access="r" name="tx_pm_p3_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p3_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p3" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p4">
      <bits access="r" name="tx_pm_p4_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p4_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p4" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p5">
      <bits access="r" name="tx_pm_p5_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p5_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p5" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p6">
      <bits access="r" name="tx_pm_p6_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p6_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p6" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p7">
      <bits access="r" name="tx_pm_p7_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p7_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p7" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p8">
      <bits access="r" name="tx_pm_p8_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p8_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p8" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p9">
      <bits access="r" name="tx_pm_p9_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p9_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p9" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p10">
      <bits access="r" name="tx_pm_p10_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p10_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p10" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p11">
      <bits access="r" name="tx_pm_p11_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p11_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p11" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p12">
      <bits access="r" name="tx_pm_p12_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p12_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p12" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p13">
      <bits access="r" name="tx_pm_p13_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p13_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p13" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p14">
      <bits access="r" name="tx_pm_p14_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p14_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p14" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p15">
      <bits access="r" name="tx_pm_p15_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p15_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p15" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_p16">
      <bits access="r" name="tx_pm_p16_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="tx_pm_p16_reserved_1" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pm_p16" pos="9:0" rst="0">
        <comment>
          AMPM Compensation Coef16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="notch_coef">
      <bits access="r" name="notch_coef_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="notch_coef_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="notch_b" pos="13:0" rst="15347">
        <comment>
          Notch Filter Coefficient B
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adapt_edr3_demod">
      <bits access="r" name="adapt_edr3_demod_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="notch_a" pos="15:12" rst="12">
        <comment>
          Notch Filter Coefficient A
        </comment>
      </bits>
      <bits access="r" name="adapt_edr3_demod_reserved_1" pos="11:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="edr3_adapt_en" pos="9" rst="1">
        <comment>
          EDR3 Adapt Demodulation Enable
1'b0:: disable
1'b1:: enable
        </comment>
      </bits>
      <bits access="rw" name="ct_u_dpsk1" pos="8:5" rst="2">
        <comment>
          second u_err of the dpsk 2/32
        </comment>
      </bits>
      <bits access="rw" name="ct_u_1_dpsk1" pos="4:0" rst="26">
        <comment>
          second u_dc of the dpsk 2/512
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adapt_edr3_thresh">
      <bits access="r" name="adapt_edr3_thresh_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="adapt_edr3_thresh_reserved_1" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="edr3_adapt_th" pos="11:0" rst="20">
        <comment>
          EDR3 Adapt Demodulation Threshold
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_auto_gain1_gfsk">
      <bits access="r" name="tx_auto_gain1_gfsk_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk7" pos="15:12" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h7
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk6" pos="11:8" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h6
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk5" pos="7:4" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h5
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk4" pos="3:0" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_auto_gain0_gfsk">
      <bits access="r" name="tx_auto_gain0_gfsk_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk3" pos="15:12" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h3
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk2" pos="11:8" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h2
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk1" pos="7:4" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h1
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk0" pos="3:0" rst="7">
        <comment>
          auto gfsk digital gain high 4bits. Tx_power=3'h0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_auto_gain1_gfsk_edr">
      <bits access="r" name="tx_auto_gain1_gfsk_edr_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr7" pos="15:12" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h7
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr6" pos="11:8" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h6
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr5" pos="7:4" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h5
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr4" pos="3:0" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_auto_gain0_gfsk_edr">
      <bits access="r" name="tx_auto_gain0_gfsk_edr_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr3" pos="15:12" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h3
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr2" pos="11:8" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h2
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr1" pos="7:4" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h1
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_gfsk_edr0" pos="3:0" rst="6">
        <comment>
          auto gfsk edr digital gain high 4bits. Tx_power=3'h0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_auto_gain1_dpsk">
      <bits access="r" name="tx_auto_gain1_dpsk_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk7" pos="15:12" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h7
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk6" pos="11:8" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h6
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk5" pos="7:4" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h5
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk4" pos="3:0" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_auto_gain0_dpsk">
      <bits access="r" name="tx_auto_gain0_dpsk_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk3" pos="15:12" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h3
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk2" pos="11:8" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h2
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk1" pos="7:4" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h1
        </comment>
      </bits>
      <bits access="rw" name="tx_auto_gain_dpsk0" pos="3:0" rst="12">
        <comment>
          auto dpsk digital gain high 4bits. Tx_power=3'h0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_cal_ofst">
      <bits access="r" name="tx_am_cal_ofst_reserved_0" pos="31:15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_am_cal_offset" pos="14:0" rst="0">
        <comment>
          tx am offset
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_am_low_limit">
      <bits access="r" name="tx_am_low_limit_reserved_0" pos="31:15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_am_lower_limit" pos="14:0" rst="0">
        <comment>
          tx am lower limit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_low_limit">
      <bits access="r" name="tx_pm_low_limit_reserved_0" pos="31:15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_pm_lower_limit" pos="14:0" rst="16384">
        <comment>
          tx pm lower limit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_pm_up_limit">
      <bits access="r" name="tx_pm_up_limit_reserved_0" pos="31:15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_pm_upper_limit" pos="14:0" rst="16383">
        <comment>
          tx pm upper limit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_num_b1">
      <bits access="r" name="tx_apf_num_b1_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b1_pm" pos="29:16" rst="2273">
        <comment>
          tx polar modulation apf num coe-2.14
        </comment>
      </bits>
      <bits access="r" name="tx_apf_num_b1_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b1_am" pos="13:0" rst="2273">
        <comment>
          tx polar modulation apf num coe-2.14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_num_b2">
      <bits access="r" name="tx_apf_num_b2_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b2_pm" pos="29:16" rst="2273">
        <comment>
          tx polar modulation apf num coe
        </comment>
      </bits>
      <bits access="r" name="tx_apf_num_b2_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b2_am" pos="13:0" rst="2273">
        <comment>
          tx polar modulation apf num coe
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_num_b3">
      <bits access="r" name="tx_apf_num_b3_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b3_pm" pos="29:16" rst="2273">
        <comment>
          tx polar modulation apf num coe
        </comment>
      </bits>
      <bits access="r" name="tx_apf_num_b3_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b3_am" pos="13:0" rst="2273">
        <comment>
          tx polar modulation apf num coe
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_num_b4">
      <bits access="r" name="tx_apf_num_b4_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b4_pm" pos="29:16" rst="4096">
        <comment>
          tx polar modulation apf num coe
        </comment>
      </bits>
      <bits access="r" name="tx_apf_num_b4_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="num_coe_b4_am" pos="13:0" rst="4096">
        <comment>
          tx polar modulation apf num coe
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_den_a2">
      <bits access="r" name="tx_apf_den_a2_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="den_coe_a2_pm" pos="29:16" rst="2273">
        <comment>
          tx polar modulation apf den coe
        </comment>
      </bits>
      <bits access="r" name="tx_apf_den_a2_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="den_coe_a2_am" pos="13:0" rst="2273">
        <comment>
          tx polar modulation apf den coe
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_den_a3">
      <bits access="r" name="tx_apf_den_a3_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="den_coe_a3_pm" pos="29:16" rst="2273">
        <comment>
          tx polar modulation apf den coe
        </comment>
      </bits>
      <bits access="r" name="tx_apf_den_a3_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="den_coe_a3_am" pos="13:0" rst="2273">
        <comment>
          tx polar modulation apf den coe
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="tx_apf_den_a4">
      <bits access="r" name="tx_apf_den_a4_reserved_0" pos="31:30" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="den_coe_a4_pm" pos="29:16" rst="2273">
        <comment>
          tx polar modulation apf den coe
        </comment>
      </bits>
      <bits access="r" name="tx_apf_den_a4_reserved_1" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="den_coe_a4_am" pos="13:0" rst="2273">
        <comment>
          tx polar modulation apf den coe
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adapt_edr3_cci">
      <bits access="r" name="adapt_edr3_cci_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ct_u_errsum" pos="15:13" rst="4">
        <comment>
          ErrSum beta coef
3'h0:: 1div2
3'h1:: 1div4
3'h2:: 1div8
3'h3:: 1div16
3'h4:: 1div32
3'h5:: 1div64
        </comment>
      </bits>
      <bits access="r" name="adapt_edr3_cci_reserved_1" pos="12:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ct_u_dpsk2" pos="8:5" rst="8">
        <comment>
          third u_err of the dpsk 8/32
        </comment>
      </bits>
      <bits access="rw" name="ct_u_1_dpsk2" pos="4:0" rst="25">
        <comment>
          third u_dc of the dpsk 1/512
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dem1250_afc_freq">
      <bits access="r" name="dem1250_afc_freq_reserved_0" pos="31:16" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="afc_smtif_2m" pos="15:0" rst="59234">
        <comment>
          Set the AFC frequency of dem1250 of rx link
dec2hex(2^16-round(2*1250/26e3*2^16))
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dc_esti_cntl">
      <bits access="rw" name="dc_esti_sat_max" pos="31:20" rst="2047">
        <comment>
          dc estimation saturation max
        </comment>
      </bits>
      <bits access="rw" name="dc_esti_sat_min" pos="19:8" rst="2048">
        <comment>
          dc estimation saturation min
        </comment>
      </bits>
      <bits access="rw" name="dc_esti_num" pos="7:6" rst="3">
        <comment>
          dc estimation calculation average cycles for open_loop
2'h0:: avg_2
2'h1:: avg_4
2'h2:: avg_8
2'h3:: avg_16
        </comment>
      </bits>
      <bits access="rw" name="dc_esti_len" pos="5:3" rst="2">
        <comment>
          dc estimation calculation symbol length
3'h0:: 4_symbols
3'h1:: 8_symbols
3'h2:: 16_symbols
3'h3:: 32_symbols
3'h4:: 64_symbols
        </comment>
      </bits>
      <bits access="rw" name="dc_esti_st_sel" pos="2" rst="0">
        <comment>
          dc estimation start select
0:: agc_steady
1:: agc_lock
        </comment>
      </bits>
      <bits access="rw" name="dc_esti_mode" pos="1" rst="0">
        <comment>
          dc estimation mode
1'b0:: close_loop
1'b1:: open_loop
        </comment>
      </bits>
      <bits access="rw" name="dc_esti_enable" pos="0" rst="0">
        <comment>
          dc estimation enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dc_esti_coef">
      <bits access="r" name="dc_esti_coef_reserved_0" pos="31" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="bpf_gain_coef_q" pos="30:16" rst="24576">
        <comment>
          bpf_gain_q*loop_gain = -1
        </comment>
      </bits>
      <bits access="r" name="dc_esti_coef_reserved_1" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="bpf_gain_coef_i" pos="14:0" rst="27525">
        <comment>
          bpf_gain_i*loop_gain = -0.64
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative="ca.xml">
  <module name="ca" category="rf_dig">
    <reg protect="rw" name="ca_ctrl_reg">
      <bits access="r" name="ca_ctrl_reg_reserved_0" pos="15:2" rst="12">
      </bits>
      <bits access="rs" name="ca_tx_rst" pos="1" rst="0">
        <comment>
        bit type is changed from w1s to rs.

          write 1 to reset CA TX, self cleared
        </comment>
      </bits>
      <bits access="rs" name="ca_rx_rst" pos="0" rst="0">
        <comment>
        bit type is changed from w1s to rs.

          write 1 to reset CA RX, self cleared
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_en_reg">
      <bits access="rw" name="ca_rx_en" pos="15:0" rst="0">
        <comment>
          CA RX enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_clk_gating_reg">
      <bits access="rw" name="ca_rx_clk_gating_en" pos="15:0" rst="0">
        <comment>
          CA RX clock gating enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer0_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in0_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in0 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer0_msb_reg">
      <bits access="r" name="ca_rx_mixer0_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in0_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in0 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer1_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in1_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in1 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer1_msb_reg">
      <bits access="r" name="ca_rx_mixer1_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in1_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in1 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer2_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in2_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in2 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer2_msb_reg">
      <bits access="r" name="ca_rx_mixer2_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in2_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in2 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer3_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in3_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in3 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer3_msb_reg">
      <bits access="r" name="ca_rx_mixer3_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in3_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in3 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer4_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in4_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in4 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer4_msb_reg">
      <bits access="r" name="ca_rx_mixer4_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in4_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in4 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer5_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in5_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in5 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer5_msb_reg">
      <bits access="r" name="ca_rx_mixer5_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in5_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in5 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer6_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in6_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in6 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer6_msb_reg">
      <bits access="r" name="ca_rx_mixer6_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in6_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in6 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer7_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in7_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in7 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer7_msb_reg">
      <bits access="r" name="ca_rx_mixer7_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in7_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in7 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer8_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in8_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in8 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer8_msb_reg">
      <bits access="r" name="ca_rx_mixer8_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in8_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in8 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer9_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in9_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in9 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer9_msb_reg">
      <bits access="r" name="ca_rx_mixer9_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in9_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in9 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer10_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in10_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in10 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer10_msb_reg">
      <bits access="r" name="ca_rx_mixer10_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in10_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in10 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer11_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in11_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in11 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer11_msb_reg">
      <bits access="r" name="ca_rx_mixer11_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in11_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in11 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer12_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in12_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in12 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer12_msb_reg">
      <bits access="r" name="ca_rx_mixer12_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in12_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in12 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer13_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in13_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in13 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer13_msb_reg">
      <bits access="r" name="ca_rx_mixer13_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in13_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in13 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer14_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in14_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in14 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer14_msb_reg">
      <bits access="r" name="ca_rx_mixer14_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in14_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in14 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer15_lsb_reg">
      <bits access="rw" name="ca_rx_mixer_freq_in15_lsb" pos="15:0" rst="0">
        <comment>
          CA RX mixer freq in15 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_mixer15_msb_reg">
      <bits access="r" name="ca_rx_mixer15_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_mixer_freq_in15_msb" pos="7:0" rst="0">
        <comment>
          CA RX mixer freq in15 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct0_reg">
      <bits access="r" name="ca_rx_gain_ct0_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct0_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct1_reg">
      <bits access="r" name="ca_rx_gain_ct1_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct1_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct2_reg">
      <bits access="r" name="ca_rx_gain_ct2_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct2_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct3_reg">
      <bits access="r" name="ca_rx_gain_ct3_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct3_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct4_reg">
      <bits access="r" name="ca_rx_gain_ct4_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct4_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct5_reg">
      <bits access="r" name="ca_rx_gain_ct5_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct5_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct6_reg">
      <bits access="r" name="ca_rx_gain_ct6_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct6_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct7_reg">
      <bits access="r" name="ca_rx_gain_ct7_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct7_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct8_reg">
      <bits access="r" name="ca_rx_gain_ct8_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct8_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct9_reg">
      <bits access="r" name="ca_rx_gain_ct9_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct9_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct10_reg">
      <bits access="r" name="ca_rx_gain_ct10_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct10_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct11_reg">
      <bits access="r" name="ca_rx_gain_ct11_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct11_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct12_reg">
      <bits access="r" name="ca_rx_gain_ct12_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct12_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct13_reg">
      <bits access="r" name="ca_rx_gain_ct13_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct13_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct14_reg">
      <bits access="r" name="ca_rx_gain_ct14_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct14_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_gain_ct15_reg">
      <bits access="r" name="ca_rx_gain_ct15_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_gain_ct15_rg" pos="9:0" rst="0">
        <comment>
          CA RX gain ct15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_en_reg">
      <bits access="rw" name="ca_tx_en" pos="15:0" rst="0">
        <comment>
          CA TX enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_clk_gating_reg">
      <bits access="rw" name="ca_tx_clk_gating_en" pos="15:0" rst="0">
        <comment>
          CA TX clock gating enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_uphbf_rate_reg">
      <bits access="r" name="ca_tx_uphbf_rate_reg_reserved_0" pos="15:12" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_uplpf_mode" pos="11" rst="0">
        <comment>
          CA TX uplpf mode
        </comment>
      </bits>
      <bits access="rw" name="ca_tx_clk_gating_en_gain" pos="10" rst="0">
        <comment>
          CA TX gain clock gating enable
        </comment>
      </bits>
      <bits access="rw" name="ca_tx_uplpf_clk_sel" pos="9" rst="0">
        <comment>
          CA TX uplpf clock select
        </comment>
      </bits>
      <bits access="rw" name="ca_tx_uphbf_rate" pos="8:0" rst="511">
        <comment>
          CA TX uphbf rate
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer0_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in0_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in0 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer0_msb_reg">
      <bits access="r" name="ca_tx_mixer0_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in0_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in0 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer1_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in1_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in1 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer1_msb_reg">
      <bits access="r" name="ca_tx_mixer1_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in1_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in1 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer2_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in2_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in2 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer2_msb_reg">
      <bits access="r" name="ca_tx_mixer2_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in2_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in2 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer3_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in3_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in3 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer3_msb_reg">
      <bits access="r" name="ca_tx_mixer3_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in3_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in3 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer4_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in4_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in4 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer4_msb_reg">
      <bits access="r" name="ca_tx_mixer4_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in4_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in4 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer5_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in5_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in5 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer5_msb_reg">
      <bits access="r" name="ca_tx_mixer5_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in5_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in5 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer6_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in6_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in6 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer6_msb_reg">
      <bits access="r" name="ca_tx_mixer6_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in6_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in6 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer7_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in7_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in7 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer7_msb_reg">
      <bits access="r" name="ca_tx_mixer7_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in7_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in7 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer8_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in8_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in8 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer8_msb_reg">
      <bits access="r" name="ca_tx_mixer8_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in8_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in8 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer9_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in9_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in9 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer9_msb_reg">
      <bits access="r" name="ca_tx_mixer9_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in9_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in9 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer10_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in10_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in10 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer10_msb_reg">
      <bits access="r" name="ca_tx_mixer10_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in10_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in10 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer11_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in11_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in11 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer11_msb_reg">
      <bits access="r" name="ca_tx_mixer11_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in11_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in11 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer12_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in12_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in12 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer12_msb_reg">
      <bits access="r" name="ca_tx_mixer12_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in12_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in12 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer13_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in13_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in13 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer13_msb_reg">
      <bits access="r" name="ca_tx_mixer13_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in13_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in13 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer14_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in14_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in14 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer14_msb_reg">
      <bits access="r" name="ca_tx_mixer14_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in14_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in14 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer15_lsb_reg">
      <bits access="rw" name="ca_tx_mixer_freq_in15_lsb" pos="15:0" rst="0">
        <comment>
          CA TX mixer freq in15 lsb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_mixer15_msb_reg">
      <bits access="r" name="ca_tx_mixer15_msb_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_freq_in15_msb" pos="7:0" rst="0">
        <comment>
          CA TX mixer freq in15 msb
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_gain_ct_reg">
      <bits access="r" name="ca_tx_gain_ct_reg_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_gain_ct_rg" pos="9:0" rst="0">
        <comment>
          CA TX gain ct
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_shift_reg">
      <bits access="r" name="ca_tx_shift_reg_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_shift" pos="2:0" rst="0">
        <comment>
          CA TX SHIFT
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_sel_reg">
      <bits access="r" name="ca_tx_aclr_sel_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_sel" pos="0" rst="0">
        <comment>
          CA TX ACLR SEL
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_sel_reg">
      <bits access="r" name="ca_rx_aci_sel_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_aci_sel" pos="0" rst="0">
        <comment>
          CA RX ACI SEL
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_bypass_reg">
      <bits access="r" name="ca_tx_aclr_bypass_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_bypass" pos="0" rst="0">
        <comment>
          ca_tx_aclr_bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_bypass_reg">
      <bits access="r" name="ca_rx_aci_bypass_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_rx_aci_bypass" pos="0" rst="0">
        <comment>
          ca_rx_aci_bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_mixer_gain_reg">
      <bits access="r" name="ca_mixer_gain_reg_reserved_0" pos="15:4" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_mixer_gain_sel" pos="3:2" rst="1">
        <comment>
          0:0.5  1:0.625 2:0.75 3:0.8125
        </comment>
      </bits>
      <bits access="rw" name="ca_rx_mixer_gain_sel" pos="1:0" rst="1">
        <comment>
          0:0.5  1:0.625 2:0.75 3:0.8125
        </comment>
      </bits>
    </reg>
    <hole size="1120"/>
    <reg protect="rw" name="ca_rx_aci_coef0_a_reg">
      <bits access="rw" name="ca_rx_aci_coef0_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef1_a_reg">
      <bits access="rw" name="ca_rx_aci_coef1_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef2_a_reg">
      <bits access="rw" name="ca_rx_aci_coef2_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef3_a_reg">
      <bits access="rw" name="ca_rx_aci_coef3_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef4_a_reg">
      <bits access="rw" name="ca_rx_aci_coef4_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef5_a_reg">
      <bits access="rw" name="ca_rx_aci_coef5_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef6_a_reg">
      <bits access="rw" name="ca_rx_aci_coef6_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef7_a_reg">
      <bits access="rw" name="ca_rx_aci_coef7_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef8_a_reg">
      <bits access="rw" name="ca_rx_aci_coef8_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef9_a_reg">
      <bits access="rw" name="ca_rx_aci_coef9_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef10_a_reg">
      <bits access="rw" name="ca_rx_aci_coef10_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef11_a_reg">
      <bits access="rw" name="ca_rx_aci_coef11_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef12_a_reg">
      <bits access="rw" name="ca_rx_aci_coef12_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef13_a_reg">
      <bits access="rw" name="ca_rx_aci_coef13_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef14_a_reg">
      <bits access="rw" name="ca_rx_aci_coef14_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef15_a_reg">
      <bits access="rw" name="ca_rx_aci_coef15_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef16_a_reg">
      <bits access="rw" name="ca_rx_aci_coef16_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef17_a_reg">
      <bits access="rw" name="ca_rx_aci_coef17_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF17
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef18_a_reg">
      <bits access="rw" name="ca_rx_aci_coef18_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF18
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef19_a_reg">
      <bits access="rw" name="ca_rx_aci_coef19_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF19
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef20_a_reg">
      <bits access="rw" name="ca_rx_aci_coef20_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF20
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef21_a_reg">
      <bits access="rw" name="ca_rx_aci_coef21_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF21
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef22_a_reg">
      <bits access="rw" name="ca_rx_aci_coef22_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF22
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef23_a_reg">
      <bits access="rw" name="ca_rx_aci_coef23_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF23
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef24_a_reg">
      <bits access="rw" name="ca_rx_aci_coef24_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF24
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef25_a_reg">
      <bits access="rw" name="ca_rx_aci_coef25_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF25
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef26_a_reg">
      <bits access="rw" name="ca_rx_aci_coef26_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF26
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef27_a_reg">
      <bits access="rw" name="ca_rx_aci_coef27_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF27
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef28_a_reg">
      <bits access="rw" name="ca_rx_aci_coef28_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF28
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef29_a_reg">
      <bits access="rw" name="ca_rx_aci_coef29_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF29
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef30_a_reg">
      <bits access="rw" name="ca_rx_aci_coef30_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF30
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef31_a_reg">
      <bits access="rw" name="ca_rx_aci_coef31_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF31
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef32_a_reg">
      <bits access="rw" name="ca_rx_aci_coef32_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF32
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef33_a_reg">
      <bits access="rw" name="ca_rx_aci_coef33_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF33
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef34_a_reg">
      <bits access="rw" name="ca_rx_aci_coef34_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF34
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef35_a_reg">
      <bits access="rw" name="ca_rx_aci_coef35_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF35
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef36_a_reg">
      <bits access="rw" name="ca_rx_aci_coef36_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF36
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef37_a_reg">
      <bits access="rw" name="ca_rx_aci_coef37_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF37
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef38_a_reg">
      <bits access="rw" name="ca_rx_aci_coef38_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF38
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef39_a_reg">
      <bits access="rw" name="ca_rx_aci_coef39_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF39
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef40_a_reg">
      <bits access="rw" name="ca_rx_aci_coef40_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF40
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef41_a_reg">
      <bits access="rw" name="ca_rx_aci_coef41_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF41
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef42_a_reg">
      <bits access="rw" name="ca_rx_aci_coef42_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF42
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef43_a_reg">
      <bits access="rw" name="ca_rx_aci_coef43_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF43
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef44_a_reg">
      <bits access="rw" name="ca_rx_aci_coef44_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF44
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef45_a_reg">
      <bits access="rw" name="ca_rx_aci_coef45_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF45
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef46_a_reg">
      <bits access="rw" name="ca_rx_aci_coef46_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF46
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef47_a_reg">
      <bits access="rw" name="ca_rx_aci_coef47_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF47
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef48_a_reg">
      <bits access="rw" name="ca_rx_aci_coef48_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF48
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef49_a_reg">
      <bits access="rw" name="ca_rx_aci_coef49_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF49
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef50_a_reg">
      <bits access="rw" name="ca_rx_aci_coef50_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF50
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef51_a_reg">
      <bits access="rw" name="ca_rx_aci_coef51_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF51
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef52_a_reg">
      <bits access="rw" name="ca_rx_aci_coef52_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF52
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef53_a_reg">
      <bits access="rw" name="ca_rx_aci_coef53_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF53
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef54_a_reg">
      <bits access="rw" name="ca_rx_aci_coef54_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF54
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef55_a_reg">
      <bits access="rw" name="ca_rx_aci_coef55_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF55
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef56_a_reg">
      <bits access="rw" name="ca_rx_aci_coef56_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF56
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef57_a_reg">
      <bits access="rw" name="ca_rx_aci_coef57_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF57
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef58_a_reg">
      <bits access="rw" name="ca_rx_aci_coef58_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF58
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef59_a_reg">
      <bits access="rw" name="ca_rx_aci_coef59_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF59
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef60_a_reg">
      <bits access="rw" name="ca_rx_aci_coef60_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF60
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef61_a_reg">
      <bits access="rw" name="ca_rx_aci_coef61_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF61
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef62_a_reg">
      <bits access="rw" name="ca_rx_aci_coef62_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF62
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef63_a_reg">
      <bits access="rw" name="ca_rx_aci_coef63_a" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF63
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef0_b_reg">
      <bits access="rw" name="ca_rx_aci_coef0_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef1_b_reg">
      <bits access="rw" name="ca_rx_aci_coef1_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef2_b_reg">
      <bits access="rw" name="ca_rx_aci_coef2_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef3_b_reg">
      <bits access="rw" name="ca_rx_aci_coef3_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef4_b_reg">
      <bits access="rw" name="ca_rx_aci_coef4_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef5_b_reg">
      <bits access="rw" name="ca_rx_aci_coef5_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef6_b_reg">
      <bits access="rw" name="ca_rx_aci_coef6_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef7_b_reg">
      <bits access="rw" name="ca_rx_aci_coef7_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef8_b_reg">
      <bits access="rw" name="ca_rx_aci_coef8_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef9_b_reg">
      <bits access="rw" name="ca_rx_aci_coef9_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef10_b_reg">
      <bits access="rw" name="ca_rx_aci_coef10_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef11_b_reg">
      <bits access="rw" name="ca_rx_aci_coef11_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef12_b_reg">
      <bits access="rw" name="ca_rx_aci_coef12_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef13_b_reg">
      <bits access="rw" name="ca_rx_aci_coef13_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef14_b_reg">
      <bits access="rw" name="ca_rx_aci_coef14_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef15_b_reg">
      <bits access="rw" name="ca_rx_aci_coef15_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef16_b_reg">
      <bits access="rw" name="ca_rx_aci_coef16_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef17_b_reg">
      <bits access="rw" name="ca_rx_aci_coef17_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF17
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef18_b_reg">
      <bits access="rw" name="ca_rx_aci_coef18_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF18
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef19_b_reg">
      <bits access="rw" name="ca_rx_aci_coef19_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF19
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef20_b_reg">
      <bits access="rw" name="ca_rx_aci_coef20_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF20
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef21_b_reg">
      <bits access="rw" name="ca_rx_aci_coef21_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF21
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef22_b_reg">
      <bits access="rw" name="ca_rx_aci_coef22_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF22
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef23_b_reg">
      <bits access="rw" name="ca_rx_aci_coef23_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF23
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef24_b_reg">
      <bits access="rw" name="ca_rx_aci_coef24_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF24
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef25_b_reg">
      <bits access="rw" name="ca_rx_aci_coef25_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF25
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef26_b_reg">
      <bits access="rw" name="ca_rx_aci_coef26_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF26
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef27_b_reg">
      <bits access="rw" name="ca_rx_aci_coef27_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF27
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef28_b_reg">
      <bits access="rw" name="ca_rx_aci_coef28_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF28
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef29_b_reg">
      <bits access="rw" name="ca_rx_aci_coef29_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF29
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef30_b_reg">
      <bits access="rw" name="ca_rx_aci_coef30_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF30
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef31_b_reg">
      <bits access="rw" name="ca_rx_aci_coef31_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF31
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef32_b_reg">
      <bits access="rw" name="ca_rx_aci_coef32_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF32
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef33_b_reg">
      <bits access="rw" name="ca_rx_aci_coef33_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF33
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef34_b_reg">
      <bits access="rw" name="ca_rx_aci_coef34_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF34
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef35_b_reg">
      <bits access="rw" name="ca_rx_aci_coef35_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF35
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef36_b_reg">
      <bits access="rw" name="ca_rx_aci_coef36_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF36
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef37_b_reg">
      <bits access="rw" name="ca_rx_aci_coef37_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF37
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef38_b_reg">
      <bits access="rw" name="ca_rx_aci_coef38_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF38
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef39_b_reg">
      <bits access="rw" name="ca_rx_aci_coef39_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF39
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef40_b_reg">
      <bits access="rw" name="ca_rx_aci_coef40_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF40
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef41_b_reg">
      <bits access="rw" name="ca_rx_aci_coef41_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF41
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef42_b_reg">
      <bits access="rw" name="ca_rx_aci_coef42_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF42
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef43_b_reg">
      <bits access="rw" name="ca_rx_aci_coef43_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF43
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef44_b_reg">
      <bits access="rw" name="ca_rx_aci_coef44_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF44
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef45_b_reg">
      <bits access="rw" name="ca_rx_aci_coef45_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF45
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef46_b_reg">
      <bits access="rw" name="ca_rx_aci_coef46_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF46
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef47_b_reg">
      <bits access="rw" name="ca_rx_aci_coef47_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF47
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef48_b_reg">
      <bits access="rw" name="ca_rx_aci_coef48_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF48
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef49_b_reg">
      <bits access="rw" name="ca_rx_aci_coef49_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF49
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef50_b_reg">
      <bits access="rw" name="ca_rx_aci_coef50_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF50
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef51_b_reg">
      <bits access="rw" name="ca_rx_aci_coef51_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF51
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef52_b_reg">
      <bits access="rw" name="ca_rx_aci_coef52_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF52
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef53_b_reg">
      <bits access="rw" name="ca_rx_aci_coef53_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF53
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef54_b_reg">
      <bits access="rw" name="ca_rx_aci_coef54_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF54
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef55_b_reg">
      <bits access="rw" name="ca_rx_aci_coef55_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF55
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef56_b_reg">
      <bits access="rw" name="ca_rx_aci_coef56_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF56
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef57_b_reg">
      <bits access="rw" name="ca_rx_aci_coef57_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF57
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef58_b_reg">
      <bits access="rw" name="ca_rx_aci_coef58_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF58
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef59_b_reg">
      <bits access="rw" name="ca_rx_aci_coef59_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF59
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef60_b_reg">
      <bits access="rw" name="ca_rx_aci_coef60_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF60
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef61_b_reg">
      <bits access="rw" name="ca_rx_aci_coef61_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF61
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef62_b_reg">
      <bits access="rw" name="ca_rx_aci_coef62_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF62
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_rx_aci_coef63_b_reg">
      <bits access="rw" name="ca_rx_aci_coef63_b" pos="15:0" rst="0">
        <comment>
          CA RX ACI COEF63
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef0_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef0_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef1_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef1_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef2_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef2_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef3_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef3_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef4_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef4_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef5_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef5_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef6_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef6_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef7_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef7_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef8_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef8_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef9_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef9_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef10_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef10_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef11_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef11_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef12_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef12_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef13_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef13_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef14_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef14_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef15_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef15_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef16_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef16_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef17_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef17_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF17
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef18_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef18_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF18
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef19_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef19_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF19
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef20_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef20_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF20
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef21_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef21_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF21
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef22_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef22_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF22
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef23_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef23_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF23
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef24_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef24_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF24
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef25_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef25_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF25
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef26_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef26_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF26
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef27_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef27_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF27
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef28_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef28_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF28
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef29_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef29_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF29
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef30_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef30_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF30
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef31_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef31_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF31
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef32_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef32_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF32
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef33_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef33_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF33
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef34_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef34_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF34
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef35_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef35_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF35
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef36_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef36_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF36
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef37_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef37_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF37
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef38_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef38_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF38
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef39_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef39_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF39
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef40_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef40_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF40
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef41_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef41_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF41
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef42_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef42_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF42
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef43_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef43_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF43
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef44_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef44_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF44
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef45_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef45_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF45
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef46_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef46_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF46
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef47_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef47_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF47
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef48_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef48_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF48
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef49_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef49_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF49
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef50_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef50_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF50
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef51_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef51_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF51
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef52_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef52_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF52
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef53_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef53_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF53
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef54_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef54_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF54
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef55_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef55_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF55
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef56_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef56_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF56
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef57_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef57_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF57
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef58_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef58_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF58
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef59_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef59_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF59
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef60_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef60_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF60
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef61_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef61_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF61
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef62_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef62_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF62
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef63_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef63_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF63
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef64_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef64_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF64
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef65_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef65_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF65
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef66_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef66_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF66
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef67_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef67_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF67
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef68_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef68_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF68
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef69_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef69_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF69
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef70_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef70_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF70
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef71_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef71_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF71
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef72_a_reg">
      <bits access="rw" name="ca_tx_aclr_coef72_a" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF72
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef0_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef0_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef1_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef1_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef2_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef2_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef3_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef3_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef4_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef4_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef5_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef5_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef6_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef6_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef7_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef7_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef8_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef8_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef9_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef9_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef10_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef10_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef11_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef11_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef12_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef12_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef13_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef13_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef14_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef14_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef15_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef15_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef16_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef16_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef17_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef17_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF17
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef18_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef18_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF18
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef19_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef19_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF19
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef20_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef20_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF20
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef21_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef21_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF21
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef22_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef22_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF22
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef23_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef23_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF23
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef24_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef24_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF24
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef25_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef25_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF25
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef26_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef26_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF26
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef27_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef27_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF27
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef28_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef28_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF28
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef29_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef29_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF29
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef30_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef30_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF30
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef31_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef31_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF31
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef32_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef32_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF32
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef33_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef33_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF33
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef34_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef34_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF34
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef35_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef35_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF35
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef36_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef36_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF36
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef37_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef37_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF37
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef38_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef38_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF38
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef39_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef39_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF39
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef40_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef40_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF40
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef41_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef41_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF41
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef42_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef42_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF42
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef43_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef43_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF43
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef44_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef44_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF44
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef45_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef45_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF45
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef46_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef46_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF46
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef47_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef47_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF47
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef48_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef48_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF48
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef49_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef49_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF49
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef50_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef50_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF50
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef51_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef51_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF51
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef52_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef52_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF52
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef53_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef53_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF53
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef54_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef54_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF54
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef55_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef55_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF55
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef56_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef56_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF56
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef57_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef57_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF57
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef58_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef58_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF58
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef59_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef59_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF59
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef60_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef60_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF60
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef61_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef61_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF61
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef62_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef62_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF62
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef63_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef63_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF63
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef64_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef64_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF64
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef65_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef65_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF65
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef66_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef66_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF66
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef67_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef67_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF67
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef68_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef68_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF68
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef69_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef69_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF69
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef70_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef70_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF70
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef71_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef71_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF71
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef72_b_reg">
      <bits access="rw" name="ca_tx_aclr_coef72_b" pos="15:0" rst="0">
        <comment>
          CA TX ACLR COEF72
        </comment>
      </bits>
    </reg>
    <hole size="3520"/>
    <reg protect="rw" name="ca_tx_aclr_coef0_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef0_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef0_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef1_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef1_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef1_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef2_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef2_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef2_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef3_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef3_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef3_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef4_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef4_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef4_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef5_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef5_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef5_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef6_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef6_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef6_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef7_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef7_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef7_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef8_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef8_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef8_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef9_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef9_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef9_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef10_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef10_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef10_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef11_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef11_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef11_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef12_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef12_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef12_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef13_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef13_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef13_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef14_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef14_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef14_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef15_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef15_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef15_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef16_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef16_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef16_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef17_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef17_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef17_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF17
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef18_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef18_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef18_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF18
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef19_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef19_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef19_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF19
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef20_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef20_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef20_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF20
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef21_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef21_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef21_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF21
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef22_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef22_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef22_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF22
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef23_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef23_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef23_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF23
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef24_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef24_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef24_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF24
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef25_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef25_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef25_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF25
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef26_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef26_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef26_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF26
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef27_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef27_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef27_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF27
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef28_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef28_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef28_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF28
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef29_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef29_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef29_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF29
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef30_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef30_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef30_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF30
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef31_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef31_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef31_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF31
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef32_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef32_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef32_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF32
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef33_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef33_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef33_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF33
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef34_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef34_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef34_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF34
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef35_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef35_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef35_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF35
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef36_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef36_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef36_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF36
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef37_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef37_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef37_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF37
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef38_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef38_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef38_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF38
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef39_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef39_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef39_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF39
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef40_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef40_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef40_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF40
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef41_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef41_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef41_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF41
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef42_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef42_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef42_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF42
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef43_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef43_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef43_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF43
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef44_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef44_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef44_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF44
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef45_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef45_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef45_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF45
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef46_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef46_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef46_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF46
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef47_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef47_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef47_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF47
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef48_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef48_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef48_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF48
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef49_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef49_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef49_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF49
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef50_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef50_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef50_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF50
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef51_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef51_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef51_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF51
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef52_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef52_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef52_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF52
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef53_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef53_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef53_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF53
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef54_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef54_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef54_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF54
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef55_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef55_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef55_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF55
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef56_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef56_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef56_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF56
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef57_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef57_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef57_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF57
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef58_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef58_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef58_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF58
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef59_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef59_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef59_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF59
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef60_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef60_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef60_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF60
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef61_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef61_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef61_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF61
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef62_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef62_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef62_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF62
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef63_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef63_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef63_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF63
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef64_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef64_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef64_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF64
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef65_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef65_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef65_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF65
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef66_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef66_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef66_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF66
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef67_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef67_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef67_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF67
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef68_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef68_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef68_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF68
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef69_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef69_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef69_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF69
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef70_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef70_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef70_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF70
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef71_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef71_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef71_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF71
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef72_h_a_reg">
      <bits access="r" name="ca_tx_aclr_coef72_h_a_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef72_h_a" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF72
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef0_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef0_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef0_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef1_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef1_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef1_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef2_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef2_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef2_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef3_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef3_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef3_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef4_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef4_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef4_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef5_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef5_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef5_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef6_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef6_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef6_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef7_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef7_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef7_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef8_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef8_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef8_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef9_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef9_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef9_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef10_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef10_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef10_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef11_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef11_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef11_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef12_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef12_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef12_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF12
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef13_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef13_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef13_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF13
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef14_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef14_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef14_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF14
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef15_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef15_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef15_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF15
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef16_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef16_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef16_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef17_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef17_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef17_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF17
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef18_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef18_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef18_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF18
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef19_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef19_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef19_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF19
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef20_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef20_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef20_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF20
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef21_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef21_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef21_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF21
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef22_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef22_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef22_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF22
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef23_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef23_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef23_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF23
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef24_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef24_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef24_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF24
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef25_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef25_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef25_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF25
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef26_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef26_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef26_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF26
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef27_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef27_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef27_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF27
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef28_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef28_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef28_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF28
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef29_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef29_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef29_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF29
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef30_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef30_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef30_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF30
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef31_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef31_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef31_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF31
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef32_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef32_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef32_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF32
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef33_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef33_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef33_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF33
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef34_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef34_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef34_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF34
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef35_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef35_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef35_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF35
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef36_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef36_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef36_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF36
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef37_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef37_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef37_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF37
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef38_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef38_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef38_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF38
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef39_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef39_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef39_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF39
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef40_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef40_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef40_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF40
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef41_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef41_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef41_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF41
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef42_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef42_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef42_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF42
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef43_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef43_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef43_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF43
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef44_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef44_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef44_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF44
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef45_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef45_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef45_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF45
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef46_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef46_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef46_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF46
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef47_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef47_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef47_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF47
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef48_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef48_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef48_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF48
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef49_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef49_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef49_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF49
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef50_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef50_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef50_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF50
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef51_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef51_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef51_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF51
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef52_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef52_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef52_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF52
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef53_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef53_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef53_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF53
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef54_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef54_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef54_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF54
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef55_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef55_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef55_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF55
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef56_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef56_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef56_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF56
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef57_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef57_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef57_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF57
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef58_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef58_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef58_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF58
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef59_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef59_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef59_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF59
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef60_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef60_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef60_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF60
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef61_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef61_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef61_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF61
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef62_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef62_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef62_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF62
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef63_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef63_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef63_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF63
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef64_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef64_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef64_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF64
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef65_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef65_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef65_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF65
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef66_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef66_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef66_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF66
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef67_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef67_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef67_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF67
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef68_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef68_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef68_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF68
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef69_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef69_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef69_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF69
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef70_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef70_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef70_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF70
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef71_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef71_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef71_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF71
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_tx_aclr_coef72_h_b_reg">
      <bits access="r" name="ca_tx_aclr_coef72_h_b_reg_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="ca_tx_aclr_coef72_h_b" pos="0" rst="0">
        <comment>
          CA TX ACLR COEF72
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "calendar.xml">
<module name="calendar" category="System">

    <reg name="Ctrl" protect="rw">

        <bits name="Interval" pos="1:0" access="rw" rst="0">
            <options>
                <default/>
                <option name="DISABLE" value="0"/>
                <option name="PER SEC" value="1"/>
                <option name="PER MIN" value="2"/>
                <option name="PER HOUR" value="3"/>
            </options>
            <comment>These 2 bits configure the interval of generating an IRQ status.
            </comment>
        </bits>
    </reg>
    
    <reg name="Cmd" protect="rw">
        <bits name="Calendar_Load" pos="0" access="rs" rst="0">
            <comment>When write, command to program calendar with a new value (sec, min, hour, day, month, year, day of week) previously written in registers Calendar_LoadVal_H and Calendar_LoadVal_L. This bit is auto cleared.
                <br/>'1' = load calendar timer.  
                <br/>
                <br/>When read, Calendar timer load status.
                <br/>'1' = Calendar load has not finished.
                <br/>'0' = Calendar load has finished.
            </comment>
        </bits>
        <bits name="Alarm_Load" pos="4" access="rs" rst="0">
            <comment>When write, command to program alarm with a new value (sec, min, hour, day, month, year, day of week) prviously written in registers AlarmVal_H and AlarmVal_L. This bit is auto cleared. 
                <br/>'1' = load alarm.
                <br/>
                <br/>When read, alarm load status.
                <br/>'1' = alarm load has not finished.
                <br/>'0' = alarm load has finished.
            </comment>
        </bits>
        <bits name="Alarm_Enable_Set" pos="5" access="rs" rst="0">
            <comment>command to enable alarm. When alarm is triggered, it will generate a wakup.
                <br/>'1' = enable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm enable operation is on going, not finished.
                <br/>'0' = alarm is enabled.                  
            </comment>
        </bits>
        <bits name="Alarm_Enable_Clr" pos="6" access="rc" rst="0">
            <comment>command to disable alarm.
                <br/>'1' = disable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm disable operation is on going, not finished.
                <br/>'0' = alarm is disabled.                  
            </comment>
        </bits>
        <bits name="Alarm_Clr" pos="8" access="rc" rst="0">
            <comment>writing '1', clear Alarm triggered signal (connect to wakeup) and alarm triggered IRQ.
                <br/>
                <br/>When read, get alarm clear status.
                <br/>'1' = alarm clear operation is on going, not finished.
                <br/>'0' = alarm is cleared.                  
            </comment>
        </bits>
        <bits name="Itv_Irq_Clr" pos="9" access="c" rst="0">
            <comment>writing '1', clear interval IRQ.
            </comment>
        </bits>
        <bits name="Itv_Irq_Mask_Set" pos="16" access="rs" rst="0">
            <comment>When write '1', Set interval Irq Mask. 
                <br/>When read, get interval Irq mask.
            </comment>
        </bits>        
        <bits name="Itv_Irq_Mask_Clr" pos="17" access="rc" rst="0">
            <comment>When write '1', Clear interval Irq Mask. 
                <br/>When read, get inteval Irq mask.
            </comment>
        </bits>               
        <bits name="Calendar_Not_Valid" pos="31" access="rs" rst="1">
            <comment>When write '1', mark calendar value to be not valid.
                <br/>
                <br/>When read, Indicate if the Calendar value is valid or not.
                <br/>The calendar value is not valid in case of mismatch between the calendar counter and the APB register,
                    which is the case of wakeup the phone after shut down. This mismatch disappear after one RTC cycle or 
                    after re-porgramming a new calendar value. 
                <br/>'1' = not valid.
            </comment>
        </bits>        
    </reg>

    <reg name="Status" protect="r">
        
        <bits name="Itv_Irq_Cause" pos="0" access="r" rst="0">
            <comment>Interval Irq Cause. 
            </comment>
        </bits>    
        <bits name="Alarm_Irq_Cause" pos="1" access="r" rst="0">
            <comment>Alarm Irq Cause. 
            </comment>
        </bits> 
        <bits name="Force_Wakeup" pos="8" access="r" rst="0">
             <comment>Force Wakeup status. After set "Force_Wakeup" to '1' in sys_ctrl, the real
                 force_wakeup is not set immediatly, this bit indicates when the force wakeup is 
                 really set. This bits also indicates if the interface between Calendar domain and
                 Core domain is enabled. 
                <br/>'1': force wakeup set.
            </comment>
        </bits>           
        <bits name="Chg_Mask" pos="12" access="r" rst="0">
             <comment>Charger Mask status. After set "Chg_Mask" to '1' in sys_ctrl, the real
                 Chg_Mask line is not set immediatly, this bit indicates when the Chg_Mask line is
                 really set.                
                <br/>'1': Chg_Mask line set.
            </comment>
        </bits>           
        <bits name="Itv_Irq_Status" pos="16" access="r" rst="0">
            <comment>Interval Irq Status. 
            </comment>
        </bits>        
        <bits name="Alarm_Enable" pos="20" access="r" rst="0">
            <comment>Alarm Enable Status. 
                <br/> Note: When calendar is not programmed, Alarm can be enabled or not. 
                <br/> It is suggested to clear Alarm Enable when program RTC. 
            </comment>
        </bits>          
        <bits name="Calendar_Not_Prog" pos="31" access="r" rst="0">
            <comment>'1' = Calendar has not been programmed. 
                <br/>This bit keep value '0' after the calendar is programmed once.
            </comment>
        </bits>
    </reg>

    <reg name="Calendar_LoadVal_L" protect="rw">
        <bits name="Sec" pos="5:0" access="rw" rst="-">
            <comment>Second value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name="Min" pos="13:8" access="rw" rst="-">
            <comment>Minute value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name="Hour" pos="20:16" access="rw" rst="-">
            <comment>Hour value loaded to calendar, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name="Calendar_LoadVal_H" protect="rw">
        <bits name="Day" pos="4:0" access="rw" rst="-">
            <comment>Day value loaded to calendar, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name="Mon" pos="11:8" access="rw" rst="-">
            <comment>Month value loaded to calendar, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name="Year" pos="22:16" access="rw" rst="-">
            <comment>Year value loaded to calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
        <bits name="WeekDay" pos="26:24" access="rw" rst="-">
            <comment>Day of the week value loaded to calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
        </bits>
    </reg>

    <reg name="Calendar_CurVal_L" protect="r">
        <bits name="Sec" pos="5:0" access="r" rst="-">
            <comment>Current Second value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Min" pos="13:8" access="r" rst="-">
            <comment>Current Minute value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="Hour" pos="20:16" access="r" rst="-">
            <comment>Current Hour value of calendar, ranged from 0 to 23. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
    </reg>
    
    <reg name="Calendar_CurVal_H" protect="r">
        <bits name="Day" pos="4:0" access="r" rst="-">
            <comment>Current Day value of calendar, ranged from 1 to 31. 
                <br/>Maximum number of days in each month are stored in the module,
                and leap year is supported, so February can have 28 or 29 days.  
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="Mon" pos="11:8" access="r" rst="-">
            <comment>Current Month value of calendar, ranged from 1 to 12. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="Year" pos="22:16" access="r" rst="-">
            <comment>Current Year value of calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WeekDay" pos="26:24" access="r" rst="-">
            <comment>Current Day of the week value of calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
     
    <reg name="AlarmVal_L" protect="rw">
        <bits name="Sec" pos="5:0" access="rw" rst="-">
            <comment>Second value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name="Min" pos="13:8" access="rw" rst="-">
            <comment>Minute value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name="Hour" pos="20:16" access="rw" rst="-">
            <comment>Hour value loaded to alarm, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name="AlarmVal_H" protect="rw">
        <bits name="Day" pos="4:0" access="rw" rst="-">
            <comment>Day value loaded to alarm, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name="Mon" pos="11:8" access="rw" rst="-">
            <comment>Month value loaded to alarm, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name="Year" pos="22:16" access="rw" rst="-">
            <comment>Year value loaded to alarm, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
    </reg>
    <reg name="Calib_Cfg" protect="rw">
        <bits name="Interval_Min" pos="5:0" access="rw" rst="0">
        </bits>
        <bits name="Interval_Hour" pos="10:6" access="rw" rst="0">
        </bits>
        <bits name="Trig_Enable" pos="31" access="rw" rst="0">
        </bits>
    </reg>
    
    <reg name="Free_Cnt_Cfg" protect="rw">
        <bits name="Counter_Enable" pos="0" access="rw" rst="1">
        </bits>
        <bits name="Counter_Clear" pos="4" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="Free_Cnt_Cur_Val_L" protect="r">
        <bits name="Cur_Val_L" pos="31:0" access="r" rst="-">
        </bits>
    </reg>
    <reg name="Free_Cnt_Cur_Val_H" protect="r">
        <bits name="Cur_Val_H" pos="15:0" access="r" rst="-">
        </bits>
    </reg>
    
</module>



</archive>

<archive relative = "cholk.xml">
    <module name="cholk" category="Baseband">
    <reg32 name="CHOLK_CTRL" protect="rw">
      <bits name="CHOLK_ON" pos="0" access="rw" rst="0">
	      <comment>write 1 will enable CHOLK module
	      </comment>
      </bits>
      <bits name="CHOLK_INT_MASK" pos="1" access="rw" rst="0">
	      <comment>1:level INT will be masked, 0:level INT will not be masked
	      </comment>
      </bits>   
      <bits name="CHOLK_MODE" pos="2" access="rw" rst="0">
	      <comment>1: Complex mode ; 0: Real mode
	      </comment>
      </bits>      
    </reg32>

    <reg32 name="GAIN" protect="rw">
      <bits name="RESI_GAIN" pos="1:0" access="rw" rst="0">
	      <comment>RESI GAIN
	      </comment>
      </bits> 
  
      <bits name="RESI2_GAIN" pos="3:2" access="rw" rst="0">
	      <comment>RESI2 GAIN
	      </comment>
      </bits> 


      <bits name="OGRS_GAIN" pos="5:4" access="rw" rst="0">
	      <comment>OGRS_GAIN
	      </comment>
      </bits> 


      <bits name="OLES1_GAIN" pos="7:6" access="rw" rst="0">
	      <comment>OLES1_GAIN
	      </comment>
      </bits> 

      <bits name="OLES2_GAIN" pos="9:8" access="rw" rst="0">
	      <comment>OLES2_GAIN
	      </comment>
      </bits> 

      <bits name="COEF_GAIN" pos="11:10" access="rw" rst="0">
	      <comment>COEF_GAIN
	      </comment>
      </bits> 

      <bits name="GRAD_GAIN" pos="13:12" access="rw" rst="0">
	      <comment>GRAD_GAIN
	      </comment>
      </bits> 
                                   
 
      <bits name="GOPS_GAIN" pos="15:14" access="rw" rst="0">
	      <comment>GOPS_GAIN
	      </comment>
      </bits> 

      <bits name="OLES3_GAIN" pos="17:16" access="rw" rst="0">
	      <comment>OLES3_GAIN
	      </comment>
      </bits> 
     </reg32>    

    <reg32 name="ITER_THRE" protect="rw">
      <bits name="ITER_THRE1" pos="15:0" access="rw" rst="0">
	      <comment>ITER_THRE1
	      </comment>
      </bits> 
     </reg32> 

    <reg32 name="MCOVA_BASE" protect="rw">
      <bits name="MCOVA_BASE" pos="12:0" access="rw" rst="0">
	      <comment>Matrix COVA base addr in BBSRAM
	      </comment>
      </bits> 
     </reg32> 

    <reg32 name="MCE_BASE" protect="rw">
      <bits name="MCE_BASE" pos="12:0" access="rw" rst="0">
	      <comment>CE base addr in BBSRAM
	      </comment>
      </bits> 
     </reg32>      

    <reg32 name="MCOEF_BASE" protect="rw">
      <bits name="MCOEF_BASE" pos="12:0" access="rw" rst="0">
	      <comment>COEF base addr in BBSRAM
	      </comment>
      </bits> 
     </reg32>   

    <reg32 name="NUMBER" protect="rw">
      <bits name="ROW_NUMBER" pos="4:0" access="rw" rst="0">
	      <comment>Matrix Row Number, maximal is 24 for Real, and 16 for Complex
	      </comment>
      </bits> 

      <bits name="MCOVA_NUMBER" pos="13:5" access="rw" rst="0">
	      <comment>Matrix COVA effective element number - 1 to read
	      </comment>
      </bits> 
      
      <bits name="ITER_NUMBER" pos="18:14" access="rw" rst="0">
	      <comment>MAXIMAL iteration number - 1 for CHOLK
	      </comment>
      </bits> 
  </reg32> 

   <reg32 name="CHOLK_STATUS" protect="rw">
      <bits name="CHOLK_STATUS" pos="0" access="rw" rst="1">
	      <comment>CHOLK Done status, ACC enable and SW write this bit will clear this Done status, hardware will set this bit when done.
	      </comment>
      </bits> 
  </reg32>  

   <reg32 name="CHOLK_INT" protect="rw">
      <bits name="CHOLK_INT_RAW" pos="0" access="rw" rst="1">
	      <comment>write 0 to this bit will clear CHOLK level RAW interrupt source bit, write 1 will not. read this bit will get raw cholk INT source bit
	      </comment>
      </bits>
      <bits name="CHOLK_INT_out" pos="1" access="r" rst="1">
	      <comment>read this bit will get cholk INT status after masking. INT_out = INT_RAW and ~MASK
	      </comment>
      </bits>                     
   </reg32>                

  </module>
</archive>     
<archive relative = "cipher.xml">
<module name="cipher" category="Baseband">
  <reg protect="rw" name="ctrl">
    <bits access="w" name="Enable" pos="0" rst="no">
        <comment>
            Writing a '1' in this register triggers an A5 process. Ignored if the module is
            already processing. Auto-reset bit
        </comment>
    </bits>
    <bits access="rw" name="Algorithm" pos="4" rst="1">
        <comment>Selects the appropriate algorithm
        </comment>
        <options>
            <option name="A5_1" value="0"/>
            <option name="A5_2" value="1"/>
        </options>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Running" pos="0" rst="0">
      <comment>1 when running, 0 in other case. </comment>
    </bits>
    <bits access="r" name="Data_Blk_Rdy" pos="4" rst="0">
        <comment>1 when data block ready (Ciphering processed), reseted when the data register is read.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Kc low">
    <bits access="rw" name="Kc_Lsb" pos="31:0" rst="0xFFFFFFFF" display="hex">
      <comment>Cipher key Kc, LSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="Kc high">
    <bits access="rw" name="Kc_Msb" pos="31:0" rst="0xFFFFFFFF" display="hex">
      <comment>Cipher key Kc, MSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="Count">
    <bits access="rw" name="Count" pos="21:0" rst="0x3FFFFFF" display="hex">
      <comment>Count register, this field represent the TDMA frame number.</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data0_block2">
    <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[31:0]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data1_block2">
      <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[63:32]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data2_block2">
    <bits access="r" name="Data_blk2" pos="31:0" rst="no">
      <comment>Data block2 bit[95:64]</comment>
    </bits>
  </reg>

  <reg protect="r" name="Data3_block2">
    <bits access="r" name="Data_blk2" pos="17:0" rst="no">
      <comment>Data block2 bit[113:96]</comment>
    </bits>
  </reg>

 <struct count="29" name="Data_block1">
    <reg protect="r" name="Data block1">
      <bits access="r" name="Bit0" pos="7" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit1" pos="15" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit2" pos="23" rst="no">
        <comment> </comment>
      </bits>
      <bits access="r" name="Bit3" pos="31" rst="no">
        <comment> </comment>
      </bits>
    </reg>
  </struct>

</module>
</archive>
<archive relative = "cipher_a53.xml">
<module name="cipher_a53" category="Baseband">
  <reg16 name="CIPH_STAT" protect="rw" >
      <bits access="r" name="RES" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="A53" pos="4" rst="0"> 
          <comment>
              Select Between A5/1-A5/2 and A5/3 Ciphering Block
          </comment>
      </bits>
      <bits access="rw" name="INIT" pos="3" rst="0"> 
          <comment>
              Initialize A5/3 Ciphering
          </comment>
      </bits>
      <bits access="rw" name="EDGE" pos="2" rst="0">
          <comment>
              Select Ciphering Blcok Size
          </comment>
      </bits>
      <bits access="rw" name="A52" pos="1" rst="0"> 
          <comment>
              Switch Between A5/1 and A5/2 Algorithm if A5/1-A5/2 Block is Selected
          </comment>
      </bits>
      <bits access="rw" name="CACT" pos="0" rst="0"> 
          <comment>
              Status and Activation of Ciphering Block
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register0" protect="rw" >
      <bits access="rw" name="KEY0" pos="15:0" rst="0">
          <comment>
              Cipher Key0
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register1" protect="rw" >
      <bits access="rw" name="KEY1" pos="15:0" rst="0">
          <comment>
              Cipher Key1
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register2" protect="rw" >
      <bits access="rw" name="KEY2" pos="15:0" rst="0">
          <comment>
              Cipher Key2
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register3" protect="rw" >
      <bits access="rw" name="KEY3" pos="15:0" rst="0">
          <comment>
              Cipher Key3
          </comment>
      </bits>
  </reg16>

  <reg16 name="TMOD26" protect="rw" >
      <bits access="rw" name="A52_RES_TMOD26" pos="15:5" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="A52_T26N" pos="4:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="TMOD51" protect="rw" >
      <bits access="rw" name="A52_RES_TMOD51" pos="15:6" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="A52_T51N" pos="5:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="SFNUM" protect="rw" >
      <bits access="rw" name="A52_RES_SFNUM" pos="15:11" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="A52_SFN" pos="10:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register4" protect="rw" >
      <bits access="rw" name="KEY4" pos="15:0" rst="0">
          <comment>
              Cipher Key4
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register5" protect="rw" >
      <bits access="rw" name="KEY5" pos="15:0" rst="0">
          <comment>
              Cipher Key5
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register6" protect="rw" >
      <bits access="rw" name="KEY6" pos="15:0" rst="0">
          <comment>
              Cipher Key6
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Register7" protect="rw" >
      <bits access="rw" name="KEY7" pos="15:0" rst="0">
          <comment>
              Cipher Key7
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data1" protect="rw" >
      <bits access="rw" name="CA" pos="15:8" rst="0">
          <comment>
              GSM mode:00001111
              EDGE mode:11110000
          </comment>
      </bits>
      <bits access="rw" name="CB" pos="7:3" rst="0">
          <comment>
              CB=0000
          </comment>
      </bits>
      <bits access="rw" name="CD" pos="2" rst="0">
          <comment>
              CD=0
          </comment>
      </bits>
      <bits access="r" name="RES_KEY_DAT1" pos="1:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data2" protect="rw" >
      <bits access="rw" name="CE" pos="15:0" rst="0">
          <comment>
              CE=0000000000000000
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data3" protect="rw" >
      <bits access="r" name="RES_15_14" pos="15:14" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="SFN_10_5" pos="13:8" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="r" name="RES_7_0" pos="7:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="Key Data4" protect="rw" >
      <bits access="rw" name="SFN_4_0" pos="15:11" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="T51N" pos="10:5" rst="0">
          <comment>
          </comment>
      </bits>
      <bits access="rw" name="T26N" pos="4:0" rst="0">
          <comment>
          </comment>
      </bits>
  </reg16>

  <reg16 name="unused1" protect="rc" count="112" >
  </reg16>

  <reg16 name="block1" protect="rw" count="8" >
  </reg16>

  <reg16 name="unused2" protect="rc" count="24" >
  </reg16>

  <reg16 name="block2" protect="rw" count="8" >
  </reg16>

</module>

<module name="cipher_a53_spram" category="System">
    <memory name="spram_array" size="64*2">
        <comment>cipher_a53 internal Spram space
        </comment>
    </memory>
</module>

</archive>

<archive relative = "cm4_cache.xml">
  <module name="cm4_cache" category="Debug">
    <reg protect="rw" name="bus_cfg0">
      <bits access="r" name="reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_prot_en7" pos="23" rst="0">
        <comment>
          0: block7, protect disabled or access permitted
1: block7, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en6" pos="22" rst="0">
        <comment>
          0: block6, protect disabled or access permitted
1: block6, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en5" pos="21" rst="0">
        <comment>
          0: block5, protect disabled or access permitted
1: block5, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en4" pos="20" rst="0">
        <comment>
          0: block4, protect disabled or access permitted
1: block4, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en3" pos="19" rst="0">
        <comment>
          0: block3, protect disabled or access permitted
1: block3, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en2" pos="18" rst="0">
        <comment>
          0: block2, protect disabled or access permitted
1: block2, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en1" pos="17" rst="0">
        <comment>
          0: block1, protect disabled or access permitted
1: block1, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_prot_en0" pos="16" rst="0">
        <comment>
          0: block0, protect disabled or access permitted
1: block0, protect enabled or access forbidden
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en7" pos="15" rst="0">
        <comment>
          0: block7, cache remap disabled
1: block7, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en6" pos="14" rst="0">
        <comment>
          0: block6, cache remap disabled
1: block6, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en5" pos="13" rst="0">
        <comment>
          0: block5, cache remap disabled
1: block5, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en4" pos="12" rst="0">
        <comment>
          0: block4, cache remap disabled
1: block4, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en3" pos="11" rst="0">
        <comment>
          0: block3, cache remap disabled
1: block3, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en2" pos="10" rst="0">
        <comment>
          0: block2, cache remap disabled
1: block2, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en1" pos="9" rst="0">
        <comment>
          0: block1, cache remap disabled
1: block1, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_remap_en0" pos="8" rst="0">
        <comment>
          0: block0, cache remap disabled
1: block0, cache remap enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en7" pos="7" rst="0">
        <comment>
          0: block7, cache disabled
1: block7, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en6" pos="6" rst="0">
        <comment>
          0: block6, cache disabled
1: block6, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en5" pos="5" rst="0">
        <comment>
          0: block5, cache disabled
1: block5, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en4" pos="4" rst="0">
        <comment>
          0: block4, cache disabled
1: block4, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en3" pos="3" rst="0">
        <comment>
          0: block3, cache disabled
1: block3, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en2" pos="2" rst="0">
        <comment>
          0: block2, cache disabled
1: block2, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en1" pos="1" rst="0">
        <comment>
          0: block1, cache disabled
1: block1, cache enabled
        </comment>
      </bits>
      <bits access="rw" name="rf_blk_cache_en0" pos="0" rst="0">
        <comment>
          0: block0, cache disabled
1: block0, cache enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg1">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr1" pos="27:12" rst="0">
        <comment>
          block 1 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg2">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr2" pos="27:12" rst="0">
        <comment>
          block 2 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg3">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr3" pos="27:12" rst="0">
        <comment>
          block 3 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg4">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr4" pos="27:12" rst="0">
        <comment>
          block 4 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg5">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr5" pos="27:12" rst="0">
        <comment>
          block 5 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg6">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr6" pos="27:12" rst="0">
        <comment>
          block 6 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_cfg7">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_blk_base_addr7" pos="27:12" rst="0">
        <comment>
          block 7 start address
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap0">
      <bits access="rw" name="rf_blk0_remap_offset0" pos="31:12" rst="0">
        <comment>
          block 0 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk0_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap1">
      <bits access="rw" name="rf_blk1_remap_offset1" pos="31:12" rst="0">
        <comment>
          block 1 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk1_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap2">
      <bits access="rw" name="rf_blk2_remap_offset2" pos="31:12" rst="0">
        <comment>
          block 2 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk2_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap3">
      <bits access="rw" name="rf_blk3_remap_offset3" pos="31:12" rst="0">
        <comment>
          block 3 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk3_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap4">
      <bits access="rw" name="rf_blk4_remap_offset4" pos="31:12" rst="0">
        <comment>
          block 4 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk4_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap5">
      <bits access="rw" name="rf_blk5_remap_offset5" pos="31:12" rst="0">
        <comment>
          block 5 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk5_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap6">
      <bits access="rw" name="rf_blk6_remap_offset6" pos="31:12" rst="0">
        <comment>
          block 6 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk6_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bus_remap7">
      <bits access="rw" name="rf_blk7_remap_offset7" pos="31:12" rst="0">
        <comment>
          block 7 remap offset when the block remap function is enabled, the address after remap will be original addr + rf_blk7_remap_offset
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="11:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="cache_cfg0">
      <bits access="rw" name="rf_debug_en" pos="31" rst="0">
        <comment>
          cache debug mode enable: 
0: normal mode
1: debug mode
This bit MUST always be cleared during cache operating 
        </comment>
      </bits>
      <bits access="rw" name="rf_cmd_exec_mode" pos="30" rst="0">
        <comment>
          0: (recommended) software can run in cacheable region during software command processing
1: software cannot run in cacheable region during software command processing
        </comment>
      </bits>
      <bits access="rw" name="rf_cache_size_sel" pos="29:28" rst="0">
        <comment>
          cache size selection: 
0: 4K Byte
1: 8K Byte
2: 16K Byte
3: 32K Byte
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="27:14" rst="0">
      </bits>
      <bits access="rw" name="rf_hprot_cache_reg" pos="13:10" rst="11">
        <comment>
          hprot control register which provide 4bit hprot for cache ctrl AHB?
        </comment>
      </bits>
      <bits access="rw" name="rf_hprot_bus_reg" pos="9:6" rst="3">
        <comment>
          hprot control register which provide 4bit hprot for cache bus AHB
        </comment>
      </bits>
      <bits access="rw" name="rf_hprot_byp" pos="5:2" rst="0">
        <comment>
          Bit [5]: 
1'b1: hprot[3] from CM4 go through cache controller without modification
1'b0: hprot[3] is provided by cache controller register
Bit [4]: 
1'b1: hprot[2] from CM4 go through cache controller without modification
1'b0: hprot[2] is provided by cache controller register
Bit [3]: 
1'b1: hprot[1] from CM4 go through cache controller without modification
1'b0: hprot[1] is provided by cache controller register
Bit [2]: 
1'b1: hprot[0] from CM4 go through cache controller without modification
1'b0: hprot[0] is provided by cache controller register
        </comment>
      </bits>
      <bits access="rw" name="rf_write_mode" pos="1:0" rst="0">
        <comment>
          cache write operation mode
2'b00: write through
2'b01: write back, no write allocate
2'b10: write back, write allocate
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="bus_sts0">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="r" name="rf_prot_detect_addr" pos="27:0" rst="0">
        <comment>
          trigging address for protect block?
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cache_sts0">
      <bits access="r" name="reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="r" name="rf_write_ongoing" pos="7" rst="0">
        <comment>
          rf_write_ongoing, this is a status register for write through mode to avoid potential coherence issue.
1'b1: the cache is still doing AHB write transaction to the main memory and the data is not written into the main memory.
1'b0: the cache has finished AHB write transaction and the data is written into the main memory. 
        </comment>
      </bits>
      <bits access="r" name="rf_cmd_st" pos="6:4" rst="0">
        <comment>
          rf_cmd_st
        </comment>
      </bits>
      <bits access="r" name="rf_cache_st" pos="3:0" rst="0">
        <comment>
          rf_cache_st
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="cmd_cfg0">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_cmd_str_addr" pos="27:0" rst="0">
        <comment>
          cmd_all : not used
cmd_range : start address
cmd_entry : entry address
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cmd_cfg1">
      <bits access="r" name="reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="rf_cmd_end_addr" pos="27:0" rst="0">
        <comment>
          cmd_all : not used
cmd_range : start address
cmd_entry : entry address
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cmd_cfg2">
      <bits access="w" name="rf_cmd_str" pos="31" rst="0">
        <comment>
          software command start: 
write 1 to this bit to issue one command 
        </comment>
      </bits>
      <bits access="r" name="reserved_0" pos="30:6" rst="0">
      </bits>
      <bits access="rw" name="rf_cmd_type" pos="5:0" rst="0">
      <options>
        <option name="CLNALL" value="0" />
        <option name="CLNRANG" value="1" />
        <option name="CLNETY" value="2" />
        <option name="INVALL" value="4" />
        <option name="INVRANG" value="5" />
        <option name="INVETY" value="6" />
        <option name="CLNINVALL" value="8" />
        <option name="CLNINVRANG" value="9" />
        <option name="CLNINVETY" value="10" />
        <default />
      </options>
        <comment>
          software command type:
6'h0 : clean all
6'h1 : clean range
6'h2 : clean entry
6'h3 : reserved
6'h4 : invalid all
6'h5 : invalid range
6'h6 : invalid entry
6'h7 : reserved
6'h8 : clean and invalid all
6'h9 : clean and invalid range
6'hA : clean and invalid entry
6'hB : reserved 
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="int_en">
      <bits access="r" name="reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rw" name="rf_prot_irq_en" pos="1" rst="0">
        <comment>
          interrupt enable for protect block trigging?
        </comment>
      </bits>
      <bits access="rw" name="rf_cmd_irq_en" pos="0" rst="0">
        <comment>
           interrupt enable for software command done
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="int_raw">
      <bits access="r" name="reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="rf_prot_irq_raw" pos="1" rst="0">
        <comment>
          interrupt raw status for protect block trigging
        </comment>
      </bits>
      <bits access="r" name="rf_cmd_irq_raw" pos="0" rst="0">
        <comment>
          interrupt raw status for software command done?
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="int_mask">
      <bits access="r" name="reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="r" name="rf_prot_irq_mask" pos="1" rst="0">
        <comment>
          interrupt masked status for protect block trigging
        </comment>
      </bits>
      <bits access="r" name="rf_cmd_irq_mask" pos="0" rst="0">
        <comment>
          interrupt masked status for software command done?
        </comment>
      </bits>
    </reg>
    <reg protect="w" name="int_clr">
      <bits access="w" name="reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="w" name="rf_prot_irq_clr" pos="1" rst="0">
        <comment>
          interrupt clear for protect block trigging
        </comment>
      </bits>
      <bits access="w" name="rf_cmd_irq_clr" pos="0" rst="0">
        <comment>
          interrupt clear for software command done?
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cache_write_hit_cnt">
      <bits access="r" name="rf_write_hit_cnt" pos="31:0" rst="0">
        <comment>
          Cache write hit times. When cache write hit, the counter value increment by 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cache_write_miss_cnt">
      <bits access="w" name="rf_write_cnt_clr" pos="31" rst="0">
        <comment>
          clear write counter values to zero?
        </comment>
      </bits>
      <bits access="rw" name="rf_write_cnt_run" pos="30" rst="0">
        <comment>
          1: write hit/miss counter will run
0: write hit/miss counter will stop 
        </comment>
      </bits>
      <bits access="r" name="rf_write_miss_cnt" pos="29:0" rst="0">
        <comment>
          Cache write hit times. When cache write hit, the counter value increment by 1
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cache_read_hit_cnt">
      <bits access="r" name="rf_read_hit_cnt" pos="31:0" rst="0">
        <comment>
          Cache read hit times. When cache read hit, the counter value increment by 1?
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cache_read_miss_cnt">
      <bits access="w" name="rf_read_cnt_clr" pos="31" rst="0">
        <comment>
          clear read counter values to zero?
        </comment>
      </bits>
      <bits access="rw" name="rf_read_cnt_run" pos="30" rst="0">
        <comment>
          1: read hit/miss counter will run
0: read hit/miss counter will stop 
        </comment>
      </bits>
      <bits access="r" name="rf_read_miss_cnt" pos="29:0" rst="0">
        <comment>
          Cache read miss times. When cache read miss, the counter value increment by 1
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cache_hact_cnt">
      <bits access="r" name="rf_hact_cnt" pos="31:0" rst="0">
        <comment>
          Cache master AHB active cycles in total. When master AHB is active (hsel and htrans[1]), the counter value increment by 1?
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="cache_hrdy_cnt">
      <bits access="w" name="rf_hact_hrdy_clr" pos="31" rst="0">
        <comment>
          clear HACT and HRDY counter values to zero
        </comment>
      </bits>
      <bits access="rw" name="rf_hact_hrdy_run" pos="30" rst="0">
        <comment>
          1: HACT and HRDY counters will run
0: HACT and HRDY counters will stop 
        </comment>
      </bits>
      <bits access="r" name="rf_hrdys_cnt" pos="29:0" rst="0">
        <comment>
          The HRDY counter counts the valid cycles of HREADY signal from the cache controller to the master when the master AHB is active. When HREADY signal to the master is high and the master AHB is active, the counter value increment by 1?
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "cordic.xml">

<module name="cordic" category="Baseband">

  <reg name="yin" protect="rw">
    <bits access="rw" name="y_addr" pos="31:0" rst="0x0">
      <comment>Control setting. y, i.e. numerator of atan computation. </comment>
    </bits>
  </reg>

  <reg name="xin" protect="rw">
    <bits access="rw" name="x_addr" pos="31:0" rst="0x0">
      <comment>Control setting. x, i.e. denominator of atan computation. </comment>
    </bits>
  </reg>

  <reg name="cmd" protect="rw">
    <bits access="rw" name="cmd" pos="0:0" rst="0x0">
      <comment>The start signal. Use the posedge of this signal. </comment>
      <options>
          <option name="RST" value="0"></option>
          <option name="START" value="1"></option>
      </options>
    </bits>
  </reg>

  <reg name="status" protect="r">
    <bits access="r" name="op" pos="31:0" rst="0x0">
      <comment>Status is set to 1 when an operation is finished. </comment>
      <options>
          <option name="Busy" value="0x00000000"></option>
          <option name="Free" value="0xFFFFFFFF"></option>
      </options>
    </bits>
  </reg>


  <reg name="dout" protect="r">
    <bits access="r" name="result_angle" pos="15:0" rst="0x0">
        <comment>. angle. The actual value is angle*pi/4</comment>
    </bits>
    <bits access="r" name="result_amplitude" pos="31:16" rst="0x0">
      <comment>amplitude.</comment>
    </bits>
  </reg>

  <reg name="amp" protect="r">
    <bits access="r" name="result_amp" pos="16:0" rst="0x0">
      <comment>amplitude only.</comment>
      <options>
          <mask/>
      </options>
    </bits>
  </reg>

</module>

</archive>
<archive relative="dbm.xml">
  <module name="dbm" category="BT">
    <reg protect="rw" name="sel">
      <bits access="r" name="sel_reserved_0" pos="31:2" rst="0">
      </bits>
      <bits access="rw" name="src_sel" pos="1" rst="0">
        <comment>
          source selection
0 : modem
1 : other
        </comment>
      </bits>
      <bits access="rw" name="dbm_en" pos="0" rst="0">
        <comment>
          debug bus master enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="trans">
      <bits access="rw" name="word_len" pos="31:12" rst="0">
        <comment>
          transfer word length
        </comment>
      </bits>
      <bits access="rw" name="data_sel" pos="11:8" rst="0">
        <comment>
          data selection
        </comment>
      </bits>
      <bits access="rw" name="dump_trig_sel" pos="7" rst="0">
        <comment>
          dump trigger selection
select trigger from soft or hardware
        </comment>
      </bits>
      <bits access="rw" name="wrap_en" pos="6" rst="0">
        <comment>
          wrap the whole fifo, when EOF, keep on write by the start addr
        </comment>
      </bits>
      <bits access="rw" name="burst_type" pos="5:4" rst="0">
        <comment>
          burst type
2'h00:: single
2'h01:: incr4
2'b10:: incr8
2'b11:: incrx
        </comment>
      </bits>
      <bits access="rw" name="burst_len" pos="3:0" rst="0">
        <comment>
          length of burst when incrx
max incr16
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr" pos="31:0" rst="0">
        <comment>
          start address of transfer
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="mask">
      <bits access="r" name="mask_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="rw" name="mask_trans_err" pos="3" rst="0">
        <comment>
          mask for transfer error
        </comment>
      </bits>
      <bits access="rw" name="mask_ovfl" pos="2" rst="0">
        <comment>
          mask for ovfl 
        </comment>
      </bits>
      <bits access="rw" name="mask_comp_half" pos="1" rst="0">
        <comment>
          mask for comp half
        </comment>
      </bits>
      <bits access="rw" name="mask_comp_end" pos="0" rst="0">
        <comment>
          mask for comp end
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="status">
      <bits access="r" name="status_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rc" name="int_trans_err_status" pos="4" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          interrupt for ahb transfer error
        </comment>
      </bits>
      <bits access="rc" name="int_ovfl_status" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          interrupt from fifo overfolw
        </comment>
      </bits>
      <bits access="rc" name="int_comp_half_status" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          half interrupt from transfer complete
        </comment>
      </bits>
      <bits access="rc" name="int_comp_end_status" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          end interrupt from transfer complete
        </comment>
      </bits>
      <bits access="r" name="srst_done_status" pos="0" rst="1">
        <comment>
          data_packer soft reset done
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="soft_reset">
      <bits access="r" name="soft_reset_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="s" name="s_reset" pos="0" rst="0">
        <comment>
        bit type is changed from wos to s.

          soft reset
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="soft_trig">
      <bits access="r" name="soft_trig_reserved_0" pos="31:1" rst="0">
      </bits>
      <bits access="s" name="s_dp_trig" pos="0" rst="0">
        <comment>
        bit type is changed from wos to s.

          dump trigger from soft
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "debug_host.xml">


<module name="debug_host" category="Debug">
  <reg protect="--" name="cmd">
    <bits access="r" name="Addr" pos="28:0" rst="-">
      <comment>Address of data to be read or written. </comment>
    </bits>

    <bits access="r" name="Size" pos="30:29" rst="-">
      <comment>These two bits indicates element data size. <br />
            when "00" = "byte". <br />
            when "01" = "half word". <br />
            when "10" = "word". 
        </comment>
    </bits>

    <bits access="r" name="Write_H" pos="31" rst="-">
      <comment>This bit indicates command is read or write. <br />
        when "0" = "Read". <br />
        when "1" = "Write".  
      </comment>
    </bits>

  </reg>

  <reg protect="--" name="data">
    <bits access="rw" name="data" pos="31:0" rst="-">
      <comment>Those bits are data to be read or written by IFC. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="event">
    <bits access="rw" name="event0_sema" pos="0" rst="0">
      <comment>When read, this bit is used for event semaphore. <br />
            '0' = no new event should be programed. <br />
            '1' = no pending event, new event is authorised. <br />
            If host is not enabled, this bit is always '1'. However in this case, 
            any event written will be ignored. <br />
            When Write, this bit is the least significant bit for a 32-bit event.
      </comment>
    </bits>

    <bits access="w" name="event31_1" pos="31:1" rst="-">
      <comment> These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will 
            be ignored. 
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="mode">
    <bits access="rw" name="force_on" pos="0" rst="1">
      <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected. </comment>
    </bits>

    <bits access="r" name="Clk_Host_On" pos="1" rst="0">
      <comment>This bit indicates if clock host is detected to be on or not. <br />
            '0' = no clock host. <br />
            '1' = clock host detected. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="h2p_status">
    <bits access="r" name="h2p_status" pos="7:0" rst="0">
      <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB. </comment>
      <options>
        <mask/>
        <shift/>
      </options>
    </bits>
    <bits access="w" name="h2p_status_rst" pos="16" rst="0">
      <comment>write in this bit will reset h2p status register. </comment>
    </bits>
  </reg>
  
  <reg protect="rw" name="p2h_status">
    <bits access="rw" name="p2h_status" pos="7:0" rst="0">
      <comment>Status which can be written by APB and read through debug uart interface 
            as a debug host internal register.
      </comment>
    </bits>
  </reg>
  
  <reg protect="r" name="irq">
    <bits access="r" name="xcpu_irq" pos="0" rst="0">
      <comment>when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared. <br /> when read, get the xcpu
          irq status. </comment>
    </bits>
    
    <bits access="r" name="bcpu_irq" pos="1" rst="0">
      <comment>when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.<br /> when read, get the bcpu
            irq status.</comment>
    </bits>
    
  </reg>
</module>



</archive>

<archive relative = "debug_host_internals.xml">

<include file="globals.xml"/>

	<module name="debug_host_internal_registers" category="Debug">
		<ireg name="CTRL_SET" protect="rw">
			<comment>General control signals set.</comment>
			<bits name="Debug_Reset" pos="0" rst="0" access="rs">
				<comment>Debug host generated reset. Signal to system control. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rs">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rs">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rs">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rs">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_XCPU" pos="5" rst="0" access="rs">
				<comment>When write '1, generate a level IRQ to XCPU. Write '0 is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="IT_BCPU" pos="6" rst="0" access="rs">
				<comment>When write '1', generate a level IRQ to BCPU. Write '0' is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rs">
				<comment>Lock Debug port set.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
		</ireg>
		
		<ireg name="CTRL_CLR" protect="rw">
			<comment>General control signals clear.</comment>		
			<bits name="XCPU_Force_Reset" pos="1" rst="0" access="rc">
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_Wakeup" pos="2" rst="0" access="rc">
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name="Force_BP_XCPU" pos="3" rst="0" access="rc">
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>	
			<bits name="Force_BP_BCPU" pos="4" rst="0" access="rc">
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="Debug_Port_Lock" pos="7" rst="0" access="rc">
				<comment>Lock Debug port clear.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>            
		</ireg>

		<ireg name="CLKDIV" protect="rw">
			<comment>Configure Debug UART Clock divider.</comment>
			<bits name="CFG_CLK" pos="5:0" rst="2" access="rw">
				<comment>Debug host clock divider. The serial clock is generated by dividing  14,7456MHz Host Clock by (CFG_CLK+2). So By default, the serial clock is 14,7456MHz / (2+2) = 3,6864 MHz which corresponds to the 921,6K Baud-rate.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
        </ireg>

		<ireg name="CFG" protect="rw">
			<comment>Configure Debug UART.</comment>
			<bits name="Disable_Uart_H" pos="0" rst="0" access="rw">
                <comment>When '1', Disable Normal Uart functional group.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Disable_IFC_H" pos="1" rst="0" access="rw">
                <comment>When '1', Ignore IFC write and read access so only debug host internal is accessible.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Debug_Host_Sel" pos="2" rst="0" access="rw">
                <comment>The usage of this bit is deternimed by the specific chip.
                    <br/>Can be used as Debug_Port_Lock register to protect some register change by the regular software while debug hosr is used to set thoses registers to specific values.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name="Force_Prio_H" pos="7" rst="1" access="rw">
				<comment>When '1', force the Debug Uart to have priority on TX.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>	
        </ireg>
        

		<ireg name="CRC_REG" protect="rw">
			<comment>Status of CRC.</comment>
			<bits name="CRC" pos="0" rst="0" access="rc">
				<comment>This bit represents that an CRC error has occured in commands received by Debug Host. Once set to '1', it will keep the value until this register is clearred by write '1'.<br/>'0' = no CRC error.<br/>'1' = CRC error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name="FC_Fifo_Ovf" pos="1" rst="0" access="r">
				<comment>This bit represents if the 16-byte Flow Control FIFO has an overflow error. This status will be kept until a RX break is received.<br/>'0' = no Flow Control Overflow Error.<br/>'1' = Flow Control Overflow Error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>
			
		<ireg name="H2P_STATUS" protect="rw">
			<comment>Host write, APB readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be read by APB and write by host. Corresponds to APB register STATUS. They can also be reseted to zeros by APB command. (see details in debug host APB register mapping) <br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="P2H_STATUS" protect="rw">
			<comment>APB write, Host readable register.</comment>
			<bits name="STATUS" pos="7:0" rst="0" access="rw">
				<comment>These bits can be written by APB and read by host. Corresponds to APB register STATUS.<br/>Write to Bit 0 can reset the P2H status.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name="AHB_SYS_HMBURSREQ" protect="r">
			<comment>Debug information of system side AHB bus status.</comment>
			<bits name="SYS_IFC_HMBURSREQ" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HMBURSREQ.</comment>
			</bits>
			<bits name="SYS_DMA_HMBURSREQ" pos="1" rst="-" access="r">
				<comment>The bit represent Dma HMBURSREQ.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HMBURSREQ" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name="XCPU_HMBURSREQ" pos="3" rst="-" access="r">
				<comment>The bit represent Xcpu HMBURSREQ.</comment>
            </bits>
			<bits name="USBC_HMBURSREQ" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HMBURSREQ.</comment>
            </bits>
			<bits name="GOUDA_HMBURSREQ" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HMBURSREQ.</comment>
            </bits>
		</ireg>
            
		<ireg name="AHB_SYS_HMGRANT" protect="r">
			<bits name="SYS_IFC_HMGRANT" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HMGRANT.</comment>
			</bits>
			<bits name="SYS_DMA_HMGRANT" pos="1" rst="-" access="r">
				<comment>The bit represent Dma HMGRANT.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HMGRANT" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name="XCPU_HMGRANT" pos="3" rst="-" access="r">
				<comment>The bit represent Xcpu HMGRANT.</comment>
			</bits>
			<bits name="USBC_HMGRANT" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HMGRANT.</comment>
            </bits>
			<bits name="GOUDA_HMGRANT" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HMGRANT.</comment>
            </bits>            
		</ireg>
	
		<ireg name="AHB_SYS_HSEL" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="SYS_MEM_EXT_HSEL" pos="0" rst="-" access="r">
				<comment>The bit represent Sys MEM_EXT HSEL.</comment>
			</bits>
			<bits name="SYS_MEM_INT_HSEL" pos="1" rst="-" access="r">
				<comment>The bit represent Sys MEM_INT HSEL.</comment>
			</bits>
			<bits name="SYS_IFC_HSEL" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ifc HSEL.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HSEL" pos="3" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HSEL.</comment>
			</bits>
			<bits name="SYS_USBC_HSEL" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HSEL.</comment>
            </bits>
			<bits name="SYS_GOUDA_HSEL" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HSEL.</comment>
            </bits>               
			<bits name="SYS_XCPU_RAM_HSEL" pos="6" rst="-" access="r">
				<comment>The bit represent XCPU RAM HSEL.</comment>
            </bits>               
		</ireg>

		<ireg name="AHB_SYS_HSREADY" protect="r">
			<bits name="SYS_IFC_HSREADY" pos="0" rst="-" access="r">
				<comment>The bit represent Sys Ifc HSREADY.</comment>
			</bits>
			<bits name="SYS_MEM_HSREADY" pos="1" rst="-" access="r">
				<comment>The bit represent Sys EBC HSREADY.</comment>
			</bits>
			<bits name="SYS_AHB2AHB_HSREADY" pos="2" rst="-" access="r">
				<comment>The bit represent Sys Ahb2ahb HSREADY.</comment>
            </bits>
			<bits name="SYS_USBC_HSREADY" pos="4" rst="-" access="r">
				<comment>The bit represent USBC HSREADY.</comment>
            </bits>
			<bits name="SYS_GOUDA_HSREADY" pos="5" rst="-" access="r">
				<comment>The bit represent GOUDA HSREADY.</comment>
            </bits>               
			<bits name="SYS_XCPU_RAM_HSREADY" pos="6" rst="-" access="r">
				<comment>The bit represent XCPU RAM HSREADY.</comment>
            </bits>              
			<bits name="SYS_HREADY" pos="7" rst="-" access="r">
				<comment>The bit represent Sys HSREADY which is sent to all sys AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_MASTER" protect="r">
			<comment>Debug information of baseband side AHB bus status.</comment>
			<bits name="BB_IFC_HMBURSREQ" pos="0" rst="-" access="r">
				<comment>The bit represent BB Ifc HMBURSREQ.</comment>
			</bits>
			<bits name="BB_VOC_HMBURSREQ" pos="1" rst="-" access="r">
				<comment>The bit represent Voc HMBURSREQ.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HMBURSREQ" pos="2" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name="BCPU_HMBRSREQ" pos="3" rst="-" access="r">
				<comment>The bit represent Bcpu HMBURSREQ.</comment>
			</bits>
			<bits name="BB_IFC_HMGRANT" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ifc HMGRANT.</comment>
			</bits>
			<bits name="BB_VOC_HMGRANT" pos="5" rst="-" access="r">
				<comment>The bit represent Voc HMGRANT.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HMGRANT" pos="6" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name="BCPU_HMGRANT" pos="7" rst="-" access="r">
				<comment>The bit represent Bcpu HMGRANT.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_HSREADY" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="BB_MEM_HSREADY" pos="0" rst="-" access="r">
				<comment>The bit represent BB MEM HSREADY.</comment>
            </bits>
			<bits name="BB_VOC_HSREADY" pos="1" rst="-" access="r">
				<comment>The bit represent BB VoC HSREADY.</comment>
			</bits>
			<bits name="BB_SRAM_HSREADY" pos="2" rst="-" access="r">
				<comment>The bit represent BB Sram HSREADY.</comment>
			</bits>
			<bits name="BB_IFC_HSREADY" pos="3" rst="-" access="r">
				<comment>The bit represent BB Ifc HSREADY.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HSREADY" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HSREADY.</comment>
			</bits>
			<bits name="BB_HREADY" pos="7" rst="-" access="r">
				<comment>The bit represent BB HREADY which is sent to all BB AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_BB_HSEL" protect="r">
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name="BB_MEM_EXT_HSEL" pos="0" rst="-" access="r">
				<comment>The bit represent BB MEM_EXT HSEL.</comment>
			</bits>
			<bits name="BB_MEM_INT_HSEL" pos="1" rst="-" access="r">
				<comment>The bit represent BB MEM_INT HSEL.</comment>
			</bits>
			<bits name="BB_VOC_HSEL" pos="2" rst="-" access="r">
				<comment>The bit represent BB VOC HSEL.</comment>
			</bits>
			<bits name="BB_SRAM_HSEL" pos="3" rst="-" access="r">
				<comment>The bit represent BB Sram HSEL.</comment>
			</bits>
			<bits name="BB_IFC_HSEL" pos="4" rst="-" access="r">
				<comment>The bit represent BB Ifc HSEL.</comment>
			</bits>
			<bits name="BB_AHB2AHB_HSEL" pos="5" rst="-" access="r">
				<comment>The bit represent BB Ahb2ahb HSEL.</comment>
			</bits>
		</ireg>

		<ireg name="AHB_SYS_MASK_SPLIT" protect="r">
            <comment>Represents the split status register of the SYS_AHBC.</comment>
            <bits name="Sys_Mask_Split" pos="SYS_NB_MASTERS-1:1" access="r" rst="-" cut="1" cutenum="Sys_Master_Id" cutprefix="Mask_Split" cutstart="1">
            </bits>
		</ireg>
		<ireg name="AHB_BB_MASK_SPLIT" protect="r">
            <comment>Represents the split status register of the BB_AHBC.</comment>
            <bits name="BB_Mask_Split" pos="BB_NB_MASTERS:1" access="r" rst="-" cut="1" cutenum="BB_Master_Id" cutprefix="Mask_Split" cutstart="1">
            </bits>
		</ireg>
        
	</module>

</archive>

<archive relative = "debug_host_test_chip.xml">

  <include file="debug_host.xml" />
  <include file="debug_host_internals.xml" />


</archive>


<archive relative = "debug_uart.xml">
<module name="debug_uart" category="System">
  <var  name="DEBUG_UART_RX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="DEBUG_UART_NB_RX_FIFO_BITS" value="4"   />
  <var  name="DEBUG_UART_NB_TX_FIFO_BITS" value="4"   />
  <var  name="ESC_DAT"                    value="92"  />
  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
          first):<br />0 = 7 bits<br />1 = 8 bits <br /> This bit will be masked to
          '1' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. <br /> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. <br /> These bit will be ignored if debug host is
      enabled. </comment>
    </bits>

    <bits access="rw" name="Tx Break Control" pos="6" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.<br /> This bit will be masked to '0' if debug host
          is enabled. </comment>
      <options>
        <option name="OFF" value="0" />
        <option name="ON"  value="1" />
        <default />
      </options>
    </bits>

   <bits access="rw" name="RX FIFO RESET" pos="7" rst="0">
      <comment>reset rx fifo. </comment>
   </bits>

   <bits access="rw" name="TX FIFO RESET" pos="8" rst="0">
      <comment>reset tx fifo. </comment>
   </bits>


    <bits access="rw" name="DMA Mode" pos="9" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>

    <bits access="rw" name="SWRX flow ctrl" pos="13:12" rst="1">
        <comment> When this field is "00" and SWTX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no transmit flow control. <br />
            01 = transmit XON1/XOFF1 as flow control bytes<br />
            10 = transmit XON2/XOFF2 as flow control bytes<br />
            11 = transmit XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="SWTX flow ctrl" pos="15:14" rst="1">
        <comment> When this field is "00" and SWRX_flow_Ctrl is also "00", hardwre
            flow ctrl is used. Otherwise, software flow control is used: <br />
            00 = no receive flow control<br />
            01 = receive XON1/XOFF1 as flow control bytes<br />
            10 = receive XON2/XOFF2 as flow control bytes<br />
            11 = receive XON1 and XON2/XOFF1 and XOFF2 as flow control bytes<br />
            <br /> Note: If single XON/XOFF character is used for flow contol, the received 
            XON/XOFF character will not be put into Rx FIFO. This is also the case if XON is
            received when XOFF is expected. <br />
            If double XON/XOFF characters are expected, the XON1/XOFF1 must followed sequently 
            by XON2/XOFF2 to be considered as patterns, which will not be put into Rx FIFO. 
            Otherwise they will be considered as data. This is also the case if XOFF1 is followed
            by character other than XOFF2. <br />
        </comment>
        <options><default/><mask/><shift/></options>
    </bits>

    <bits access="rw" name="BackSlash En" pos="16" rst="1">
        <comment> When soft flow control characters or backslash are encountered in the data file, 
            they will be inverted and a backslash will be added before them. for example, if tx data
            is XON(0x11) with BackSlash_En = '1', then uart will send 5Ch(Backslash) + EEh (~XON).
        </comment>
    </bits>    
    
    <bits access="rw" name="Tx Finish n Wait" pos="19" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>

    <bits access="rw" name="Divisor Mode" pos="20" rst="0">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 4)<br />1 = (BCLK = SCLK / 16) <br /> This bit will be
      masked to '0' if debug host is enabled.</comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). <br /> This bit will be
      masked to '0' if debug host is enabled. </comment>
    </bits>

    <bits access="rw" name="Rx RTS" pos="22" rst="0">
      <comment>Controls the Uart_RTS output (not directly in auto flow control
      mode).<br />0 = the Uart_RTS will be inactive high<br />1 = the Uart_RTS
      will be active low <br /> This bit will be masked to '1' if debug host is
      enabled. </comment>
      <options>
        <option name="INACTIVE" value="0" />
        <option name="ACTIVE"  value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>       
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. <br/> 
          In case HW flow control (both swTx_Flow_ctrl=0 and swRx_Flow_Ctrl=0),
          If Auto_Flow_Control is enabled, Uart_RTS is controlled by the Rx RTS bit in 
          CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). 
          Tx data flow is stopped If Uart_CTS become inactive high.<br/>
          If Auto_Flow_Control is disabled, Uart_RTS is controlled only by the Rx RTS
          bit in CMD_Set register. Uart_CTS will not take effect. <br/><br/>

          In case SW flow control(either swTx_Flow_ctrl/=0 or swRx_Flow_Ctrl/=0),
          If Auto_Flow_Control is enabled, XON/XOFF will be controlled by the Rx RTS bit
          in CMD_Set register and the UART Auto Control Flow System(flow controlled by Rx
          Fifo Level and AFC_Level in Triggers register). <br/>
          If Auto_Flow_Control is disabled, XON/XOFF will be controlled only by Rx RTS bit
          in CMD_Set register. Tx data flow will be stoped when XOFF is received either
          this bit is enable or disabled.<br/>
          <br /> This bit will be masked to '1' if debug host is enabled.
      </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. <br /> This bit 
      will be masked to '0' if debug host is enabled. </comment>
      <options>
        <option name="DISABLE" value="0" />
        <option name="ENABLE" value="1" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="HST TXD oen" pos="26" rst="0">
      <comment>HST TXD output enable. '0' enable.</comment>
      <options>
        <option name="DISABLE" value="1" />
        <option name="ENABLE" value="0" />
        <default />
      </options>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. <br /> This bit will be masked
      to "1011" if debug host is enabled. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="4:0" rst="0">
        <options>
            <mask/>
            <shift/>
        </options>
    <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo Level" pos="12:8" rst="0">
         <options>
            <mask/>
            <shift/>
        </options>
      <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent. </comment>
    </bits>

    <bits access="r" name="Tx Active" pos="13" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="Tx DCTS" pos="24" rst="0">
      <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0), 
            This bit is set when the Uart_CTS line changed since the last
            time this register has been written. <br/>
            In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0), 
            This bit is set when received XON/XOFF status changed since the last time
            this register has been writtern. <br/>
            This bit is cleared when the UART_STATUS register is written with any value. 
       </comment>
    </bits>

    <bits access="r" name="Tx CTS" pos="25" rst="0">
        <comment>In case HW flow ctrl(both swRx_Flow_Ctrl=0 and swTx_Flow_Ctrl=0),
            current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
            <br/>In case SW flow ctrl(either swRx_Flow_Ctrl/=0 or swTx_Flow_Ctrl/=0),
            current state of software flow control.
            <br/> '1' = when XOFF received. 
            <br/> '0' = when XON received. 
        </comment>
    </bits>

    <bits access="r" name="Tx Fifo Rsted L" pos="28" rst="0">
      <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.      
      </comment>
    </bits>

    <bits access="r" name="Rx Fifo Rsted L" pos="29" rst="0">
      <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Enable n finished" pos="30" rst="0">
      <comment>This bit is set when bit enable is changed from '0' to '1' or 
      from '1' to '0', it is cleared when the enable process has finished.      
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
        <comment>Clear to send signal change or XON/XOFF detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
      <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
        </bits>

    <bits access="rw" name="XOFF_detected" pos="8" rst="0">
    </bits>
    
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>

    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="3:0" rst="0">
      <comment>Defines the threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="7:4" rst="0">
      <comment>Defines the threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="11:8" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>
  <reg protect="rw" name="XChar">
    <bits access="rw" name="XON1" pos="7:0" rst="17">
        <comment>XON1 character value. Reset Value is CTRL-Q 0x11.</comment>
    </bits>
    <bits access="rw" name="XOFF1" pos="15:8" rst="19">
        <comment>XOFF1 character value. Reset Value is CTRL-S 0x13</comment>
    </bits>
    <bits access="rw" name="XON2" pos="23:16" rst="0">
        <comment>XON2 character value. </comment>
    </bits>
    <bits access="rw" name="XOFF2" pos="31:24" rst="0">
        <comment>XOFF2 character value. </comment>
    </bits>
    <comment> These characters must respect following constraints: They must be different if used in software control, if BackSlash_En='1', they cannot be '\' and they cannot be complementary to each other, for example neither XON1 = ~XOFF1 nor XON1 = ~'\' is permitted. </comment>
  </reg>
  
</module>
</archive>

<archive relative="dfe.xml">
  <module name="dfe" category="rf_dig">
    <reg protect="rw" name="general_mode">
      <bits access="rw" name="lvds2dfe_data_dump_en" pos="15" rst="0">
        <comment>
          enable for lvds2dfe_data dump when dfe_dump_sel is 4
        </comment>
      </bits>
      <bits access="rw" name="dfe_dump_sel" pos="14:11" rst="0">
        <comment>
          Dump source selection.
0: dump RX data from DFE
1: dump TX data from BB
2: dump DFE internal RX path data. It works with rxdp_test_dac_sel_rg register 
3: dump DFE internal TX path data. It works with txdp_test_dac_sel_rg register
4: dump all 32-bits of lvds2dfe_data, work with lvds2dfe_data_dump_en register
5: dump part of lvds2dfe_data, used when adc-dfe-lvds-bb or bb-lvds-dfe-dac
6: dump FIFO A output for LVDS
7: dump FIFO B output for LVDS
8: dump FIFO C output for LVDS
9: dump FIFO D output for LVDS
        </comment>
      </bits>
      <bits access="rw" name="rxtx_switch" pos="10" rst="0">
        <comment>
          RX/TX work mode in DFE:
0: RX
1: TX
        </comment>
      </bits>
      <bits access="rw" name="resetn_cgu" pos="9" rst="1">
        <comment>
          Software reset for CGU, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="resetn_txdp" pos="8" rst="0">
        <comment>
          Software reset for TXDP, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="resetn_rxdp" pos="7" rst="0">
        <comment>
          Software reset for RXDP when reset_mode is 1, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="sw_resetn" pos="6" rst="1">
        <comment>
          SW controlled reset for RXDP when reset_mode is 0, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="reset_mode" pos="5" rst="0">
        <comment>
          Reset source for RXDP.
0: reset from BB TCU event signal with precise timing control
1: reset from register resetn_rxdp
        </comment>
      </bits>
      <bits access="rw" name="clk_fbc_en_mode" pos="4" rst="0">
        <comment>
          PolarIQ mode enable for NB/WT TX
0: PolarIQ disabled
1: PolarIQ enabled
        </comment>
      </bits>
      <bits access="rw" name="tx_mode" pos="3:2" rst="0">
        <comment>
          DFE TX mode.
0: GGE mode
1: NB mode
2: WT mode
        </comment>
      </bits>
      <bits access="rw" name="rx_mode" pos="1:0" rst="0">
        <comment>
          DFE RX mode.
0: GGE mode
1: NB mode
2: WT mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clock_ctrl">
      <bits access="r" name="clock_ctrl_reserved_0" pos="15" rst="0">
      </bits>
      <bits access="rw" name="en_clk_nb230_wrapper" pos="14" rst="0">
        <comment>
          clock enable for NB230 interface wrapper
        </comment>
      </bits>
      <bits access="rw" name="sel_clk_nb230_wrapper" pos="13" rst="0">
        <comment>
          clock select for NB230 interface wrapper
0: NBPLL clock, depend on sel_clk_nb
1: LVDS clock, depend on sel_lvds2dfe_clk
        </comment>
      </bits>
      <bits access="rw" name="sel_clk_nb" pos="12" rst="0">
        <comment>
          clock select for BB NB or NB230.
0: 61.44MHz
1: 122.88MHz
        </comment>
      </bits>
      <bits access="rw" name="sel_clk_61p44m_bb" pos="11" rst="0">
        <comment>
          clock select for BB NB or NB230 or dump.
0: 61.44MHz or 122.88MHz for normal function, depend on sel_clk_nb
1: 52MHz for dump
        </comment>
      </bits>
      <bits access="rw" name="reg_clkgate_en" pos="10" rst="0">
        <comment>
          0: registers module clk gating enabled; 1: registers module clk always on
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_inv_mode" pos="9" rst="0">
        <comment>
          Invert DAC clock or not.
0: clk_dac is not inverted
1: clk_dac is inverted
        </comment>
      </bits>
      <bits access="rw" name="clk_adc_inv_mode" pos="8" rst="0">
        <comment>
          Invert ADC clock or not.
0: clk_adc is not inverted
1: clk_adc is inverted
        </comment>
      </bits>
      <bits access="rw" name="clk_rate_convert_rg" pos="7" rst="0">
        <comment>
          DFE clock shift control.
0: clock shift disabled
1: clock shift enabled. When it is enabled, all DFE clocks except GSM TX clock are working in 17/16 normal frequency
        </comment>
      </bits>
      <bits access="rw" name="clk_26m_en" pos="6" rst="1">
        <comment>
          clock enable for BB GGE 26MHz
        </comment>
      </bits>
      <bits access="rw" name="clk_61p44m_en" pos="5" rst="1">
        <comment>
          clock enable for BB NB/WT 61.44MHz
        </comment>
      </bits>
      <bits access="rw" name="txdp_nb_dfe_clk_en" pos="4" rst="0">
        <comment>
          clock enable for DFE NB/WT TX
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_dfe_clk_en" pos="3" rst="0">
        <comment>
          clock enable for DFE GSM TX
        </comment>
      </bits>
      <bits access="rw" name="rxdp_dfe_clk_en" pos="2" rst="0">
        <comment>
          clock enable for DFE RX
        </comment>
      </bits>
      <bits access="rw" name="txdp_clk_dac_en" pos="1" rst="0">
        <comment>
          clock enable for DFE DAC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_adc_clk_en" pos="0" rst="0">
        <comment>
          clock enable for DFE ADC.
0: clock disabled
1: clock enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dcc">
      <bits access="r" name="rxdp_dcc_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_dcc_load" pos="6" rst="0">
        <comment>
          Start to load DC value, active high. Before next load, set it low firstly
        </comment>
      </bits>
      <bits access="rw" name="dcc_imgrej_rg" pos="5" rst="0">
        <comment>
          IQ swap in DC module
0: no swap
1. swap
        </comment>
      </bits>
      <bits access="rw" name="dcc_hold_en_rg" pos="4" rst="0">
        <comment>
          Hold DC accumulator calculation in DC calibration mode
        </comment>
      </bits>
      <bits access="rw" name="dcc_bypass_rg" pos="3" rst="0">
        <comment>
          This register is not used. But DC module bypass is actrually controlled by register rxdp_bypass_dcc and rxdp_bypass_mode_dcc
        </comment>
      </bits>
      <bits access="rw" name="dcc_dc_delta_ld_st_rg" pos="2" rst="0">
        <comment>
          Store initial value to DC accumulator at positive edge in DC cancel mode or DC calibration mode.
        </comment>
      </bits>
      <bits access="rw" name="dcc_dc_calib_en_rg" pos="1" rst="0">
        <comment>
          Load DC value in calibration mode to debug port, only used for debug purpose
        </comment>
      </bits>
      <bits access="rw" name="dcc_rx_calib_sel_rg" pos="0" rst="0">
        <comment>
          DC module work mode.
0: DC calibration mode
1: DC cancel mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_calib_re">
      <bits access="rw" name="rxdp_dc_calib_re_rg" pos="15:0" rst="0">
        <comment>
          DC real part value used in cancel mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_calib_im">
      <bits access="rw" name="rxdp_dc_calib_im_rg" pos="15:0" rst="0">
        <comment>
          DC image part value used in cancel mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_delta_re">
      <bits access="rw" name="rxdp_dc_delta_re_rg" pos="15:0" rst="0">
        <comment>
          Accumulator initial real part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_delta_im">
      <bits access="rw" name="rxdp_dc_delta_im_rg" pos="15:0" rst="0">
        <comment>
          Accumulator initial image part value, which is strored at positive edge of dcc_dc_delta_ld_st_rg register
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_dc_cr">
      <bits access="r" name="rxdp_dc_cr_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="conv_slow_bw_ct_rg" pos="11:9" rst="0">
        <comment>
          Slow convergence control, work with conv_mode_ct_rg register
        </comment>
      </bits>
      <bits access="rw" name="conv_fast_bw_ct_rg" pos="8:6" rst="0">
        <comment>
          Fast convergence control, work with conv_mode_ct_rg register
        </comment>
      </bits>
      <bits access="rw" name="conv_tmr_ct_rg" pos="5:2" rst="0">
        <comment>
          Duration time of DC calibration, which is based on sample unit
        </comment>
      </bits>
      <bits access="rw" name="conv_mode_ct_rg" pos="1:0" rst="0">
        <comment>
          DC convergence loop mode selection.
0: fast
1: slow
2: fast-&gt;slow
3: fast-&gt;hold
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gain_ct_reg">
      <bits access="r" name="rxdp_gain_ct_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct_load" pos="13" rst="0">
        <comment>
          load rxdp_gain_ct to DFE. Write it to 1b'0 before assert it
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gain_ct_load_bypass" pos="12" rst="1">
        <comment>
          bypass rxdp_gain_ct_load
        </comment>
      </bits>
      <bits access="r" name="rxdp_gain_ct_reg_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct" pos="9:0" rst="0">
        <comment>
          Gain BB control. [-24db, 57.875db], step=0.125db
        </comment>
      </bits>
    </reg>
    <hole size="160"/>
    <reg protect="rw" name="rxdp_gdeq_coef0_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef0_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef0_rg_2">
      <bits access="r" name="rxdp_gdeq_coef0_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef0_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef1_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef1_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef1_rg_2">
      <bits access="r" name="rxdp_gdeq_coef1_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef1_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef2_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef2_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef2_rg_2">
      <bits access="r" name="rxdp_gdeq_coef2_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef2_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef3_rg_1">
      <bits access="rw" name="rxdp_gdeq_coef3_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_coef3_rg_2">
      <bits access="r" name="rxdp_gdeq_coef3_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_coef3_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of RX group delay coefficient 2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gdeq_bypass">
      <bits access="r" name="rxdp_gdeq_bypass_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_zf_if_sel" pos="1" rst="0">
        <comment>
          RF data type.
0: IF
1: ZF
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gdeq_bp_lp_sel" pos="0" rst="0">
        <comment>
          RF filter type.
0: BP
1: LP
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rxdp_adc_wr_buf_fifo">
      <bits access="r" name="rxdp_adc_wr_buf_fifo_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_adc_smp_rate_rg" pos="11:7" rst="0">
        <comment>
          Read rate of DFE ADC FIFO, which depends on RX mode.
5'h00: GGE
5'h01: NB/WT
        </comment>
      </bits>
      <bits access="r" name="rxdp_adc_wr_buf_fifo_reserved_1" pos="6" rst="0">
      </bits>
      <bits access="r" name="rxdp_adc_wr_buf_fifo_reserved_2" pos="5:1" rst="0">
      </bits>
      <bits access="rw" name="rxdp_adc_wr_en_rg" pos="0" rst="1">
        <comment>
          Write enable of DFE ADC FIFO, active high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxdp_dcc_valid_o_reg">
      <bits access="r" name="rxdp_dcc_valid_o_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rxdp_dcc_val_reg" pos="0" rst="0">
        <comment>
          Valid indication of DC value after assert rxdp_dcc_load to avoid metastability. rxdp_dcc_re_o and rxdp_dcc_im_o are stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxdp_dcc_re_o_reg">
      <bits access="r" name="rxdp_dcc_re_o" pos="15:0" rst="0">
        <comment>
          Real part of DC value, it is stable when rxdp_dcc_val_reg is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rxdp_dcc_im_o_reg">
      <bits access="r" name="rxdp_dcc_im_o" pos="15:0" rst="0">
        <comment>
          Image part of DC value, it is stable when rxdp_dcc_val_reg is high
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="rxdp_notch_ct">
      <bits access="r" name="rxdp_notch_ct_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_dataen0" pos="0" rst="1">
        <comment>
          Data enable of Notch DC
0: disable
1: enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch_a0_i_reg">
      <bits access="r" name="rxdp_notch_a0_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_a0_i" pos="11:0" rst="0">
        <comment>
          Coefficient a for real part of Notch DC
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch_a0_q_reg">
      <bits access="r" name="rxdp_notch_a0_q_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_a0_q" pos="11:0" rst="0">
        <comment>
          Coefficient a for image part of Notch DC
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="rxdp_notch_k_reg">
      <bits access="r" name="rxdp_notch_k_reg_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch_k0" pos="3:0" rst="0">
        <comment>
          Coefficient k of Notch DC
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_ct">
      <bits access="r" name="rxdp_notch2_ct_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_dataen0" pos="1" rst="1">
        <comment>
          Data enable of Notch H 1st core
0: disable
1: enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_dataen1" pos="0" rst="1">
        <comment>
          Data enable of Notch H 2nd core
0: disable
1: enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a0_i_reg">
      <bits access="r" name="rxdp_notch2_a0_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a0_i" pos="11:0" rst="0">
        <comment>
          Coefficient a for real part of Notch H 1st core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a0_q_reg">
      <bits access="r" name="rxdp_notch2_a0_q_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a0_q" pos="11:0" rst="0">
        <comment>
          Coefficient a for image part of Notch H 1st core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a1_i_reg">
      <bits access="r" name="rxdp_notch2_a1_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a1_i" pos="11:0" rst="0">
        <comment>
          Coefficient a for real part of Notch H 2nd core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_a1_q_reg">
      <bits access="r" name="rxdp_notch2_a1_q_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_a1_q" pos="11:0" rst="0">
        <comment>
          Coefficient a for image part of Notch H 2nd core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_notch2_k_reg">
      <bits access="r" name="rxdp_notch2_k_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_k0" pos="7:4" rst="0">
        <comment>
          Coefficient k of Notch H 1st core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_notch2_k1" pos="3:0" rst="0">
        <comment>
          Coefficient k of Notch H 2nd core
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef0_reg">
      <bits access="rw" name="rxdp_aci_fir_coef0" pos="15:0" rst="0">
        <comment>
          Coefficient COEF0 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef1_reg">
      <bits access="rw" name="rxdp_aci_fir_coef1" pos="15:0" rst="0">
        <comment>
          Coefficient COEF1 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef2_reg">
      <bits access="rw" name="rxdp_aci_fir_coef2" pos="15:0" rst="0">
        <comment>
          Coefficient COEF2 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef3_reg">
      <bits access="rw" name="rxdp_aci_fir_coef3" pos="15:0" rst="0">
        <comment>
          Coefficient COEF3 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef4_reg">
      <bits access="rw" name="rxdp_aci_fir_coef4" pos="15:0" rst="0">
        <comment>
          Coefficient COEF4 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef5_reg">
      <bits access="rw" name="rxdp_aci_fir_coef5" pos="15:0" rst="0">
        <comment>
          Coefficient COEF5 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef6_reg">
      <bits access="rw" name="rxdp_aci_fir_coef6" pos="15:0" rst="0">
        <comment>
          Coefficient COEF6 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef7_reg">
      <bits access="rw" name="rxdp_aci_fir_coef7" pos="15:0" rst="0">
        <comment>
          Coefficient COEF7 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef8_reg">
      <bits access="rw" name="rxdp_aci_fir_coef8" pos="15:0" rst="0">
        <comment>
          Coefficient COEF8 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef9_reg">
      <bits access="rw" name="rxdp_aci_fir_coef9" pos="15:0" rst="0">
        <comment>
          Coefficient COEF9 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef10_reg">
      <bits access="rw" name="rxdp_aci_fir_coef10" pos="15:0" rst="0">
        <comment>
          Coefficient COEF10 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef11_reg">
      <bits access="rw" name="rxdp_aci_fir_coef11" pos="15:0" rst="0">
        <comment>
          Coefficient COEF11 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef12_reg">
      <bits access="rw" name="rxdp_aci_fir_coef12" pos="15:0" rst="0">
        <comment>
          Coefficient COEF12 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef13_reg">
      <bits access="rw" name="rxdp_aci_fir_coef13" pos="15:0" rst="0">
        <comment>
          Coefficient COEF13 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef14_reg">
      <bits access="rw" name="rxdp_aci_fir_coef14" pos="15:0" rst="0">
        <comment>
          Coefficient COEF14 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef15_reg">
      <bits access="rw" name="rxdp_aci_fir_coef15" pos="15:0" rst="0">
        <comment>
          Coefficient COEF15 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef16_reg">
      <bits access="rw" name="rxdp_aci_fir_coef16" pos="15:0" rst="0">
        <comment>
          Coefficient COEF16 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef17_reg">
      <bits access="rw" name="rxdp_aci_fir_coef17" pos="15:0" rst="0">
        <comment>
          Coefficient COEF17 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef18_reg">
      <bits access="rw" name="rxdp_aci_fir_coef18" pos="15:0" rst="0">
        <comment>
          Coefficient COEF18 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef19_reg">
      <bits access="rw" name="rxdp_aci_fir_coef19" pos="15:0" rst="0">
        <comment>
          Coefficient COEF19 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef20_reg">
      <bits access="rw" name="rxdp_aci_fir_coef20" pos="15:0" rst="0">
        <comment>
          Coefficient COEF20 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef21_reg">
      <bits access="rw" name="rxdp_aci_fir_coef21" pos="15:0" rst="0">
        <comment>
          Coefficient COEF21 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef22_reg">
      <bits access="rw" name="rxdp_aci_fir_coef22" pos="15:0" rst="0">
        <comment>
          Coefficient COEF22 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_aci_filter_coef23_reg">
      <bits access="rw" name="rxdp_aci_fir_coef23" pos="15:0" rst="0">
        <comment>
          Coefficient COEF23 of ACI filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_mixer_freq_in_reg0">
      <bits access="rw" name="rxdp_mixer_freq_p0" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of frequency offset for Mixer
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_mixer_freq_in_reg1">
      <bits access="r" name="rxdp_mixer_freq_in_reg1_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="rxdp_mixer_freq_p1" pos="7:0" rst="0">
        <comment>
          Bit [23:16] of frequency offset for Mixer
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_rssi_reg">
      <bits access="r" name="rxdp_rssi_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ob_enable" pos="7" rst="0">
        <comment>
          Outband RSSI enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ib_enable" pos="6" rst="0">
        <comment>
          Inband RSSI enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ob_ushift" pos="5:3" rst="0">
        <comment>
          Outband RSSI ushift value
        </comment>
      </bits>
      <bits access="rw" name="rxdp_rssi_ib_ushift" pos="2:0" rst="0">
        <comment>
          Inband RSSI ushift value
        </comment>
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="rw" name="rxdpdecimatefordigrf">
      <bits access="r" name="rxdpdecimatefordigrf_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_deci_gge_delay_rg" pos="11:4" rst="0">
        <comment>
          delay count to discard some initial samples
        </comment>
      </bits>
      <bits access="rw" name="rxdp_deci_gge_deci_select" pos="3:1" rst="0">
        <comment>
          sample select in 12x data rate for GGE mode
        </comment>
      </bits>
      <bits access="rw" name="rxdp_deci_gge_sample_mode" pos="0" rst="0">
        <comment>
          sample number per symbol for GGE mode
0: 541K, 2x
1: 1.08M, 4x
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdpmt_param">
      <bits access="r" name="rxdpmt_param_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_deci_wt_deci_select" pos="9:6" rst="0">
        <comment>
          sample select in 192K data rate for WT mode
        </comment>
      </bits>
      <bits access="rw" name="rxdp_deci_wt_sample_mode" pos="5:2" rst="0">
        <comment>
          0: 192K
1: 96K=192K/2
2: 64K=192K/3
....
15: 12K=192K/16
        </comment>
      </bits>
      <bits access="rw" name="rxdp_cic2_mode" pos="1:0" rst="0">
        <comment>
          select data rate for CIC2 module used by WT mode
0: mode0, CIC2 decimated by 40, i.e., from 3.84M to 96K
1: mode1, CIC2 decimated by 20, i.e., from 3.84M to 192K
2/3: mode2,  CIC2 decimated by 10, i.e., from 3.84M to 384K
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_gain_ct_rf_reg">
      <bits access="r" name="rxdp_gain_ct_rf_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct_rf_load" pos="13" rst="0">
        <comment>
          load rxdp_gain_ct_rf to DFE. Write it to 1b'0 before assert it
        </comment>
      </bits>
      <bits access="rw" name="rxdp_gain_ct_rf_load_bypass" pos="12" rst="1">
        <comment>
          bypass rxdp_gain_ct_rf_load
        </comment>
      </bits>
      <bits access="r" name="rxdp_gain_ct_rf_reg_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain_ct_rf" pos="9:0" rst="0">
        <comment>
          Gain RF control. [-24db, 57.875db], step=0.125db
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="start_max_min_ib_rssi_reg">
      <bits access="r" name="start_max_min_ib_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="start_max_min_ib_rssi" pos="0" rst="0">
        <comment>
          start inband RSSI max and min measurement
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16lsb_ib_rssi_reg">
      <bits access="rw" name="count_16lsb_ib_rssi" pos="15:0" rst="30720">
        <comment>
          timer count [15:0] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16msb_ib_rssi_reg">
      <bits access="rw" name="count_16msb_ib_rssi" pos="15:0" rst="0">
        <comment>
          timer count [31:16] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_max_min_ib_rssi_reg">
      <bits access="r" name="load_max_min_ib_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_max_min_ib_rssi" pos="0" rst="0">
        <comment>
          start to load max and min measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_min_val_ib_rssi">
      <bits access="r" name="rssi_max_min_val_ib_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_min_val_reg_ib_rssi" pos="0" rst="0">
        <comment>
          valid indication of max and min measurement report after assert load_max_min_ib_rssi to avoid metastability. rssi_min_reg_ib_rssi and rssi_max_reg_ib_rssi are stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_min_ib_rssi">
      <bits access="r" name="rssi_min_ib_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_min_reg_ib_rssi" pos="9:0" rst="0">
        <comment>
          inband RSSI min value, it is stable when rssi_max_min_val_reg_ib_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_ib_rssi">
      <bits access="r" name="rssi_max_ib_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_reg_ib_rssi" pos="9:0" rst="0">
        <comment>
          inband RSSI max value, it is stable when rssi_max_min_val_reg_ib_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="int_ib_rssi">
      <bits access="r" name="int_ib_rssi_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_int_ib_rssi" pos="2" rst="0">
        <comment>
          interrupt status to be able to start to load max and min measurement report
        </comment>
      </bits>
      <bits access="rw" name="int_mask_ib_rssi" pos="1" rst="0">
        <comment>
          interrupt mask
        </comment>
      </bits>
      <bits access="rw" name="int_clear_ib_rssi" pos="0" rst="0">
        <comment>
          interrupt clear
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_ib_rssi_reg">
      <bits access="r" name="load_ib_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_ib_rssi" pos="0" rst="0">
        <comment>
          start to load instant measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_val_ib_rssi">
      <bits access="r" name="rssi_val_ib_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_val_reg_ib_rssi" pos="0" rst="0">
        <comment>
          valid indication of instant measurement report after assert load_ib_rssi to avoid metastability. rssi_reg_ib_rssi is stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_ib_rssi">
      <bits access="r" name="rssi_ib_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_ib_rssi" pos="9:0" rst="0">
        <comment>
          inband RSSI instant value, it is stable when rssi_val_reg_ib_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="start_max_min_ob_rssi_reg">
      <bits access="r" name="start_max_min_ob_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="start_max_min_ob_rssi" pos="0" rst="0">
        <comment>
          start outband RSSI max and min measurement
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16lsb_ob_rssi_reg">
      <bits access="rw" name="count_16lsb_ob_rssi" pos="15:0" rst="30720">
        <comment>
          timer count [15:0] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="count_16msb_ob_rssi_reg">
      <bits access="rw" name="count_16msb_ob_rssi" pos="15:0" rst="0">
        <comment>
          timer count [31:16] for max and min measurement report after start
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_max_min_ob_rssi_reg">
      <bits access="r" name="load_max_min_ob_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_max_min_ob_rssi" pos="0" rst="0">
        <comment>
          start to load max and min measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_min_val_ob_rssi">
      <bits access="r" name="rssi_max_min_val_ob_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_min_val_reg_ob_rssi" pos="0" rst="0">
        <comment>
          valid indication of max and min measurement report after assert load_max_min_ob_rssi to avoid metastability. rssi_min_reg_ob_rssi and rssi_max_reg_ob_rssi are stable when this register is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_min_ob_rssi">
      <bits access="r" name="rssi_min_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_min_reg_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI min value, it is stable when rssi_max_min_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_max_ob_rssi">
      <bits access="r" name="rssi_max_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_max_reg_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI max value, it is stable when rssi_max_min_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="int_ob_rssi">
      <bits access="r" name="int_ob_rssi_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_int_ob_rssi" pos="2" rst="0">
        <comment>
          interrupt status to be able to start to load max and min measurement report
        </comment>
      </bits>
      <bits access="rw" name="int_mask_ob_rssi" pos="1" rst="0">
        <comment>
          interrupt mask
        </comment>
      </bits>
      <bits access="rw" name="int_clear_ob_rssi" pos="0" rst="0">
        <comment>
          interrupt clear
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="load_ob_rssi_reg">
      <bits access="r" name="load_ob_rssi_reg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="load_ob_rssi" pos="0" rst="0">
        <comment>
          start to load instant measurement report. Before next load, set it low firstly
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_val_ob_rssi">
      <bits access="r" name="rssi_val_ob_rssi_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_val_reg_ob_rssi" pos="0" rst="0">
        <comment>
          valid indication of instant measurement report after assert load_ob_rssi to avoid metastability
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_wd_ob_rssi">
      <bits access="r" name="rssi_wd_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_wd_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI instant value for WB, it is stable when rssi_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_up_ob_rssi">
      <bits access="r" name="rssi_up_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_up_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI instant value for UP, it is stable when rssi_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rssi_dn_ob_rssi">
      <bits access="r" name="rssi_dn_ob_rssi_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="rssi_reg_dn_ob_rssi" pos="9:0" rst="0">
        <comment>
          outband RSSI instant value for DN, it is stable when rssi_val_reg_ob_rssi is high
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="digrf_rx_ctrl_reg">
      <bits access="r" name="digrf_rx_ctrl_reg_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="digrf_rx_rx_en_delay_counter" pos="6:3" rst="0">
        <comment>
          delay counter for rx_en
        </comment>
      </bits>
      <bits access="rw" name="digrf_rx_rx_iq_order" pos="2" rst="0">
        <comment>
          RX IQ swap
        </comment>
      </bits>
      <bits access="rw" name="digrf_rx_rxclk_polarity" pos="1" rst="0">
        <comment>
          RX clock invert or not
        </comment>
      </bits>
      <bits access="rw" name="digrf_rx_digrf_enable" pos="0" rst="1">
        <comment>
          enable digrf RX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="digrf_tx_ctrl_reg">
      <bits access="rw" name="digrf_tx_txdata_out_timer" pos="15:8" rst="0">
        <comment>
          delay counter for tx_data
        </comment>
      </bits>
      <bits access="r" name="digrf_tx_ctrl_reg_reserved_0" pos="7:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="digrf_tx_txclk_polarity" pos="1" rst="0">
        <comment>
          TX clock invert or not
        </comment>
      </bits>
      <bits access="rw" name="digrf_tx_digrf_stream_mode_enable" pos="0" rst="1">
        <comment>
          TX mode.
0: block mode
1: stream mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_bypass_control_reg1">
      <bits access="r" name="rxdp_bypass_control_reg1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_uphb1" pos="13" rst="0">
        <comment>
          Interp. HBF1
0: SW bypass disable
1: SW bypass enable
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_gainbb" pos="12" rst="0">
        <comment>
          Gain_BB
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_notch2_2" pos="11" rst="0">
        <comment>
          Notrch(H) 2nd core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_notch2_1" pos="10" rst="0">
        <comment>
          Notrch(H) 1st core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_dnbh1" pos="9" rst="0">
        <comment>
          Deci. HBF1
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_aci_lpf" pos="8" rst="0">
        <comment>
          ACI Filter
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_gainrf" pos="7" rst="0">
        <comment>
          Gain_RF
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_gdeq" pos="6" rst="0">
        <comment>
          Group Delay Equ
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_notch1_1" pos="5" rst="0">
        <comment>
          Notch(DC)
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mixer" pos="4" rst="0">
        <comment>
          Mixer
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_rc" pos="3" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_cic2" pos="2" rst="0">
        <comment>
          Deci.CIC2
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_dcc" pos="1" rst="0">
        <comment>
          DC Calib.&amp;Cancel
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_cic1" pos="0" rst="0">
        <comment>
          Deci.CIC1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_bypass_control_reg2">
      <bits access="r" name="rxdp_bypass_control_reg2_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_deci_digrf" pos="2" rst="0">
        <comment>
          Downsample
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_uphb3" pos="1" rst="0">
        <comment>
          Interp. HBF3
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_uphb2" pos="0" rst="0">
        <comment>
          Interp. HBF2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_bypass_mode_control_reg1">
      <bits access="r" name="rxdp_bypass_mode_control_reg1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_uphb1" pos="13" rst="0">
        <comment>
          Interp. HBF1
0: bypass controlled by HW. HW bypass module automaticlly based on algorithm requirement
1: bypass controlled by SW. When it is set, rxdp_bypass_uphb1 will be used
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_gainbb" pos="12" rst="0">
        <comment>
          Gain_BB
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_notch2_2" pos="11" rst="0">
        <comment>
          Notrch(H) 2nd core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_notch2_1" pos="10" rst="0">
        <comment>
          Notrch(H) 1st core
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_dnbh1" pos="9" rst="0">
        <comment>
          Deci. HBF1
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_aci_lpf" pos="8" rst="0">
        <comment>
          ACI Filter
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_gainrf" pos="7" rst="0">
        <comment>
          Gain_RF
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_gdeq" pos="6" rst="0">
        <comment>
          Group Delay Equ
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_notch1_1" pos="5" rst="0">
        <comment>
          Notch(DC)
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_mixer" pos="4" rst="0">
        <comment>
          Mixer
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_rc" pos="3" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_cic2" pos="2" rst="0">
        <comment>
          Deci.CIC2
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_dcc" pos="1" rst="0">
        <comment>
          DC Calib.&amp;Cancel
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_cic1" pos="0" rst="0">
        <comment>
          Deci.CIC1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_bypass_mode_control_reg2">
      <bits access="r" name="rxdp_bypass_mode_control_reg2_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_deci_digrf" pos="2" rst="0">
        <comment>
          Downsample
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_uphb3" pos="1" rst="0">
        <comment>
          Interp. HBF3
        </comment>
      </bits>
      <bits access="rw" name="rxdp_bypass_mode_uphb2" pos="0" rst="0">
        <comment>
          Interp. HBF2
        </comment>
      </bits>
    </reg>
    <hole size="768"/>
    <reg protect="rw" name="txdp_gsm_a1">
      <bits access="r" name="txdp_gsm_a1_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_a1_rg" pos="11:0" rst="0">
        <comment>
          Coefficient a1 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_a2">
      <bits access="r" name="txdp_gsm_a2_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_a2_rg" pos="11:0" rst="0">
        <comment>
          Coefficient a2 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_b1">
      <bits access="r" name="txdp_gsm_b1_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_b1_rg" pos="11:0" rst="0">
        <comment>
          Coefficient b1 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_b2">
      <bits access="r" name="txdp_gsm_b2_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_b2_rg" pos="11:0" rst="0">
        <comment>
          Coefficient b2 for PLL Equ.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_g">
      <bits access="rw" name="txdp_gsm_g_rg" pos="15:0" rst="0">
        <comment>
          Bit [27:12] of gain for PLL Equ. It is valid when AFC adjustment is being enabled
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_equ_bypass_reg">
      <bits access="r" name="txdp_gsm_equ_bypass_reg_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="txdp_gsm_g_load_bypass" pos="1" rst="1">
        <comment>
          Bypass load_g:
0: disable bypass
1: enable bypass
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_equ_bypass" pos="0" rst="1">
        <comment>
          Bypass PLL Equ.
0: disable bypass
1: enable bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_equ_tx_shift_ct">
      <bits access="r" name="txdp_gsm_equ_tx_shift_ct_reserved_0" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_form_lsb_acc_en" pos="4" rst="0">
        <comment>
          4 LSB control
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_equ_tx_shift_ct_rg" pos="3:0" rst="0">
        <comment>
          Former output shift control
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="txdp_gsm_offset_value0_reg">
      <bits access="r" name="txdp_gsm_offset_value0_reg_reserved_0" pos="15:0" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="txdp_gsm_offset_value1_reg">
      <bits access="r" name="txdp_gsm_offset_value1_reg_reserved_0" pos="15:0" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_tx_rx">
      <bits access="r" name="txdp_gsm_tx_rx_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_freq_rg2" pos="3:1" rst="0">
        <comment>
          Bit [34:32] for GSM TX frequency
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_tx_rx_rg" pos="0" rst="1">
        <comment>
          use former output or not
0: RX don't use
1: TX use
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_freq0">
      <bits access="rw" name="txdp_gsm_freq_rg0" pos="15:0" rst="25200">
        <comment>
          Bit [15:0] for GSM TX frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_freq1">
      <bits access="rw" name="txdp_gsm_freq_rg1" pos="15:0" rst="37415">
        <comment>
          Bit [31:16] for GSM TX frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_freq_tx_offset">
      <bits access="rw" name="txdp_gsm_freq_tx_offset_rg" pos="15:0" rst="0">
        <comment>
          Offset add to GSM TX frequency
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="txdp_gsm_sdmpre_ct">
      <bits access="r" name="txdp_gsm_sdmpre_ct_reserved_0" pos="15:1" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_form_bypass" pos="0" rst="0">
        <comment>
          GSM TX frequency control.
0: modulation signal act on GSM TX freqency
1: GSM TX freqency is fixed
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_misc_reg">
      <bits access="r" name="txdp_gsm_misc_reg_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_freq_load_bypass_rg" pos="3" rst="0">
        <comment>
          GSM TX frequency load is at the same time of AFC adjustment or not
0: at the same time
1: not at the same time
        </comment>
      </bits>
      <bits access="rw" name="gsm_tx_fifo_rd_clr_rg" pos="2" rst="0">
        <comment>
          Clear bit for read point of GSM TX FIFO
        </comment>
      </bits>
      <bits access="rw" name="gsm_tx_fifo_wr_clr_rg" pos="1" rst="0">
        <comment>
          Clear bit for write point of GSM TX FIFO
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_pn_en" pos="0" rst="0">
        <comment>
          PN test enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_pn_switch_reg">
      <bits access="r" name="txdp_gsm_pn_switch_reg_reserved_0" pos="15:3" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_pn_switch" pos="2:0" rst="0">
        <comment>
          The mode of pseudo random polynomial
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_encode_en_reg">
      <bits access="r" name="txdp_gsm_encode_en_reg_reserved_0" pos="15:2" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_encode_pos_neg" pos="1" rst="0">
        <comment>
          The initial phase selection of differential encoding
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_encode_en" pos="0" rst="1">
        <comment>
          The differential encoding enable for GSM TX data
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_g_ext_reg">
      <bits access="r" name="txdp_gsm_g_ext_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gsm_g_ext" pos="11:0" rst="0">
        <comment>
          Bit [11:0] of gain for PLL Equ. It works with register txdp_gsm_g_rg
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_nb_ctrl_reg">
      <bits access="r" name="txdp_gsm_nb_ctrl_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_sw_ctrl_rg" pos="7" rst="0">
        <comment>
          enable delay control by software
        </comment>
      </bits>
      <bits access="rw" name="gsm_dly1_data_idx_rg" pos="6:2" rst="0">
        <comment>
          Delay1 index
        </comment>
      </bits>
      <bits access="rw" name="gsm_dly2_data_idx_rg" pos="1:0" rst="0">
        <comment>
          Delay2 index
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff1_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff1_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff1_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff1_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff1_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff2_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff2_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff2_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff2_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff2_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff3_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff3_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff3_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff3_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff3_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff4_reg_l">
      <bits access="rw" name="gsm_grp_dly_coff4_rg_l" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of gsm_grp_dly_coff4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gsm_grp_dly_coff4_reg_m">
      <bits access="r" name="txdp_gsm_grp_dly_coff4_reg_m_reserved_0" pos="15:4" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="gsm_grp_dly_coff4_rg_m" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of gsm_grp_dly_coff4
        </comment>
      </bits>
    </reg>
    <hole size="1152"/>
    <reg protect="rw" name="txdp_wedge_gain_ct_reg">
      <bits access="r" name="txdp_wedge_gain_ct_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="txdp_wedge_gain_ct_load" pos="13" rst="0">
        <comment>
          load txdp_wedge_gain_ct to DFE. Write it to 1b'0 before assert it
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_gain_ct_load_bypass" pos="12" rst="1">
        <comment>
          bypass txdp_wedge_gain_ct_load
        </comment>
      </bits>
      <bits access="r" name="txdp_wedge_gain_ct_reg_reserved_1" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="txdp_wedge_gain_ct" pos="9:0" rst="0">
        <comment>
          Gain control of NB/WT TX. [-24db, 57.875db], step=0.125db
        </comment>
      </bits>
    </reg>
    <hole size="640"/>
    <reg protect="rw" name="txdp_wedge_pm_split_mode_reg">
      <bits access="r" name="txdp_wedge_pm_split_mode_reg_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_flow_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="txdp_wedge_split_mode" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_shrink_reg">
      <bits access="r" name="txdp_wedge_am_shrink_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_shrink" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="txdp_wedge_pm_shift_reg">
      <bits access="r" name="txdp_wedge_pm_shift_reg_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_shift" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p0_reg">
      <bits access="r" name="txdp_wedge_am_p0_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p0" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p1_reg">
      <bits access="r" name="txdp_wedge_am_p1_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p1" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p2_reg">
      <bits access="r" name="txdp_wedge_am_p2_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p2" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p3_reg">
      <bits access="r" name="txdp_wedge_am_p3_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p3" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p4_reg">
      <bits access="r" name="txdp_wedge_am_p4_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p4" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p5_reg">
      <bits access="r" name="txdp_wedge_am_p5_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p5" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p6_reg">
      <bits access="r" name="txdp_wedge_am_p6_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p6" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p7_reg">
      <bits access="r" name="txdp_wedge_am_p7_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p7" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p8_reg">
      <bits access="r" name="txdp_wedge_am_p8_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p8" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p9_reg">
      <bits access="r" name="txdp_wedge_am_p9_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p9" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p10_reg">
      <bits access="r" name="txdp_wedge_am_p10_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p10" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p11_reg">
      <bits access="r" name="txdp_wedge_am_p11_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p11" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p12_reg">
      <bits access="r" name="txdp_wedge_am_p12_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p12" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p13_reg">
      <bits access="r" name="txdp_wedge_am_p13_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p13" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p14_reg">
      <bits access="r" name="txdp_wedge_am_p14_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p14" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p15_reg">
      <bits access="r" name="txdp_wedge_am_p15_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p15" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_am_p16_reg">
      <bits access="r" name="txdp_wedge_am_p16_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_am_p16" pos="9:0" rst="0">
        <comment>
          Amplitude compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p0_reg">
      <bits access="r" name="txdp_wedge_pm_p0_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p0" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p1_reg">
      <bits access="r" name="txdp_wedge_pm_p1_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p1" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p2_reg">
      <bits access="r" name="txdp_wedge_pm_p2_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p2" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p3_reg">
      <bits access="r" name="txdp_wedge_pm_p3_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p3" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p4_reg">
      <bits access="r" name="txdp_wedge_pm_p4_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p4" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p5_reg">
      <bits access="r" name="txdp_wedge_pm_p5_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p5" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p6_reg">
      <bits access="r" name="txdp_wedge_pm_p6_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p6" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p7_reg">
      <bits access="r" name="txdp_wedge_pm_p7_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p7" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p8_reg">
      <bits access="r" name="txdp_wedge_pm_p8_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p8" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p9_reg">
      <bits access="r" name="txdp_wedge_pm_p9_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p9" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p10_reg">
      <bits access="r" name="txdp_wedge_pm_p10_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p10" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p11_reg">
      <bits access="r" name="txdp_wedge_pm_p11_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p11" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p12_reg">
      <bits access="r" name="txdp_wedge_pm_p12_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p12" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p13_reg">
      <bits access="r" name="txdp_wedge_pm_p13_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p13" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p14_reg">
      <bits access="r" name="txdp_wedge_pm_p14_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p14" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p15_reg">
      <bits access="r" name="txdp_wedge_pm_p15_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p15" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_wedge_pm_p16_reg">
      <bits access="r" name="txdp_wedge_pm_p16_reg_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_wedge_pm_p16" pos="9:0" rst="0">
        <comment>
          Phase compensation curve of DPD
        </comment>
      </bits>
    </reg>
    <hole size="192"/>
    <reg protect="rw" name="clk_dac_ctrl">
      <bits access="r" name="clk_dac_ctrl_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_test_mode" pos="6:4" rst="0">
        <comment>
          divide resource of clk_dac when test mode.
000: divide by 1
001: divide by 2
010: divide by 4
011: divide by 8
100: divide by 16
101: divide by 32
110: divide by 64
default: divide by 1
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_test_sel" pos="3:2" rst="0">
        <comment>
          resource of clk_dac when test mode.
00: clk_26m
01: clk_61.44m
10: clk_26m_fbc
11: clk_adc_gge_nb
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_test_en" pos="1" rst="0">
        <comment>
          enable clk_dac when test mode
        </comment>
      </bits>
      <bits access="rw" name="clk_dac_sel" pos="0" rst="0">
        <comment>
          0: clk_dac is from function mode
1: clk_dac is from test mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_delay_reg">
      <bits access="r" name="txdp_delay_reg_reserved_0" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_amp_dly" pos="10:7" rst="12">
        <comment>
          Delay3 index
        </comment>
      </bits>
      <bits access="rw" name="delay4_rg" pos="6:4" rst="0">
        <comment>
          Delay4 index
        </comment>
      </bits>
      <bits access="rw" name="delay5_rg" pos="3" rst="0">
        <comment>
          Delay5 index
        </comment>
      </bits>
      <bits access="rw" name="delay6_rg" pos="2" rst="0">
        <comment>
          Delay6 index
        </comment>
      </bits>
      <bits access="rw" name="delay7_rg" pos="1:0" rst="0">
        <comment>
          Delay7 index
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef0">
      <bits access="r" name="aclr_coef0_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef00" pos="9:0" rst="0">
        <comment>
          Coefficient 0 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef1">
      <bits access="r" name="aclr_coef1_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef01" pos="9:0" rst="0">
        <comment>
          Coefficient 1 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef2">
      <bits access="r" name="aclr_coef2_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef02" pos="9:0" rst="0">
        <comment>
          Coefficient 2 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="aclr_coef3">
      <bits access="r" name="aclr_coef3_reserved_0" pos="15:10" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="aclr_coef03" pos="9:0" rst="0">
        <comment>
          Coefficient 3 of ACLR filter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef0_rg_1">
      <bits access="rw" name="txdp_gdeq_coef0_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 0 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef0_rg_2">
      <bits access="r" name="txdp_gdeq_coef0_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef0_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 0 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef1_rg_1">
      <bits access="rw" name="txdp_gdeq_coef1_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 1 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef1_rg_2">
      <bits access="r" name="txdp_gdeq_coef1_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef1_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 1 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef2_rg_1">
      <bits access="rw" name="txdp_gdeq_coef2_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 2 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef2_rg_2">
      <bits access="r" name="txdp_gdeq_coef2_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef2_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 2 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef3_rg_1">
      <bits access="rw" name="txdp_gdeq_coef3_rg_lo" pos="15:0" rst="0">
        <comment>
          Bit [15:0] of coefficient 3 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_gdeq_coef3_rg_2">
      <bits access="r" name="txdp_gdeq_coef3_rg_2_reserved_0" pos="15:4" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_gdeq_coef3_rg_hi" pos="3:0" rst="0">
        <comment>
          Bit [19:16] of coefficient 3 of group delay equ. for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef00">
      <bits access="r" name="txdp_polariq_fir_coef00_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef0" pos="11:0" rst="0">
        <comment>
          Coefficient 0 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef01">
      <bits access="r" name="txdp_polariq_fir_coef01_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef1" pos="11:0" rst="0">
        <comment>
          Coefficient 1 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef02">
      <bits access="r" name="txdp_polariq_fir_coef02_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef2" pos="11:0" rst="0">
        <comment>
          Coefficient 2 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef03">
      <bits access="r" name="txdp_polariq_fir_coef03_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef3" pos="11:0" rst="0">
        <comment>
          Coefficient 3 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef04">
      <bits access="r" name="txdp_polariq_fir_coef04_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef4" pos="11:0" rst="0">
        <comment>
          Coefficient 4 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef05">
      <bits access="r" name="txdp_polariq_fir_coef05_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef5" pos="11:0" rst="0">
        <comment>
          Coefficient 5 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef06">
      <bits access="r" name="txdp_polariq_fir_coef06_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef6" pos="11:0" rst="0">
        <comment>
          Coefficient 6 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef07">
      <bits access="r" name="txdp_polariq_fir_coef07_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef7" pos="11:0" rst="0">
        <comment>
          Coefficient 7 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef08">
      <bits access="r" name="txdp_polariq_fir_coef08_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef8" pos="11:0" rst="0">
        <comment>
          Coefficient 8 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef09">
      <bits access="r" name="txdp_polariq_fir_coef09_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef9" pos="11:0" rst="0">
        <comment>
          Coefficient 9 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef010">
      <bits access="r" name="txdp_polariq_fir_coef010_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef10" pos="11:0" rst="0">
        <comment>
          Coefficient 10 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_polariq_fir_coef011">
      <bits access="r" name="txdp_polariq_fir_coef011_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_polariq_fir_coef11" pos="11:0" rst="0">
        <comment>
          Coefficient 11 of PolarIQ LPF in DPD for NB/WT TX
        </comment>
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="data_format_ctrl">
      <bits access="r" name="data_format_ctrl_reserved_0" pos="15:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="nb_tx_rx_loop" pos="8" rst="0">
        <comment>
          BB TX data loopback to BB RX
        </comment>
      </bits>
      <bits access="rw" name="rx_iq_swap" pos="7" rst="0">
        <comment>
          BB RX IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="tx_iq_swap" pos="6" rst="0">
        <comment>
          BB TX IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="adc_iq_swap" pos="5" rst="0">
        <comment>
          ADC IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="dac_iq_swap" pos="4" rst="0">
        <comment>
          DAC IQ swap. 
0: normal
1: swap
        </comment>
      </bits>
      <bits access="rw" name="rx_off_bin_en" pos="3" rst="0">
        <comment>
          BB RX. 
0: two's complement
1: offset binary
        </comment>
      </bits>
      <bits access="rw" name="tx_off_bin_en" pos="2" rst="0">
        <comment>
          BB TX.
0: two's complement
1: offset binary
        </comment>
      </bits>
      <bits access="rw" name="adc_off_bin_en" pos="1" rst="0">
        <comment>
          RF ADC.
0: two's complement
1: offset binary
        </comment>
      </bits>
      <bits access="rw" name="dac_off_bin_en" pos="0" rst="1">
        <comment>
          RF DAC. 
0: two's complement
1: offset binary
        </comment>
      </bits>
    </reg>
    <hole size="160"/>
    <reg protect="rw" name="osc_temp_clk_ct">
      <bits access="r" name="osc_temp_clk_ct_reserved_0" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="osc_resetn_sw" pos="4" rst="0">
        <comment>
          reset for Temcomp, active low
        </comment>
      </bits>
      <bits access="rw" name="osc_clk_en" pos="3" rst="0">
        <comment>
          clock enable for Temcomp
        </comment>
      </bits>
      <bits access="rw" name="osc_clk_freq_sel" pos="2:1" rst="0">
        <comment>
          divide mode of clock from analog for Temcomp
0: not divide
1: 1/2 divide
2: 1/4 divide
3: 1/8 divide
        </comment>
      </bits>
      <bits access="rw" name="osc_clk_phase_sel" pos="0" rst="0">
        <comment>
          clock invert for Temcomp
0: clock invert disable
1: clock invert enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sdm_fre_hi_reg">
      <bits access="r" name="sdm_fre_hi_reg_reserved_0" pos="15:11" rst="0">
      </bits>
      <bits access="rw" name="sdm_force_bypass" pos="10" rst="0">
        <comment>
          force bypass, high valid
        </comment>
      </bits>
      <bits access="rw" name="sdm_bypass" pos="9" rst="1">
        <comment>
          bypass, high valid
        </comment>
      </bits>
      <bits access="rw" name="sdm_fre_load" pos="8" rst="0">
        <comment>
          set sdm frequency value, high valid
        </comment>
      </bits>
      <bits access="rw" name="sdm_fre_hi" pos="7:0" rst="0">
        <comment>
          sdm frequency value, high 8 bits
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sdm_fre_lo_reg">
      <bits access="rw" name="sdm_fre_lo" pos="15:0" rst="0">
        <comment>
          sdm frequency value, low 16 bits
        </comment>
      </bits>
    </reg>
    <hole size="192"/>
    <reg protect="rw" name="temcom_lpf_a11_rg">
      <bits access="r" name="temcom_lpf_a11_rg_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="temcom_lpf_a11" pos="13:0" rst="0">
        <comment>
          Coefficient a11 for Temcomp LPF
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="temcom_lpf_a12_rg">
      <bits access="r" name="temcom_lpf_a12_rg_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="temcom_lpf_a12" pos="13:0" rst="0">
        <comment>
          Coefficient a12 for Temcomp LPF
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="temcom_lpf_g1_rg">
      <bits access="r" name="temcom_lpf_g1_rg_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="temcom_lpf_g1" pos="13:0" rst="0">
        <comment>
          Coefficient g1 for Temcomp LPF
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="temcom_lpf_a21_rg">
      <bits access="r" name="temcom_lpf_a21_rg_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="temcom_lpf_a21" pos="13:0" rst="0">
        <comment>
          Coefficient a21 for Temcomp LPF
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="temcom_lpf_a22_rg">
      <bits access="r" name="temcom_lpf_a22_rg_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="temcom_lpf_a22" pos="13:0" rst="0">
        <comment>
          Coefficient a22 for Temcomp LPF
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="temcom_lpf_g2_rg">
      <bits access="r" name="temcom_lpf_g2_rg_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="temcom_lpf_g2" pos="13:0" rst="0">
        <comment>
          Coefficient g2 for Temcomp LPF
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="temcom_temp_ct">
      <bits access="r" name="temcom_temp_ct_reserved_0" pos="15:6" rst="0">
      </bits>
      <bits access="r" name="temcom_pout_val_rg" pos="5" rst="0">
        <comment>
          valid indication of temcom_pwd_dout after assert temcom_pout_load to avoid metastability. The temcom_pwd_dout is stable when this register is high
        </comment>
      </bits>
      <bits access="rw" name="temcom_pout_load" pos="4" rst="0">
        <comment>
          start to load the result of thermometer. Before next load, set it low firstly
        </comment>
      </bits>
      <bits access="rw" name="temcom_temp_lpf3_bypass" pos="3" rst="0">
        <comment>
          temperature calibration LPF bypass, high valid
        </comment>
      </bits>
      <bits access="rw" name="temcom_temp_ushift" pos="2:0" rst="0">
        <comment>
          temperature calibration LPF shift value
0 : left shift by 7 bit
1 : left shift by 6 bit
2 : left shift by 5 bit
3 : left shift by 4 bit
4 : left shift by 3 bit
5 : left shift by 2 bit
6 : left shift by 1 bit
7 : left shift by 0 bit
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="temcom_dout_reg">
      <bits access="r" name="temcom_pwd_dout" pos="15:0" rst="32768">
        <comment>
          The result of thermometer
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="temcom_pout_dout_rt_reg">
      <bits access="r" name="temcom_pwd_dout_rt" pos="15:0" rst="0">
        <comment>
          result of the thermometer, real time
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="txdp_pcom_zin_lo_rg">
      <bits access="r" name="txdp_pcom_zin_lo_rg_reserved_0" pos="15:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dfe_sw_clkgate_en_rg">
      <bits access="r" name="dfe_sw_clkgate_en_rg_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dfe_sw_clkgate_en" pos="0" rst="0">
        <comment>
          Globle clock gating disable register
0: no use
1: enable clock on all clock gating cells
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="mon_ct">
      <bits access="r" name="mon_ct_reserved_0" pos="15:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dfe_monitor_en" pos="5" rst="0">
        <comment>
          enable dfe monitor 
        </comment>
      </bits>
      <bits access="rw" name="dfe_monitor_swap" pos="4" rst="0">
        <comment>
          swap of dfe_monitor[15:8] and dfe_monitor[7:0]
0: no swap
1: swap
        </comment>
      </bits>
      <bits access="rw" name="dfe_monitor_sel" pos="3:0" rst="0">
        <comment>
          Monitor output selection
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_offset_re_rg">
      <bits access="r" name="dac_offset_re_rg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_offset_re" pos="11:0" rst="0">
        <comment>
          The offset on DAC real part
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_offset_im_rg">
      <bits access="r" name="dac_offset_im_rg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_offset_im" pos="11:0" rst="0">
        <comment>
          The offset on DAC image part
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_tx_amp_re_rg">
      <bits access="r" name="dac_tx_amp_re_rg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_tx_amp_re" pos="11:0" rst="0">
        <comment>
          The DAC real part on test mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="dac_tx_amp_im_rg">
      <bits access="r" name="dac_tx_amp_im_rg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="dac_tx_amp_im" pos="11:0" rst="0">
        <comment>
          The DAC image part on test mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_cic2_mode_rg">
      <bits access="r" name="txdp_cic2_mode_rg_reserved_0" pos="15:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="txdp_cic2_cfg_mode" pos="2:0" rst="0">
        <comment>
          Interp.CIC2 configuration mode for WT:
000: 60, 16K to 960K
001: 30, 32K to 960K
010: 25, 38.4K to 960K
011: 10, 96K to 960K
others: 5, 192K to 960K
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="data_dac_ctrl">
      <bits access="r" name="data_dac_ctrl_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="data_dac_sel" pos="13:12" rst="0">
        <comment>
          selection of function DAC data or test DAC data
00/01: select function DAC data including sine waveform
10: select test DAC data in RXDP path
11: select test DAC data in TXDP path
        </comment>
      </bits>
      <bits access="rw" name="sine_enable_rg" pos="11" rst="0">
        <comment>
          enable sine waveform generation module
        </comment>
      </bits>
      <bits access="rw" name="rxdp_test_dac_en_rg" pos="10" rst="0">
        <comment>
          enable test DAC data in RXDP path
        </comment>
      </bits>
      <bits access="rw" name="rxdp_test_dac_sel_rg" pos="9:5" rst="0">
        <comment>
          select test DAC data in RXDP path
        </comment>
      </bits>
      <bits access="rw" name="txdp_test_dac_en_rg" pos="4" rst="0">
        <comment>
          enable test DAC data in TXDP path
        </comment>
      </bits>
      <bits access="rw" name="txdp_test_dac_sel_rg" pos="3:0" rst="0">
        <comment>
          select test DAC data in TXDP path
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sincos_amp">
      <bits access="r" name="sincos_amp_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sincos_amp_rg" pos="11:0" rst="511">
        <comment>
          sine waveform amplitude
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sincos_fre_lo">
      <bits access="rw" name="sincos_fre_rg_lo" pos="15:0" rst="54613">
        <comment>
          bit [15:0] of sine waveform frequence
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sincos_fre_hi">
      <bits access="r" name="sincos_fre_hi_reserved_0" pos="15:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="sincos_fre_rg_hi" pos="6:0" rst="0">
        <comment>
          bit [22:16] of sine waveform frequence
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_bypass_reg0">
      <bits access="rw" name="txdp_bypass_cic1" pos="15" rst="0">
        <comment>
          Interp. CIC1
0: SW bypass disable
1: SW bypass enable
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_gsm_gdeq" pos="14" rst="0">
        <comment>
          Group Delay Equ. when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb5" pos="13" rst="0">
        <comment>
          Interp.HBF5
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb4" pos="12" rst="0">
        <comment>
          Interp. HBF4
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_gdeq" pos="11" rst="0">
        <comment>
          Group Delay Equ.
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq_lpf" pos="10" rst="0">
        <comment>
          LPF of DPD only when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq_ampm" pos="9" rst="0">
        <comment>
          AMPM of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq_split" pos="8" rst="0">
        <comment>
          Split of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_polariq" pos="7" rst="0">
        <comment>
          Whole DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_rc" pos="6" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_gain" pos="5" rst="0">
        <comment>
          Gain
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb3" pos="4" rst="0">
        <comment>
          Interp.HBF3 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb2" pos="3" rst="0">
        <comment>
          Interp.HBF2 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_uphb1" pos="2" rst="0">
        <comment>
          Interp.HBF1
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_aclr_lpf" pos="1" rst="0">
        <comment>
          ACLR LPF
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_cic2" pos="0" rst="0">
        <comment>
          Interp. CIC2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_bypass_reg1">
      <bits access="r" name="txdp_bypass_reg1_reserved_0" pos="15:1" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_imbc" pos="0" rst="0">
        <comment>
          IMBC bypass 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_bypass_mode_reg0">
      <bits access="rw" name="txdp_bypass_mode_cic1" pos="15" rst="0">
        <comment>
          Interp. CIC1
0: bypass controlled by HW. HW bypass module automaticlly based on algorithm requirement
1: bypass controlled by SW. When it is set, txdp_bypass_cic1 will be used
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_gsm_gdeq" pos="14" rst="0">
        <comment>
          Group Delay Equ. when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb5" pos="13" rst="0">
        <comment>
          Interp.HBF5
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb4" pos="12" rst="0">
        <comment>
          Interp.HBF4
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_gdeq" pos="11" rst="0">
        <comment>
          Group Delay Equ.
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq_lpf" pos="10" rst="0">
        <comment>
          LPF of DPD only when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq_ampm" pos="9" rst="0">
        <comment>
          AMPM of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq_split" pos="8" rst="0">
        <comment>
          Split of DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_polariq" pos="7" rst="0">
        <comment>
          Whole DPD
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_rc" pos="6" rst="0">
        <comment>
          RC
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_gain" pos="5" rst="0">
        <comment>
          Gain
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb3" pos="4" rst="0">
        <comment>
          Interp.HBF3 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb2" pos="3" rst="0">
        <comment>
          Interp.HBF2 when PolarIQ
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_uphb1" pos="2" rst="0">
        <comment>
          Interp.HBF1
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_aclr_lpf" pos="1" rst="0">
        <comment>
          ACLR LPF
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_cic2" pos="0" rst="0">
        <comment>
          Interp. CIC2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_bypass_mode_reg1">
      <bits access="r" name="txdp_bypass_mode_reg1_reserved_0" pos="15:1" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_bypass_mode_imbc" pos="0" rst="0">
        <comment>
          IMBC bypass mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lvds_mode_reg">
      <bits access="rw" name="lvds_in_wt" pos="15" rst="0">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="rw" name="en_clk_lvds2dfe_bb_rx" pos="14" rst="0">
        <comment>
          clock enable for BB side when adc-dfe-lvds-bb, enable when lvds_rx_mode is 3
        </comment>
      </bits>
      <bits access="rw" name="en_clk_lvds2dfe_dfe_tx" pos="13" rst="0">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="rw" name="en_clk_lvds2dfe_dfe_rx" pos="12" rst="0">
        <comment>
          clock enable for ADC RX when adc-lvds-dfe-bb, enable when lvds_rx_mode is 1
        </comment>
      </bits>
      <bits access="rw" name="en_clk_lvds2dfe_rf_tx" pos="11" rst="0">
        <comment>
          clock enable for DAC TX when bb-dfe-lvds-dac, enable when lvds_rx_mode is 0
        </comment>
      </bits>
      <bits access="rw" name="en_clk_dfe2lvds" pos="10" rst="0">
        <comment>
          clock enable for lvds_tx, enable when lvds_tx_mode is 0/1/2/3
        </comment>
      </bits>
      <bits access="rw" name="lvds_rx_clk_mux_bb_rx" pos="9" rst="0">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="rw" name="lvds_rx_clk_mux_dfe_rx" pos="8" rst="0">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="rw" name="lvds_rx_clk_mux_rf_tx" pos="7" rst="0">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="rw" name="lvds_tx_clk_mode" pos="6:5" rst="0">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="rw" name="lvds_rx_mode" pos="4:3" rst="0">
        <comment>
          3: lvds_rx in adc-dfe-lvds-bb
2: lvds_rx in bb-lvds-dfe-dac
1: lvds_rx in adc-lvds-dfe-bb
0: lvds_rx in bb-dfe-lvds-dac
        </comment>
      </bits>
      <bits access="rw" name="lvds_tx_mode" pos="2:1" rst="0">
        <comment>
          3: lvds_tx in adc-dfe-lvds-bb
2: lvds_tx in bb-lvds-dfe-dac
1: lvds_tx in adc-lvds-dfe-bb
0: lvds_tx in bb-dfe-lvds-dac
        </comment>
      </bits>
      <bits access="rw" name="lvds_enable" pos="0" rst="0">
        <comment>
          LVDS enabled in DFE
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lvds_swap_reg">
      <bits access="r" name="lvds_swap_reg_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="dfe2lvds_bbtx_clkdiv" pos="7:6" rst="0">
        <comment>
          frequency select of dfe2lvds_clk when bb-lvds-dfe-dac.
0: 7.68MHz
1: 15.36MHz
2: 30.72MHz
3: 61.44MHz
        </comment>
      </bits>
      <bits access="rw" name="dfe2lvds_bbrx_clkdiv" pos="5:4" rst="0">
        <comment>
          frequency select of dfe2lvds_clk when adc-dfe-lvds-bb.
0: 7.68MHz
1: 15.36MHz
2: 30.72MHz
3: 61.44MHz
        </comment>
      </bits>
      <bits access="rw" name="lvds_rx_clk_ref_bb_rx" pos="3" rst="0">
        <comment>
          clock select in BB side when adc-dfe-lvds-bb and bb-lvds-dfe-dac
0: use LVDS clock
1: use BBPLL clock
        </comment>
      </bits>
      <bits access="rw" name="sel_lvds2dfe_clk" pos="2" rst="0">
        <comment>
          work clock used for BB when LVDS mode
0: lvds2dfe_clk_dig_ref
1: lvds2dfe_clk
        </comment>
      </bits>
      <bits access="rw" name="lvds_rx_swap" pos="1" rst="0">
        <comment>
          iq swap on lvds2dfe_data
        </comment>
      </bits>
      <bits access="rw" name="lvds_tx_swap" pos="0" rst="0">
        <comment>
          iq swap on dfe2lvds_data
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_imbc_phase_err_reg">
      <bits access="r" name="txdp_imbc_phase_err_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_imbc_phase_err_rg" pos="11:0" rst="0">
        <comment>
          for txdp imbc phase err
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_imbc_amp_err_reg">
      <bits access="r" name="txdp_imbc_amp_err_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_imbc_amp_err_rg" pos="11:0" rst="0">
        <comment>
          for txdp imbc amplitude err
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="txdp_imbc_offset_i_reg">
      <bits access="r" name="txdp_imbc_offset_i_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_imbc_offset_i_rg" pos="11:0" rst="0">
        <comment>
          for txdp imbc offset_i
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_imbc_offset_reg">
      <bits access="r" name="txdp_imbc_offset_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="rw" name="txdp_imbc_offset_rg" pos="11:0" rst="0">
        <comment>
          for txdp imbc offset
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reserved_half_ones_reg">
      <bits access="rw" name="rsv_half_ones" pos="15:0" rst="65280">
        <comment>
          all one bits, reserved for ECO
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_clk_gate_enable_reg">
      <bits access="r" name="txdp_clk_gate_enable_reg_reserved_0" pos="15:9" rst="0">
      </bits>
      <bits access="rw" name="txdp_aclr_clkgate_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="txdp_dpd_clkgate_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="txdp_gsm_grp_dly_clkgate_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="txdp_uphb2_clkgate_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="txdp_uphb3_clkgate_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="txdp_imbc_clkgate_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="txdp_uphb5_clkgate_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="txdp_interp_cic1_clkgate_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="txdp_sine_clkgate_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rxdp_clk_gate_enable_reg1">
      <bits access="r" name="rxdp_clk_gate_enable_reg1_reserved_0" pos="15:10" rst="0">
      </bits>
      <bits access="rw" name="rxdp_notch1_clkgate_en" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rxdp_dnsc1_clkgate_en" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rxdp_mixer_clkgate_en" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rxdp_ob_clkgate_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rxdp_dnhb1_clkgate_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rxdp_aci_clkgate_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rxdp_notch2_clkgate_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rxdp_gain2_clkgate_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rxdp_ib_clkgate_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="rxdp_deci_clkgate_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="share_clk_gate_enable_reg1">
      <bits access="r" name="share_clk_gate_enable_reg1_reserved_0" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="share_grp_dly_clkgate_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="share_gain_clkgate_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="share_rc_clkgate_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="share_uphb1_clkgate_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="share_uphb2_clkgate_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="test_dac_bits_sel_register">
      <bits access="r" name="test_dac_bits_sel_register_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="test_dac_bits_sel" pos="2:0" rst="0">
        <comment>
          0:[11:0], 1:[12:1], 2:[13:2], 3:[14:3], 4: [15:4]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fifo_sample_rate_reg1">
      <bits access="r" name="fifo_sample_rate_reg1_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="fifoa_wr_en_rg" pos="13" rst="0">
        <comment>
          write enable for FIFO A
        </comment>
      </bits>
      <bits access="rw" name="fifoa_smp_rate_rg" pos="12:8" rst="3">
        <comment>
          read interval for FIFO A
        </comment>
      </bits>
      <bits access="r" name="fifo_sample_rate_reg1_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="fifob_wr_en_rg" pos="5" rst="0">
        <comment>
          write enable for FIFO B
        </comment>
      </bits>
      <bits access="rw" name="fifob_smp_rate_rg" pos="4:0" rst="31">
        <comment>
          read interval for FIFO B
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fifo_sample_rate_reg2">
      <bits access="r" name="fifo_sample_rate_reg2_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="fifoc_wr_en_rg" pos="13" rst="0">
        <comment>
          write enable for FIFO C
        </comment>
      </bits>
      <bits access="rw" name="fifoc_smp_rate_rg" pos="12:8" rst="3">
        <comment>
          read interval for FIFO C
        </comment>
      </bits>
      <bits access="r" name="fifo_sample_rate_reg2_reserved_1" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="fifod_wr_en_rg" pos="5" rst="0">
        <comment>
          write enable for FIFO D
        </comment>
      </bits>
      <bits access="rw" name="fifod_smp_rate_rg" pos="4:0" rst="31">
        <comment>
          read interval for FIFO D
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="fifo_status_reg">
      <bits access="r" name="fifo_status_reg_reserved_0" pos="15:14" rst="0">
      </bits>
      <bits access="r" name="fifo_txdp_rc_full_status" pos="13" rst="0">
        <comment>
          FIFO txdp_rc full
        </comment>
      </bits>
      <bits access="r" name="fifo_txdp_rc_empty_status" pos="12" rst="0">
        <comment>
          FIFO txdp_rc empty
        </comment>
      </bits>
      <bits access="r" name="fifo_rxdp_rc_full_status" pos="11" rst="0">
        <comment>
          FIFO rxdp_rc full
        </comment>
      </bits>
      <bits access="r" name="fifo_rxdp_rc_empty_status" pos="10" rst="0">
        <comment>
          FIFO rxdp_rc empty
        </comment>
      </bits>
      <bits access="r" name="fifo_adc_full_status" pos="9" rst="0">
        <comment>
          FIFO ADC full
        </comment>
      </bits>
      <bits access="r" name="fifo_adc_empty_status" pos="8" rst="0">
        <comment>
          FIFO ADC empty, this FIFO used between ADC and DFE
        </comment>
      </bits>
      <bits access="r" name="fifod_full_status" pos="7" rst="0">
        <comment>
          FIFO D full
        </comment>
      </bits>
      <bits access="r" name="fifod_empty_status" pos="6" rst="0">
        <comment>
          FIFO D empty, this FIFO used when LVDS RX for bb-lvds-dfe-dac
        </comment>
      </bits>
      <bits access="r" name="fifoc_full_status" pos="5" rst="0">
        <comment>
          FIFO C full
        </comment>
      </bits>
      <bits access="r" name="fifoc_empty_status" pos="4" rst="0">
        <comment>
          FIFO C empty, this FIFO used when LVDS TX for bb-lvds-dfe-dac
        </comment>
      </bits>
      <bits access="r" name="fifob_full_status" pos="3" rst="0">
        <comment>
          FIFO B full
        </comment>
      </bits>
      <bits access="r" name="fifob_empty_status" pos="2" rst="0">
        <comment>
          FIFO B empty, this FIFO used when LVDS RX for adc-dfe-lvds-bb 
        </comment>
      </bits>
      <bits access="r" name="fifoa_full_status" pos="1" rst="0">
        <comment>
          FIFO A full
        </comment>
      </bits>
      <bits access="r" name="fifoa_empty_status" pos="0" rst="0">
        <comment>
          FIFO A empty, this FIFO used when LVDS TX for adc-dfe-lvds-bb 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="txdp_resetn_reg">
      <bits access="r" name="txdp_resetn_reg_reserved_0" pos="15:2" rst="0">
      </bits>
      <bits access="rw" name="sw_resetn_tx" pos="1" rst="1">
        <comment>
          SW controlled reset for TXDP when reset_mode is 0, active low.
0: reset
1: no reset
        </comment>
      </bits>
      <bits access="rw" name="reset_mode_tx" pos="0" rst="0">
        <comment>
          Reset source for TXDP.
0: reset from BB TCU event signal with precise timing control
1: reset from register resetn_rxdp
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "dma.xml">
<module name="dma" category="System">
  <reg protect="w" name="get_channel">
    <bits access="r" name="Get Channel" pos="0" rst="1">
      <comment>Returns 1 and locks the DMA channel for a transaction if it is
      available. Else returns 0. <br />Clear the transfer done interrupt
      status. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Enable" pos="0" rst="0">
      <comment>Status of the DMA: 1 if enabled, 0 if disabled. </comment>
    </bits>

    <bits access="r" name="Int Done Cause" pos="1" rst="0">
      <comment>Cause of the interrupt. This bit is set when the transfer is
      done and the interrupt mask bit is set. <br />Write one in the Int Clear
      or write 0 in Enable control bits to clear Int Done Cause bit.
      </comment>
    </bits>

    <bits access="r" name="Int Done Status" pos="2" rst="0">
      <comment>Status of the interrupt. Status of the transfer: 1 if the
      transfer is finished, 0 if it is not finished. <br />Write one in the
      Int Clear or write 0 in Enable control bits to clear Int Done Status
      bit. </comment>
    </bits>

    <bits access="r" name="Channel Lock" pos="4" rst="0">
      <comment>Actual status of channel lock. Channel is unlocked at the end
      of transaction or when the DMA is disabled. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="control">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <comment>Controls the DMA. Write 1 to enable the DMA, write 0 to disable
      it. When 0 is written in this register, the Int Done Status and Cause
      bits are reset. </comment>
    </bits>

    <bits access="rw" name="Int Done Mask" pos="1" rst="0">
      <comment>End of transfer interrupt generation. When 1, the DMA will send
      an interrupt at transaction completion. </comment>
      <options>
        <shift/>
      </options>  
    </bits>

    <bits access="rw" name="Int Done Clear" pos="2" rst="0">
      <comment>Clear the transfer done interruption (this will clear Int Done
      Status and Int Done Cause). <br />This bit is auto-clear. You will
      always read 0 here. </comment>
    </bits>

    <bits access="rw" name="Use Pattern" pos="4" rst="0">
      <comment>If this bit is set, the source address will be ignored and the
      memory will be fill with the value of the pattern register. </comment>
    </bits>

    <bits access="rw" name="max_burst_length" pos="6:5" rst="00">
      <comment>Set the MAX burst length. 
        <br/> The 2'b10 mean burst max 16, 2'b01 mean burst max 8, 00 mean burst max 4. 
      </comment>
    </bits>

    <bits access="w" name="Stop Transfer" pos="8" rst="0">
      <comment>The DMA stop the current transfer and flush his FIFO (write
      only bit). When the FIFO is empty and last write performed, the DMA is
      disabled and available for a next transfer. The number of bytes copied
      is readable on DMA_XFER_SIZE register.</comment>
    </bits>

    <bits access="rw" name="GEA Enable" pos="12" rst="0">
      <options>
        <option name="DMA" value="0" />

        <option name="GEA" value="1" />

        <default />
      </options>

      <comment>Enable Gea process when 1.</comment>
    </bits>

    <bits access="rw" name="GEA Algorithm" pos="13" rst="1">
      <options>
        <option name="GEA1" value="0" />

        <option name="GEA2" value="1" />

        <default />
      </options>

      <comment>This field sets the type of GEA algorithm to process.</comment>
    </bits>

    <bits access="rw" name="GEA Direction" pos="14" rst="1">
      <options>
        <shift/>
      </options>
      <comment>This field selects the Direction in the GEA algorithm.
      </comment>
    </bits>

    <bits access="rw" name="FCS Enable" pos="16" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="FCS_PROCESS" value="1" />

        <default />
      </options>

      <comment>Enable FCS process when 1.</comment>
    </bits>

    <bits access="rw" name="Dst Addr Mgt" pos="21:20" rst="0">
      <options>
        <option name="NORMAL_DMA" value="0" />

        <option name="CONST_ADDR" value="1" />

        <option name="ALTERN_ADDR" value="2" />

        <option name="RESERVED" value="3" />

        <default />
      </options>

      <comment>Destination address management.<br />00 : Normal DMA operation,
      DMA_DST_ADDR register define the destination address.<br /> 01 : DMA
      write address is constant (no incremented) and defined by the
      DMA_DST_ADDR register. All data write are in 16-bit.<br /> 10 : DMA
      write address is alternatively defined by DMA_DST_ADDR and
      DMA_SD_DST_ADDR registers. All data write are in 16-bit. <br />In this
      configuration, DMA write operation is alternatively: <br />DMA_DST_ADDR
      &lt;= DMA_PATTERN register <br />DMA_SD_DST_ADDR &lt;=
      Data[DMA_SRC_ADDR] <br />11 : reserved </comment>
    </bits>
  </reg>

  <reg protect="rw" name="src_addr">
    <bits access="rw" name="Src Address" pos="27:0" rst="0xFFFFFFF">
      <comment>Source start read byte address. When a transfer is stalled by
      the Stop_Transfer bit, this register give the next current source
      address, which is directly the value to re-program to complete the
      transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="dst_addr">
    <bits access="rw" name="Dst Address" pos="27:0" rst="0xFFFFFFF">
      <comment>Destination start read byte address. When a transfer is stalled
      by the Stop_Transfer bit, this register give the next current
      destination address, which is directly the value to re-program to
      complete the transfer stopped.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="sd_dst_addr">
    <bits access="rw" name="Sd Dst Address" pos="27:0" rst="0xFFFFFFF">
      <comment>Second destination address. This register is only used when
      Dst_Address_Mgt=10.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="xfer_size">
    <bits access="rw" name="Transfer Size" pos="17:0" rst="0x3FFFF">
      <comment>Transfer size in bytes. Maximum: 262144 bytes. When a transfer
      is stopped by the Stop_Transfer bit, this register give the number of
      remainder bytes to transfer.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="pattern">
    <bits access="rw" name="Pattern" pos="31:0" rst="0xFFFFFFFF">
      <comment>Value taken to fill the memory when the configuration bit Use
      Pattern is set. When the pattern mode is used the destination address
      must be 32-bit aligned and the transfer size multiple of 4. when
      Dst_Address_Mgt=10 Pattern is the data written at the address given by
      the Dst_Address register.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_low">
    <bits access="rw" name="KC_LSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, LSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_kc_high">
    <bits access="rw" name="KC_MSB" pos="31:0" rst="0xFFFFFFFF">
      <comment>GEA key Kc, MSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gea_messkey">
    <bits access="rw" name="MessKey" pos="31:0" rst="0xFFFFFFFF">
      <comment>MessKey (Input) register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="fcs">
    <bits access="r" name="FCS" pos="23:0" rst="0">
      <comment>Frame Check Sequence.</comment>
    </bits>

    <bits access="r" name="FCS Correct" pos="31" rst="0">
      <comment>The FCS is correct in reception when the final remainder is
      equal to C(x)= x^22 + x^21 + x^19 + x^18 + x^16 + x^15 + x^11 + x^8 +
      x^5 + x^4</comment>
    </bits>

    
  </reg>
</module>
</archive>


<archive relative = "excor.xml">

<include file="globals.xml"/>

<module name="excor" category="Baseband">

 <var name="EXCOR_IDLE" value="0" />
 <var name="EXCOR_BMMLZF" value="1" />
 <var name="EXCOR_COMPMATRIMUL" value="2" />
 <var name="EXCOR_COMPCONV" value="3" />
 <var name="EXCOR_COMPPOW" value="4" />
 <var name="EXCOR_DEROTATE" value="5" />
 <var name="EXCOR_DCCOMP" value="6" />
 <var name="EXCOR_SRECPSK8" value="7" />
 <var name="EXCOR_FCCH" value="8" />
 <var name="EXCOR_IR_COMB" value="9" />
 <var name="EXCOR_IQ_SHIFT" value="10" />
 <var name="EXCOR_STATUS_MASK" value="1" />
 <var name="EXCOR_FASTMATRIMUL" value="11" />
 <var name="EXCOR_FASTCONV" value="12" />
 <var name="EXCOR_2XTO1X" value="19" />
 <var name="EXCOR_M1" value="20" />
 <var name="EXCOR_M2" value="21" />
 <var name="EXCOR_Z" value="22" />
 <var name="EXCOR_Y" value="23" />
 <var name="EXCOR_DET" value="24" />
 
  
 
  <reg name="ctrl" protect="rw">
    <bits access="rw" name="cmd" pos="7:0" rst="0x0">
      <comment>Control setting. comand type. </comment>
    </bits>

    <bits access="rw" name="nb_iloop" pos="15:8" rst="0x0">
      <comment>Control setting. Number of internal loop iteration.
      </comment>
    </bits>

    <bits access="rw" name="nb_oloop" pos="25:16" rst="0x0">
      <comment>Control setting. Number of nb_symbol.
      </comment>
    </bits>

    <bits access="rw" name="shift_bit" pos="30:26" rst="0x0">
      <comment>Control setting. Number of shift bits.
      </comment>
    </bits>
  </reg>

 <reg name="addr0" protect="rw">
    <bits access="rw" name="addr0" pos="14:0" rst="0x0">
        <comment>address register 0. </comment>
    </bits>

  </reg>
  
  <reg name="addr1" protect="rw">
    <bits access="rw" name="addr1" pos="14:0" rst="0x0">
        <comment>address register 1. </comment>
    </bits>
  </reg>
  
  <reg name="addr2" protect="rw">
    <bits access="rw" name="addr2" pos="14:0" rst="0x0">
        <comment>address register 2. </comment>
    </bits>
  </reg>
  
<reg name="addr3" protect="rw">
    <bits access="rw" name="addr3" pos="31:0" rst="0x0">
        <comment>address register 3. </comment>
    </bits>
  </reg>
  
<reg name="addr4" protect="rw">
    <bits access="rw" name="addr4" pos="31:0" rst="0x0">
        <comment>address register 4. </comment>
    </bits>
  </reg>  
  
<reg name="addr5" protect="rw">
    <bits access="rw" name="addr5" pos="31:0" rst="0x0">
        <comment>address register 5. </comment>
    </bits>
  </reg>  
  
 <reg name="data0" protect="rw">
    <bits access="rw" name="data0" pos="31:0" rst="0x0">
        <comment>data register 0. </comment>
    </bits>
  </reg>  
  
 <reg name="data1" protect="rw">
    <bits access="rw" name="data1" pos="31:0" rst="0x0">
        <comment>data register 1. </comment>
    </bits>
  </reg>
  
 <reg name="data2" protect="rw">
    <bits access="rw" name="data2" pos="31:0" rst="0x0">
        <comment>data register 2. </comment>
    </bits>
  </reg>  
    
 <reg name="data3" protect="rw">
    <bits access="rw" name="data3" pos="31:0" rst="0x0">
        <comment>data register 3. </comment>
    </bits>
  </reg>  
  
 <reg name="data4" protect="rw">
    <bits access="rw" name="ircom_psidx0" pos="1:0" rst="0x0">
      <comment>for ircombine idx0 </comment>
    </bits>
    <bits access="rw" name="ircom_psidx2" pos="5:4" rst="0x0">
      <comment>for ircombine idx1 </comment>
    </bits>
    <bits access="rw" name="ircom_psidx1" pos="18:8" rst="0x0">
      <comment>for ircombine idx2 </comment>
    </bits>
  </reg>    
  
 <reg name="data5" protect="rw">
    <bits access="rw" name="data5" pos="31:0" rst="0x0">
        <comment>data register 5. </comment>
    </bits>
  </reg>    
  
  
  <reg name="status" protect="rw">
    <bits access="rw" name="status" pos="7:0" rst="0x0">
        <comment>Status is set to 1 when an operation is finished. </comment>
    </bits>
  </reg>
  <reg name="ctrl_fast" protect="rw">
    <bits access="rw" name="loop_num_a" pos="2:0" rst="0x0">
      <comment>Control setting. Number of A row. </comment>
    </bits>

    <bits access="rw" name="loop_num_b" pos="6:4" rst="0x0">
      <comment>Control setting. Number of B column.
      </comment>
    </bits>

    <bits access="rw" name="loop_num_ab" pos="15:8" rst="0x0">
      <comment>Control setting. Number of  A column and B row.
      </comment>
    </bits>
    <bits access="rw" name="shift_bit_reg1" pos="20:16" rst="0x0">
      <comment>Control setting. Number of  shift bit after multiply.
      </comment>
    </bits>
  </reg>  
</module>

</archive>
<archive relative = "f8.xml">
<module name="cipher_f8" category="Baseband">
  
  <reg protect="rw" name="F8_CONF">
    <bits access="rw" name="F8_START" pos="0" rst="0">
      <comment>f8 start bit, 0: not start or finished ,  1: start</comment>
    </bits>
    
    <bits access="rw" name="F8_IRQ_EN" pos="1" rst="0">
      <comment> when all groups done , 0: no gen int 1: gen int </comment>
    </bits>
    
    <bits access="rw" name="F8_AR_SEL" pos="3:2" rst="0x0">
        <comment>function sel 00: only move data , no encrypt 
                              01:      move data , AES encrypt
                              10:      move data , snow3G encrypt
                              11:      move data , zuc encrypt
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="F8_GROUP_ADDR">
    <bits access="rw" name="GROUP_ADDR" pos="31:0" rst="0x0">
      <comment>group start address</comment>
    </bits>
  </reg>

  <reg protect="rw" name="F8_GROUP_CNT">
    <bits access="rw" name="GROUP_ADDR" pos="31:0" rst="0x0">
      <comment>total group cnt</comment>
    </bits>
  </reg>

  <reg protect="rw" name="F8_STATUS">
    <bits access="rw" name="F8_STAT" pos="0" rst="0">
      <comment>0: not started or no finished  1: finished</comment>
    </bits>

    <bits access="rw" name="F9_STAT" pos="1" rst="0">
      <comment>0: not started or no finished  1: finished</comment>
    </bits>
  </reg>

  <reg protect="rw" name="F9_CONF">
    <bits access="rw" name="F9_START" pos="0" rst="0">
      <comment>f9 start bit, 0: not start or finished ,  1: start</comment>
    </bits>
    
    <bits access="rw" name="F9_IRQ_EN" pos="1" rst="0">
      <comment> when all groups done , 0: no gen int 1: gen int </comment>
    </bits>
    
    <bits access="rw" name="F9_AR_SEL" pos="3:2" rst="0x0">
        <comment>function sel 00:  AES encrypt 
                              01:  AES encrypt
                              10:  snow3G encrypt
                              11:  zuc encrypt
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="F9_GROUP_ADDR">
    <bits access="rw" name="F9_ADDR" pos="31:0" rst="0x0">
      <comment>group start address</comment>
    </bits>
  </reg>

  <reg protect="r" name="F9_RESULT">
    <bits access="rw" name="F9_MAC" pos="31:0" rst="0x0">
      <comment>f9 result</comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative = "gea3.xml">

  <module name="gea3" category="Baseband">
      <reg protect="rw" name="gprs_clc">
        <bits access="rw" name="gprs_clc" pos="31:0" rst="0">
        </bits>
      </reg>

      <hole size="32*3" />

      <reg protect="--" name="gprs_data">
        <bits access="rw" name="data" pos="31:0" rst="0">
        </bits>
      </reg>

      <reg protect="ro" name="gprs_status">
        <bits access="ro" name="status" pos="31:0" rst="0">
        </bits>
      </reg>

      <hole size="32*6" />

      <reg protect="rw" name="gprs_kc0">
        <bits access="rw" name="kc0" pos="31:0" rst="0">
        </bits>
      </reg>

      <reg protect="rw" name="gprs_kc1">
        <bits access="rw" name="kc1" pos="31:0" rst="0">
        </bits>
      </reg>

      <reg protect="rw" name="gprs_kc2">
        <bits access="rw" name="kc2" pos="31:0" rst="0">
        </bits>
      </reg>

      <reg protect="rw" name="gprs_kc3">
        <bits access="rw" name="kc3" pos="31:0" rst="0">
        </bits>
      </reg>

      <reg protect="rw" name="gprs_input">
        <bits access="rw" name="input" pos="31:0" rst="0">
        </bits>
      </reg>

      <reg protect="rw" name="gprs_gea3">
        <bits access="rw" name="gea3" pos="31:0" rst="0">
        </bits>
      </reg>

      <hole size="32*1" />

      <reg protect="rw" name="gprs_ctrl">
        <bits access="rw" name="ctrl" pos="31:0" rst="0">
        </bits>
      </reg>

  </module>

</archive>

<archive relative = "gpio.xml">

  
  

  
  <var name="IDX_GPIO_DCON" value="0" />
  <var name="IDX_GPO_CHG"   value="0" />
  <var name="NB_GPIO"       value="64" />
  <var name="NB_GPIO_INT"   value="64" />
  <var name="NB_GPO"        value="10" />

<module name="gpio" category="Periph">

  
  
  <reg protect="rw" name="gpio_oen_val_l">
    <bits access="rw" name="oen_val_l" pos="31:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out_l">
    <bits access="rc" name="oen_set_out_l" pos="31:0" rst="0xffffffff">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in_l">
    <bits access="rs" name="oen_set_in_l" pos="31:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val_l">
    <bits access="rw" name="gpio_val_l" pos="31:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set_l">
    <bits access="rs" name="gpio_set_l" pos="31:0" rst="0xffffffff">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr_l">
    <bits access="rc" name="gpio_clr_l" pos="31:0" rst="0xffffffff">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="gpint_r_set_l">
     <bits access="rs" name="gpint_r_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_r_set_h">
     <bits access="rs" name="gpint_r_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>

  <reg protect="w" name="int_clr_l">
    <bits access="c" name="gpint_clr_l" pos="31:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status_l">
    <bits access="r" name="gpint_status_l" pos="31:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="rw" name="chg_ctrl">
    <bits access="rw" name="out_time" pos="3:0" rst="0xf" display="hex">
        <comment>time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.<br />The output time = (OUT_TIME+1)*30.5us.
        </comment>
    </bits>

    <bits access="rw" name="wait_time" pos="9:4" rst="0x3f" display="hex">
        <comment>time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.<br />The wait time = (WAIT_TIME+1)*30.5us.
            <br/>NOTE: wait_time must be strictly greater than out_time;
        </comment>
    </bits>

    <bits access="rw" name="int_mode" pos="17:16" rst="0x3" display="hex">
        <comment>interruption mode of GPIO0 in mode DC_ON detection.<br />
        </comment>
            <options>
                <option name="L2H" value="0">
                    <comment>
                        "00" = send IRQ if last read DCON is '0' and now is '1'. 
                    </comment>
                </option>
                <option name="H2L" value="1">
                    <comment>
                        "01" = send IRQ if last read DCON is '1' and now is '0'.
                    </comment>
                </option>
                <option name="RR" value="3">
                    <comment>
                        "11" = send IRQ every time read is ready.
                    </comment>
                </option>
            </options>
    </bits>
  </reg>

  <reg protect="w" name="chg_cmd">
    <bits access="s" name="dcon_mode_set" pos="0" rst="0">
      <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
    </bits>
      
    <bits access="s" name="chg_mode_set" pos="4" rst="0">
      <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
    </bits>

    <bits access="c" name="dcon_mode_clr" pos="8" rst="0">
      <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
    </bits>

    <bits access="c" name="chg_mode_clr" pos="12" rst="0">
      <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
    </bits>

    <bits access="s" name="chg_down" pos="24" rst="0">
      <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_set">
    <bits access="rs" name="gpo_set" pos="NB_GPO-1:0" rst="0x2aa" display="hex">
      <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpo_clr">
    <bits access="rc" name="gpo_clr" pos="NB_GPO-1:0" rst="0x2aa" display="hex">
      <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  
  <reg protect="rw" name="gpio_oen_val_h">
    <bits access="rw" name="oen_val_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <options>
        <option name="INPUT" value="1" />

        <option name="OUTPUT" value="0" />

        <default />
      </options>

      <comment>Set the direction of the GPIO n.<br />0 = output<br />1 =
      input</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_out_h">
    <bits access="rc" name="oen_set_out_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_oen_set_in_h">
    <bits access="rs" name="oen_set_in_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg protect="rw" name="gpio_val_h">
    <bits access="rw" name="gpio_val_h" pos="NB_GPIO-33:0" rst="0xffffffff" display="hex">
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_set_h">
    <bits access="rs" name="gpio_set_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="gpio_clr_h">
    <bits access="rc" name="gpio_clr_h" pos="NB_GPIO-33:0" rst="0xffffffff">
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>

  
  
   <reg protect="rw" name="gpint_r_clr_l">
     <bits access="rs" name="gpint_r_clr_l" pos="31:0" rst="0">
       <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
       level high.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_r_clr_h">
     <bits access="rs" name="gpint_r_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
       level high.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_f_set_l">
     <bits access="rs" name="gpint_f_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for rising edge and
       level high. When read, get the GPIO interrupt mask for rising edge and
       level high. </comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_f_set_h">
     <bits access="rs" name="gpint_f_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set GPIO interrupt mask for falling edge and
       level low. When read, get the GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_f_clr_l">
     <bits access="rs" name="gpint_f_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will clear GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_f_clr_h">
     <bits access="rs" name="gpint_f_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will clear GPIO interrupt mask for falling edge and
       level low.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_dbn_en_set_l">
     <bits access="rs" name="dbn_en_set_l" pos="31:0" rst="0">
       <comment>Write '1' will enable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_set_h">
     <bits access="rs" name="dbn_en_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will enable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_clr_l">
     <bits access="rs" name="dbn_en_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will disable debounce mechanism.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_dbn_en_clr_h">
     <bits access="rs" name="dbn_en_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will disable debounce mechanism.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_mode_set_l">
     <bits access="rs" name="gpint_mode_set_l" pos="31:0" rst="0">
       <comment>Write '1' will set interruption mode to level.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_mode_set_h">
     <bits access="rs" name="gpint_mode_set_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set interruption mode to level.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="gpint_mode_clr_l">
     <bits access="rs" name="gpint_mode_clr_l" pos="31:0" rst="0">
       <comment>Write '1' will set interruption mode to edge
       triggered.</comment>
     </bits>
   </reg>
   <reg protect="rw" name="gpint_mode_clr_h">
     <bits access="rs" name="gpint_mode_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
       <comment>Write '1' will set interruption mode to edge
       triggered.</comment>
     </bits>
   </reg>

  <reg protect="r" name="int_status_h">
    <bits access="r" name="gpint_status_h" pos="NB_GPIO_INT-33:0" rst="0">
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  <reg protect="w" name="int_clr_h">
    <bits access="c" name="gpint_clr_h" pos="NB_GPIO_INT-33:0" rst="0">
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>


</module>


</archive>

<archive relative="gpt.xml">
  <module name="gpt" category="Periph">
    <reg protect="rw" name="cr">
      <bits access="rw" name="refclk_sel" pos="31" rst="1">
      </bits>
      <bits access="r" name="reserved_18" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="12" rst="0">
      </bits>
      <bits access="rw" name="tri" pos="11:9" rst="0">
        <comment>
          slave_mode trigger select
        </comment>
      </bits>
      <bits access="rw" name="arpe" pos="8" rst="1">
        <comment>
          auto preload value
        </comment>
      </bits>
      <bits access="rw" name="cms" pos="7:6" rst="0">
        <comment>
          Center-aligned mode select 00: disable , other:enable
        </comment>
      </bits>
      <bits access="rw" name="dir" pos="5" rst="0">
        <comment>
          counter dir , 0: cnt ++ , 1: cnt --
        </comment>
      </bits>
      <bits access="rw" name="opm" pos="4" rst="0">
        <comment>
          one pulse mode,  0:disable 1:enable
        </comment>
      </bits>
      <bits access="rw" name="udis" pos="3" rst="0">
        <comment>
          update disable, 0:disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="ckd" pos="2:1" rst="0">
        <comment>
          clock fdts didiver, 01: divided by 2 10:divided by 4, other:bypass
        </comment>
      </bits>
      <bits access="rw" name="cen" pos="0" rst="0">
        <comment>
          counter enable, 0: disbale, 1:enable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="smcr">
      <bits access="r" name="reserved_28" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_27" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="4" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="3" rst="0">
      </bits>
      <bits access="rw" name="sms" pos="2:0" rst="0">
        <comment>
          slave mode select: 100: slave mode, 101:gate mode, 110:trig mode, others disable
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="egr">
      <bits access="r" name="reserved_30" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_29" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_28" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_27" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_26" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_25" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_24" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_23" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="4" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="3" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="2" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="1" rst="0">
      </bits>
      <bits access="rc" name="ug" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          user trigger gen
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_oc1">
      <bits access="rw" name="oc4ce" pos="31" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc4m" pos="30:28" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc4pe" pos="27" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc4fe" pos="26" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc4s" pos="25:24" rst="1">
        <comment>
          channel source sel, bit[24] 0: output enable, 1 output disable bit[25] 0: use ti4, 1: use ti3
        </comment>
      </bits>
      <bits access="rw" name="oc3ce" pos="23" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc3m" pos="22:20" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc3pe" pos="19" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc3fe" pos="18" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc3s" pos="17:16" rst="1">
        <comment>
          channel source sel, bit[17] 0: output enable, 1 output disable bit[16] 0: use ti3, 1: use ti4
        </comment>
      </bits>
      <bits access="rw" name="oc2ce" pos="15" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc2m" pos="14:12" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc2pe" pos="11" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc2fe" pos="10" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc2s" pos="9:8" rst="1">
        <comment>
          channel source sel, bit[9] 0: output enable, 1 output disable bit[8] 0: use ti2, 1: use ti1
        </comment>
      </bits>
      <bits access="rw" name="oc1ce" pos="7" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="oc1m" pos="6:4" rst="0">
        <comment>
          output compare mode: 000: freeze, 001: when cnt eq ccr, output1, 010: when cnt eq ccr, output1 011:,when cnt eq ccr, output reversal, 100: force 0, 101: force , 110, pwm mode1, 111, pwm mode2
        </comment>
      </bits>
      <bits access="rw" name="oc1pe" pos="3" rst="0">
        <comment>
          compare value preload 0: disable, 1:enable
        </comment>
      </bits>
      <bits access="rw" name="oc1fe" pos="2" rst="0">
        <comment>
          no used yet
        </comment>
      </bits>
      <bits access="rw" name="cc1s" pos="1:0" rst="1">
        <comment>
          channel source sel, bit[0] 0: output enable, 1 output disable bit[1] 0: use ti2, 1: use ti1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccmr_ic1">
      <bits access="r" name="reserved_7" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="30" rst="0">
      </bits>
      <bits access="rw" name="ic4f" pos="29:26" rst="0">
        <comment>
          ti4 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic4psc" pos="25:24" rst="0">
        <comment>
          ti4 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="reserved_5" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="22" rst="0">
      </bits>
      <bits access="rw" name="ic3f" pos="21:18" rst="0">
        <comment>
          ti3 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic3psc" pos="17:16" rst="0">
        <comment>
          ti3 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="reserved_3" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="14" rst="0">
      </bits>
      <bits access="rw" name="ic2f" pos="13:10" rst="0">
        <comment>
          ti2 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic2psc" pos="9:8" rst="0">
        <comment>
          ti2 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
      <bits access="r" name="reserved_1" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="6" rst="0">
      </bits>
      <bits access="rw" name="ic1f" pos="5:2" rst="0">
        <comment>
          ti1 filter , 0000:bypass, 0001:clk=pclk, N=2, 0010:clk=pclk, N=4, 0011:clk=pclk, N=8,
        </comment>
      </bits>
      <bits access="rw" name="ic1psc" pos="1:0" rst="0">
        <comment>
          ti1 prescale, 01:0 div2, 10: div4, others: bypass
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ccer">
      <bits access="r" name="reserved_23" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_22" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_21" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="16" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="15" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="14" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="13" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="12" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="8" rst="0">
      </bits>
      <bits access="rw" name="cc4p" pos="7" rst="0">
        <comment>
          ti4 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc4e" pos="6" rst="0">
        <comment>
          ti4 enable
        </comment>
      </bits>
      <bits access="rw" name="cc3p" pos="5" rst="0">
        <comment>
          ti3 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc3e" pos="4" rst="0">
        <comment>
          ti3 enable
        </comment>
      </bits>
      <bits access="rw" name="cc2p" pos="3" rst="0">
        <comment>
          ti2 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc2e" pos="2" rst="0">
        <comment>
          ti2 enable
        </comment>
      </bits>
      <bits access="rw" name="cc1p" pos="1" rst="0">
        <comment>
          ti1 polarity
        </comment>
      </bits>
      <bits access="rw" name="cc1e" pos="0" rst="0">
        <comment>
          ti1 enable
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="cnt">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="r" name="cnt_value" pos="15:0" rst="0">
        <comment>
          cnt value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="psc">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="psc_value" pos="15:0" rst="0">
        <comment>
          cnt prescale value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="arr">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="arr_value" pos="15:0" rst="65535">
        <comment>
          cnt max value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr1_ic">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr1_capture" pos="15:0" rst="65535">
        <comment>
          ic1 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr2_ic">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr2_capture" pos="15:0" rst="65535">
        <comment>
          ic2 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr3_ic">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr3_capture" pos="15:0" rst="65535">
        <comment>
          ic3 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="timer_ccr4_ic">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="r" name="timer_ccr4_capture" pos="15:0" rst="65535">
        <comment>
          ic4 capture value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr1_oc">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr1_compare" pos="15:0" rst="65535">
        <comment>
          ic1 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr2_oc">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr2_compare" pos="15:0" rst="65535">
        <comment>
          ic2 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr3_oc">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr3_compare" pos="15:0" rst="65535">
        <comment>
          ic3 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="timer_ccr4_oc">
      <bits access="r" name="reserved_15" pos="31" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="30" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="timer_ccr4_compare" pos="15:0" rst="65535">
        <comment>
          ic4 compare value
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="isr">
      <bits access="r" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="reserved_21" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="16" rst="0">
      </bits>
      <bits access="r" name="capture_int" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="irsr">
      <bits access="r" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="r" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="reserved_21" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="16" rst="0">
      </bits>
      <bits access="r" name="capture_int" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="r" name="compare_int" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mask">
      <bits access="rw" name="event_update" pos="31" rst="0">
        <comment>
          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rw" name="slave_trig" pos="30" rst="0">
        <comment>
          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="reserved_21" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="16" rst="0">
      </bits>
      <bits access="rw" name="capture_int" pos="15:12" rst="0">
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="rw" name="compare_int" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clr">
      <bits access="rc" name="event_update" pos="31" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          cnt reach max when dir = 0, cnt reach zeror when dir = 1
        </comment>
      </bits>
      <bits access="rc" name="slave_trig" pos="30" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          trig gens,  when counter works in slave mode
        </comment>
      </bits>
      <bits access="r" name="reserved_21" pos="29" rst="0">
      </bits>
      <bits access="r" name="reserved_20" pos="28" rst="0">
      </bits>
      <bits access="r" name="reserved_19" pos="27" rst="0">
      </bits>
      <bits access="r" name="reserved_18" pos="26" rst="0">
      </bits>
      <bits access="r" name="reserved_17" pos="25" rst="0">
      </bits>
      <bits access="r" name="reserved_16" pos="24" rst="0">
      </bits>
      <bits access="r" name="reserved_15" pos="23" rst="0">
      </bits>
      <bits access="r" name="reserved_14" pos="22" rst="0">
      </bits>
      <bits access="r" name="reserved_13" pos="21" rst="0">
      </bits>
      <bits access="r" name="reserved_12" pos="20" rst="0">
      </bits>
      <bits access="r" name="reserved_11" pos="19" rst="0">
      </bits>
      <bits access="r" name="reserved_10" pos="18" rst="0">
      </bits>
      <bits access="r" name="reserved_9" pos="17" rst="0">
      </bits>
      <bits access="r" name="reserved_8" pos="16" rst="0">
      </bits>
      <bits access="rc" name="capture_int" pos="15:12" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="r" name="reserved_7" pos="11" rst="0">
      </bits>
      <bits access="r" name="reserved_6" pos="10" rst="0">
      </bits>
      <bits access="r" name="reserved_5" pos="9" rst="0">
      </bits>
      <bits access="r" name="reserved_4" pos="8" rst="0">
      </bits>
      <bits access="r" name="reserved_3" pos="7" rst="0">
      </bits>
      <bits access="r" name="reserved_2" pos="6" rst="0">
      </bits>
      <bits access="r" name="reserved_1" pos="5" rst="0">
      </bits>
      <bits access="r" name="reserved_0" pos="4" rst="0">
      </bits>
      <bits access="rc" name="compare_int" pos="3:0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "i2c_master.xml">

<module name="i2c_master" category="Periph">
    
    <reg protect="rw" name="CTRL">
        
 		<bits access="rw" name="EN" pos="0" rst="0">
			<comment> I2C master enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="IRQ_MASK" pos="8" rst="0">
			<comment> I2C master interrupt enable, high active. 
			</comment>
		</bits>
        
		<bits access="rw" name="Clock_Prescale" pos="31:16" rst="0xFFFF">
            <comment> This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared. <br /> <br /> Example:<br /> PCLK_MOD is 52 MHz, desired SCL is 100 KHz. <br /> Prescale = 52MHz / (5 * 100KHz) -1 = 103.
			</comment>
            <options><mask/></options>
		</bits>
	</reg>

    <reg protect="r" name="STATUS">
        
        <bits access="r" name="IRQ_Cause" pos="0" rst="0">
			<comment> IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.
			</comment>
        </bits>
        
		<bits access="r" name="IRQ_Status" pos="4" rst="0">
			<comment> IRQ status bit. 
			</comment>
        </bits>
        
		<bits access="r" name="TIP" pos="8" rst="0">
			<comment> TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.
			</comment>
		</bits>
        
		<bits access="r" name="AL" pos="12" rst="0">
			<comment> AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.
			</comment>
		</bits>
        
		<bits access="r" name="Busy" pos="16" rst="0">
			<comment> Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.
			</comment>
		</bits>
        
		<bits access="r" name="RxACK" pos="20" rst="0">
			<comment> RxACK, Received acknowledge from slave.
				'1'= "No ACK" received.
				'0'= ACK received.
			</comment>
		</bits>
        
		<bits access="r" name="writing" pos="24" rst="0">
			<comment> Register writing is in process.
				'1'= Register writing is in process.
				'0'= Register writing is done.
			</comment>
		</bits>
    </reg>
    
	<reg protect="rw" name="TXRX_BUFFER">
        
		<bits access="w" name="TX_DATA" pos="7:0" rst="-">
			<comment> Byte to transmit via I2C. <br /> for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit. <br /> '1' = reading from slave. <br /> '0' = writing to slave.   
			</comment>
		</bits>

 		<bits access="r" name="RX_DATA" pos="7:0" rst="-">
			<comment> Last byte received via I2C. 
			</comment>
		</bits>
        
	</reg>

	<reg protect="w" name="CMD">

		<bits access="w" name="ACK" pos="0" rst="0">
			<comment> ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').
			</comment>
		</bits>

		<bits access="w" name="RD" pos="4" rst="0">
			<comment> RD,read from slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STO" pos="8" rst="0">
			<comment> STO,generate stop condition, this bit is auto cleared.
			</comment>
		</bits>
        
		<bits access="w" name="WR" pos="12" rst="0">
			<comment> WR,write to slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits access="w" name="STA" pos="16" rst="0">
			<comment> STA,generate (repeated) start condition, this bit is auto cleared.
			</comment>
		</bits>
    </reg>

  	<reg protect="rw" name="IRQ_CLR">  
        
		<bits access="c" name="IRQ_Clr" pos="0" rst="0">
			<comment> When write '1', clears a pending I2C interrupt.
			</comment>
        </bits>
    </reg>
    

</module>
</archive>

<archive relative = "i2s.xml">
  <module name="i2s" category="Periph">
    <reg protect="rw" name="i2s_ctrl">
      <bits access="rw" name="rx_int_sel" pos="20:19" rst="0">
      </bits>
      <bits access="rw" name="tx_int_sel" pos="18:17" rst="0">
      </bits>
      <bits access="rw" name="rx_swap" pos="16" rst="0">
      </bits>
      <bits access="rw" name="tx_swap" pos="15" rst="0">
      </bits>
      <bits access="rw" name="bclk_lrck_ratio" pos="14:12" rst="0">
      </bits>
      <bits access="rw" name="bit_delay" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="word_length" pos="9:8" rst="0">
      </bits>
      <bits access="rw" name="audio_mode" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="lrck_pol" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bclk_pol" pos="4" rst="0">
      </bits>
      <bits access="rw" name="ctrl_mode" pos="3" rst="0">
      </bits>
      <bits access="rw" name="dma_mode" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rx_enable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="tx_enable" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:21" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_fifo_ctrl">
      <bits access="rw" name="rx_fifo_clr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="tx_fifo_clr" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:2" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_data">
      <bits access="rw" name="txrx_data" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="i2s_status">
      <bits access="r" name="tx_active" pos="6" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_level" pos="5:3" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_level" pos="2:0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_int_en">
      <bits access="rw" name="slv_err_en" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rx_fifo_almost_full_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="rx_fifo_full_en" pos="4" rst="0">
      </bits>
      <bits access="rw" name="tx_fifo_almost_empty_en" pos="3" rst="0">
      </bits>
      <bits access="rw" name="tx_fifo_empty_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="dma_rx_done_en" pos="1" rst="0">
      </bits>
      <bits access="rw" name="dma_tx_done_en" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>                            
    <reg protect="r" name="i2s_int_status">
      <bits access="rw" name="slv_err" pos="6" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_full" pos="5" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_empty" pos="4" rst="1">
      </bits>
      <bits access="r" name="rx_fifo_nempty" pos="3" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_nfull" pos="2" rst="1">
      </bits>
      <bits access="r" name="dma_rx_done" pos="1" rst="0">
      </bits>
      <bits access="r" name="dma_tx_done" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="i2s_int_cause">
      <bits access="rw" name="slv_err_int" pos="6" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_almost_full_int" pos="5" rst="0">
      </bits>
      <bits access="r" name="rx_fifo_full_int" pos="4" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_almost_empty_int" pos="3" rst="0">
      </bits>
      <bits access="r" name="tx_fifo_empty_int" pos="2" rst="0">
      </bits>
      <bits access="r" name="dma_rx_done_int" pos="1" rst="0">
      </bits>
      <bits access="r" name="dma_tx_done_int" pos="0" rst="0">
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="i2s_int_clr">
      <bits access="rw" name="slv_err_clr" pos="6" rst="0">
      </bits>
      <bits access="rc" name="rx_fifo_almost_full_clr" pos="5" rst="0">
      </bits>
      <bits access="rc" name="rx_fifo_full_clr" pos="4" rst="0">
      </bits>
      <bits access="rc" name="tx_fifo_almost_empty_clr" pos="3" rst="0">
      </bits>
      <bits access="rc" name="tx_fifo_empty_clr" pos="2" rst="0">
      </bits>
      <bits access="rc" name="dma_rx_done_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="dma_tx_done_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="reserved" pos="31:7" rst="0">
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "iomux.xml">
<module name="iomux" category="System">
  
 

  <reg name="pad_GPIO_0_cfg" protect="rw">
     <bits name="pad_GPIO_0_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_0 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_0_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_0_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_0 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_0_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_0 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_0_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_0_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_0 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_0 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_0 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_0 select</comment>
     <options>
            <option name="fun_GPIO_0_sel" value ="0"></option>
            <option name="fun_LPUART_RXD_sel" value ="1"></option>
            <option name="fun_UART3_RXD_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_1_cfg" protect="rw">
     <bits name="pad_GPIO_1_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_1 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_1_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_1_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_1 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_1_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_1 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_1_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_1_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_1 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_1 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_1 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_1 select</comment>
     <options>
            <option name="fun_GPIO_1_sel" value ="0"></option>
            <option name="fun_LPUART_TXD_sel" value ="1"></option>
            <option name="fun_UART3_TXD_sel" value ="2"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_2_cfg" protect="rw">
     <bits name="pad_GPIO_2_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_2 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_2_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_2 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_2_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_2 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_2_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_2 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_2_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_2 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_2_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_2 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_2_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_2 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_2_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_2 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_2_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_2 select</comment>
     <options>
            <option name="fun_GPIO_2_sel" value ="0"></option>
            <option name="fun_GPT_TI_0_sel" value ="1"></option>
            <option name="fun_UART3_CTS_sel" value ="2"></option>
            <option name="fun_PWM_0_sel" value ="3"></option>
            <option name="fun_adi_data_0_sel" value ="5"></option>
            <option name="fun_EJ_TCK_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_3_cfg" protect="rw">
     <bits name="pad_GPIO_3_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_3 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_3_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_3 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_3_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_3 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_3_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_3 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_3_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_3 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_3_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_3 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_3_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_3 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_3_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_3 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_3_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_3 select</comment>
     <options>
            <option name="fun_GPIO_3_sel" value ="0"></option>
            <option name="fun_GPT_TI_1_sel" value ="1"></option>
            <option name="fun_UART3_RTS_sel" value ="2"></option>
            <option name="fun_PWM_1_sel" value ="3"></option>
            <option name="fun_adi_data_1_sel" value ="5"></option>
            <option name="fun_EJ_TMS_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_4_cfg" protect="rw">
     <bits name="pad_GPIO_4_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_4 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_4_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_4 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_4_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_4 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_4_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_4 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_4_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_4 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_4_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_4 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_4_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_4 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_4_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_4 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_4_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_4 select</comment>
     <options>
            <option name="fun_GPIO_4_sel" value ="0"></option>
            <option name="fun_SPI2_CLK_sel" value ="1"></option>
            <option name="fun_PWM_2_sel" value ="3"></option>
            <option name="fun_I2S_BCLK_sel" value ="4"></option>
            <option name="fun_adi_data_2_sel" value ="5"></option>
            <option name="fun_EJ_TDI_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_5_cfg" protect="rw">
     <bits name="pad_GPIO_5_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_5 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_5_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_5 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_5_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_5 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_5_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_5 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_5_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_5 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_5_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_5 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_5_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_5 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_5_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_5 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_5_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_5 select</comment>
     <options>
            <option name="fun_GPIO_5_sel" value ="0"></option>
            <option name="fun_SPI2_CS_sel" value ="1"></option>
            <option name="fun_PWM_3_sel" value ="3"></option>
            <option name="fun_I2S_LRCK_sel" value ="4"></option>
            <option name="fun_adi_data_3_sel" value ="5"></option>
            <option name="fun_EJ_TDO_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_6_cfg" protect="rw">
     <bits name="pad_GPIO_6_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_6 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_6_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_6 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_6_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_6 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_6_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_6 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_6_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_6 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_6_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_6 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_6_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_6 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_6_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_6 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_6_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_6 select</comment>
     <options>
            <option name="fun_GPIO_6_sel" value ="0"></option>
            <option name="fun_SPI2_DI_0_sel" value ="1"></option>
            <option name="fun_PWM_4_sel" value ="3"></option>
            <option name="fun_I2S_DI_sel" value ="4"></option>
            <option name="fun_adi_data_4_sel" value ="5"></option>
            <option name="fun_EJ_TRST_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_7_cfg" protect="rw">
     <bits name="pad_GPIO_7_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_7 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_7_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_7 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_7_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_7 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_7_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_7 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_7_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_7 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_7_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_7 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_7_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_7 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_7_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_7 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_7_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_7 select</comment>
     <options>
            <option name="fun_GPIO_7_sel" value ="0"></option>
            <option name="fun_SPI2_DI_1_sel" value ="1"></option>
            <option name="fun_TCO_0_sel" value ="2"></option>
            <option name="fun_PWM_5_sel" value ="3"></option>
            <option name="fun_I2S_DO_sel" value ="4"></option>
            <option name="fun_adi_data_5_sel" value ="5"></option>
            <option name="fun_SWV_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_8_cfg" protect="rw">
     <bits name="pad_GPIO_8_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_8 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_8_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_8 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_8_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_8 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_8_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_8 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_8_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_8 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_8_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_8 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_8_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_8 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_8_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_8 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_8_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_8 select</comment>
     <options>
            <option name="fun_GPIO_8_sel" value ="0"></option>
            <option name="fun_UART1_RXD_sel" value ="1"></option>
            <option name="fun_SEGOUT_0_sel" value ="6"></option>
            <option name="fun_DBG_DO_0_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_9_cfg" protect="rw">
     <bits name="pad_GPIO_9_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_9 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_9_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_9 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_9_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_9 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_9_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_9 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_9_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_9 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_9_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_9 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_9_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_9 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_9_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_9 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_9_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_9 select</comment>
     <options>
            <option name="fun_GPIO_9_sel" value ="0"></option>
            <option name="fun_UART1_TXD_sel" value ="1"></option>
            <option name="fun_SEGOUT_1_sel" value ="6"></option>
            <option name="fun_DBG_DO_1_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_10_cfg" protect="rw">
     <bits name="pad_GPIO_10_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_10 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_10_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_10 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_10_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_10 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_10_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_10 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_10_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_10 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_10_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_10 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_10_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_10 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_10_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_10 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_10_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_10 select</comment>
     <options>
            <option name="fun_GPIO_10_sel" value ="0"></option>
            <option name="fun_UART1_CTS_sel" value ="1"></option>
            <option name="fun_TCO_2_sel" value ="2"></option>
            <option name="fun_GPT_TI_2_sel" value ="3"></option>
            <option name="fun_SEGOUT_2_sel" value ="6"></option>
            <option name="fun_DBG_DO_2_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_11_cfg" protect="rw">
     <bits name="pad_GPIO_11_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_11 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_11_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_11 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_11_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_11 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_11_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_11 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_11_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_11 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_11_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_11 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_11_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_11 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_11_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_11 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_11_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_11 select</comment>
     <options>
            <option name="fun_GPIO_11_sel" value ="0"></option>
            <option name="fun_UART1_RTS_sel" value ="1"></option>
            <option name="fun_TCO_3_sel" value ="2"></option>
            <option name="fun_GPT_TI_3_sel" value ="3"></option>
            <option name="fun_SEGOUT_3_sel" value ="6"></option>
            <option name="fun_DBG_DO_3_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_12_cfg" protect="rw">
     <bits name="pad_GPIO_12_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_12 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_12_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_12 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_12_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_12 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_12_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_12 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_12_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_12 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_12_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_12 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_12_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_12 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_12_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_12 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_12_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_12 select</comment>
     <options>
            <option name="fun_GPIO_12_sel" value ="0"></option>
            <option name="fun_UART2_RXD_sel" value ="1"></option>
            <option name="fun_adi_data_6_sel" value ="5"></option>
            <option name="fun_SEGOUT_4_sel" value ="6"></option>
            <option name="fun_DBG_DO_4_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_13_cfg" protect="rw">
     <bits name="pad_GPIO_13_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_13 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_13_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_13 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_13_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_13 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_13_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_13 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_13_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_13 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_13_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_13 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_13_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_13 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_13_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_13 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_13_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_13 select</comment>
     <options>
            <option name="fun_GPIO_13_sel" value ="0"></option>
            <option name="fun_UART2_TXD_sel" value ="1"></option>
            <option name="fun_adi_data_7_sel" value ="5"></option>
            <option name="fun_SEGOUT_5_sel" value ="6"></option>
            <option name="fun_DBG_DO_5_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_14_cfg" protect="rw">
     <bits name="pad_GPIO_14_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_14 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_14_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_14 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_14_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_14 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_14_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_14 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_14_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_14 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_14_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_14 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_14_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_14 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_14_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_14 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_14_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_14 select</comment>
     <options>
            <option name="fun_GPIO_14_sel" value ="0"></option>
            <option name="fun_UART2_CTS_sel" value ="1"></option>
            <option name="fun_I2C2_SCL_sel" value ="2"></option>
            <option name="fun_PWM_0_sel" value ="3"></option>
            <option name="fun_GPT_TI_4_sel" value ="4"></option>
            <option name="fun_adi_data_8_sel" value ="5"></option>
            <option name="fun_SEGOUT_6_sel" value ="6"></option>
            <option name="fun_DBG_DO_6_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_15_cfg" protect="rw">
     <bits name="pad_GPIO_15_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_15 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_15_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_15 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_15_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_15 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_15_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_15 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_15_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_15 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_15_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_15 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_15_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_15 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_15_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_15 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_15_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_15 select</comment>
     <options>
            <option name="fun_GPIO_15_sel" value ="0"></option>
            <option name="fun_UART2_RTS_sel" value ="1"></option>
            <option name="fun_I2C2_SDA_sel" value ="2"></option>
            <option name="fun_PWM_1_sel" value ="3"></option>
            <option name="fun_GPT_TI_5_sel" value ="4"></option>
            <option name="fun_adi_data_9_sel" value ="5"></option>
            <option name="fun_SEGOUT_7_sel" value ="6"></option>
            <option name="fun_DBG_DO_7_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_16_cfg" protect="rw">
     <bits name="pad_GPIO_16_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_16 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_16_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_16 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_16_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_16 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_16_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_16 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_16_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_16 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_16_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_16 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_16_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_16 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_16_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_16 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_16_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_16 select</comment>
     <options>
            <option name="fun_GPIO_16_sel" value ="0"></option>
            <option name="fun_UART3_RXD_sel" value ="1"></option>
            <option name="fun_PWM_2_sel" value ="3"></option>
            <option name="fun_I2S_BCLK_sel" value ="4"></option>
            <option name="fun_adi_data_10_sel" value ="5"></option>
            <option name="fun_SEGOUT_8_sel" value ="6"></option>
            <option name="fun_DBG_DO_8_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_17_cfg" protect="rw">
     <bits name="pad_GPIO_17_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_17 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_17_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_17 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_17_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_17 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_17_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_17 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_17_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_17 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_17_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_17 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_17_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_17 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_17_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_17 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_17_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_17 select</comment>
     <options>
            <option name="fun_GPIO_17_sel" value ="0"></option>
            <option name="fun_UART3_TXD_sel" value ="1"></option>
            <option name="fun_PWM_3_sel" value ="3"></option>
            <option name="fun_I2S_LRCK_sel" value ="4"></option>
            <option name="fun_adi_data_11_sel" value ="5"></option>
            <option name="fun_SEGOUT_9_sel" value ="6"></option>
            <option name="fun_DBG_DO_9_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_18_cfg" protect="rw">
     <bits name="pad_GPIO_18_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_18 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_18_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_18 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_18_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_18 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_18_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_18 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_18_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_18 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_18_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_18 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_18_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_18 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_18_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_18 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_18_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_18 select</comment>
     <options>
            <option name="fun_GPIO_18_sel" value ="0"></option>
            <option name="fun_UART3_CTS_sel" value ="1"></option>
            <option name="fun_I2C3_SCL_sel" value ="2"></option>
            <option name="fun_PWM_4_sel" value ="3"></option>
            <option name="fun_I2S_DI_sel" value ="4"></option>
            <option name="fun_adi_data_12_sel" value ="5"></option>
            <option name="fun_SEGOUT_10_sel" value ="6"></option>
            <option name="fun_DBG_DO_10_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_19_cfg" protect="rw">
     <bits name="pad_GPIO_19_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_19 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_19_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_19 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_19_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_19 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_19_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_19 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_19_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_19 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_19_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_19 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_19_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_19 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_19_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_19 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_19_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_19 select</comment>
     <options>
            <option name="fun_GPIO_19_sel" value ="0"></option>
            <option name="fun_UART3_RTS_sel" value ="1"></option>
            <option name="fun_I2C3_SDA_sel" value ="2"></option>
            <option name="fun_PWM_5_sel" value ="3"></option>
            <option name="fun_I2S_DO_sel" value ="4"></option>
            <option name="fun_adi_data_13_sel" value ="5"></option>
            <option name="fun_SEGOUT_11_sel" value ="6"></option>
            <option name="fun_DBG_DO_11_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_20_cfg" protect="rw">
     <bits name="pad_GPIO_20_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_20 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_20_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_20 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_20_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_20 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_20_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_20 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_20_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_20 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_20_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_20 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_20_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_20 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_20_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_20 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_20_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_20 select</comment>
     <options>
            <option name="fun_GPIO_20_sel" value ="0"></option>
            <option name="fun_SPI1_CLK_sel" value ="1"></option>
            <option name="fun_KEYIN_0_sel" value ="2"></option>
            <option name="fun_TCO_2_sel" value ="4"></option>
            <option name="fun_adi_data_14_sel" value ="5"></option>
            <option name="fun_SEGOUT_12_sel" value ="6"></option>
            <option name="fun_DBG_DO_12_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_21_cfg" protect="rw">
     <bits name="pad_GPIO_21_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_21 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_21_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_21 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_21_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_21 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_21_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_21 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_21_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_21 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_21_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_21 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_21_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_21 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_21_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_21 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_21_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_21 select</comment>
     <options>
            <option name="fun_GPIO_21_sel" value ="0"></option>
            <option name="fun_SPI1_CS_sel" value ="1"></option>
            <option name="fun_KEYIN_1_sel" value ="2"></option>
            <option name="fun_TCO_3_sel" value ="4"></option>
            <option name="fun_adi_data_15_sel" value ="5"></option>
            <option name="fun_SEGOUT_13_sel" value ="6"></option>
            <option name="fun_DBG_DO_13_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_22_cfg" protect="rw">
     <bits name="pad_GPIO_22_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_22 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_22_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_22 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_22_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_22 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_22_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_22 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_22_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_22 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_22_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_22 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_22_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_22 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_22_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_22 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_22_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_22 select</comment>
     <options>
            <option name="fun_GPIO_22_sel" value ="0"></option>
            <option name="fun_SPI1_DI_0_sel" value ="1"></option>
            <option name="fun_KEYOUT_0_sel" value ="2"></option>
            <option name="fun_adi_rx_clk_sel" value ="5"></option>
            <option name="fun_SEGOUT_14_sel" value ="6"></option>
            <option name="fun_DBG_DO_14_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_23_cfg" protect="rw">
     <bits name="pad_GPIO_23_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_23 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_23_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_23 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_23_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_23 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_23_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_23 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_23_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_23 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_23_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_23 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_23_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_23 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_23_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_23 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_23_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_23 select</comment>
     <options>
            <option name="fun_GPIO_23_sel" value ="0"></option>
            <option name="fun_SPI1_DI_1_sel" value ="1"></option>
            <option name="fun_KEYOUT_1_sel" value ="2"></option>
            <option name="fun_TCO_1_sel" value ="3"></option>
            <option name="fun_adi_tx_clk_sel" value ="5"></option>
            <option name="fun_SEGOUT_15_sel" value ="6"></option>
            <option name="fun_DBG_DO_15_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_24_cfg" protect="rw">
     <bits name="pad_GPIO_24_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_24 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_24_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_24 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_24_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_24 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_24_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_24 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_24_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_24 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_24_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_24 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_24_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_24 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_24_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_24 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_24_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_24 select</comment>
     <options>
            <option name="fun_GPIO_24_sel" value ="0"></option>
            <option name="fun_I2C1_SCL_sel" value ="1"></option>
            <option name="fun_GPT_TI_6_sel" value ="4"></option>
            <option name="fun_adi_rx_frame_sel" value ="5"></option>
            <option name="fun_SEGOUT_16_sel" value ="6"></option>
            <option name="fun_DBG_TRIG_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_25_cfg" protect="rw">
     <bits name="pad_GPIO_25_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_25 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_25_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_25 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_25_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_25 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_25_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_25 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_25_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_25 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_25_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_25 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_25_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_25 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_25_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_25 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_25_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_25 select</comment>
     <options>
            <option name="fun_GPIO_25_sel" value ="0"></option>
            <option name="fun_I2C1_SDA_sel" value ="1"></option>
            <option name="fun_GPT_TI_7_sel" value ="4"></option>
            <option name="fun_adi_tx_frame_sel" value ="5"></option>
            <option name="fun_SEGOUT_17_sel" value ="6"></option>
            <option name="fun_DBG_CLK_sel" value ="7"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_26_cfg" protect="rw">
     <bits name="pad_GPIO_26_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_26 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_26_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_26 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_26_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_26 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_26_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_26 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_26_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_26 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_26_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_26 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_26_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_26 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_26_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_26 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_26_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_26 select</comment>
     <options>
            <option name="fun_GPIO_26_sel" value ="0"></option>
            <option name="fun_SDMMC2_CLK_sel" value ="1"></option>
            <option name="fun_UART2_CTS_sel" value ="2"></option>
            <option name="fun_PWM_6_sel" value ="3"></option>
            <option name="fun_TCO_0_sel" value ="4"></option>
            <option name="fun_adi_resetb_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_27_cfg" protect="rw">
     <bits name="pad_GPIO_27_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_27 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_27_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_27 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_27_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_27 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_27_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_27 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_27_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_27 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_27_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_27 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_27_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_27 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_27_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_27 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_27_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_27 select</comment>
     <options>
            <option name="fun_GPIO_27_sel" value ="0"></option>
            <option name="fun_SDMMC2_CMD_sel" value ="1"></option>
            <option name="fun_UART2_RTS_sel" value ="2"></option>
            <option name="fun_PWM_7_sel" value ="3"></option>
            <option name="fun_TCO_1_sel" value ="4"></option>
            <option name="fun_adi_enable_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_28_cfg" protect="rw">
     <bits name="pad_GPIO_28_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_28 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_28_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_28 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_28_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_28 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_28_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_28 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_28_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_28 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_28_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_28 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_28_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_28 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_28_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_28 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_28_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_28 select</comment>
     <options>
            <option name="fun_GPIO_28_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_0_sel" value ="1"></option>
            <option name="fun_SPI2_CLK_sel" value ="2"></option>
            <option name="fun_CLKO_0_sel" value ="3"></option>
            <option name="fun_KEYIN_2_sel" value ="4"></option>
            <option name="fun_adi_txnrx_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_29_cfg" protect="rw">
     <bits name="pad_GPIO_29_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_29 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_29_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_29 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_29_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_29 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_29_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_29 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_29_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_29 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_29_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_29 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_29_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_29 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_29_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_29 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_29_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_29 select</comment>
     <options>
            <option name="fun_GPIO_29_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_1_sel" value ="1"></option>
            <option name="fun_SPI2_CS_sel" value ="2"></option>
            <option name="fun_CLKO_1_sel" value ="3"></option>
            <option name="fun_KEYIN_3_sel" value ="4"></option>
            <option name="fun_m_rfspi_clk_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_30_cfg" protect="rw">
     <bits name="pad_GPIO_30_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_30 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_30_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_30 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_30_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_30 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_30_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_30 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_30_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_30 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_30_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_30 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_30_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_30 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_30_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_30 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_30_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_30 select</comment>
     <options>
            <option name="fun_GPIO_30_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_2_sel" value ="1"></option>
            <option name="fun_SPI2_DI_0_sel" value ="2"></option>
            <option name="fun_CLKO_2_sel" value ="3"></option>
            <option name="fun_KEYOUT_2_sel" value ="4"></option>
            <option name="fun_m_rfspi_cs_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_GPIO_31_cfg" protect="rw">
     <bits name="pad_GPIO_31_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>GPIO_31 RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_GPIO_31_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>GPIO_31 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_GPIO_31_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>GPIO_31 PUll up</comment>
     </bits>
     <bits name="pad_GPIO_31_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>GPIO_31 PUll down</comment>
     </bits>
     <bits name="pad_GPIO_31_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>GPIO_31 force enable for outoen. </comment>
     </bits>
     <bits name="pad_GPIO_31_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>GPIO_31 force outoen value. </comment>
     </bits>
     <bits name="pad_GPIO_31_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>GPIO_31 force output value for output. </comment>
     </bits>
     <bits name="pad_GPIO_31_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>GPIO_31 pin output value. </comment>
     </bits>
     <bits name="pad_GPIO_31_sel" pos="3:0" access="rw" rst="0"> 
         <comment>GPIO_31 select</comment>
     <options>
            <option name="fun_GPIO_31_sel" value ="0"></option>
            <option name="fun_SDMMC2_DAT_3_sel" value ="1"></option>
            <option name="fun_SPI2_DI_1_sel" value ="2"></option>
            <option name="fun_CLKO_3_sel" value ="3"></option>
            <option name="fun_KEYOUT_3_sel" value ="4"></option>
            <option name="fun_m_rfspi_dio_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_HST_RXD_cfg" protect="rw">
     <bits name="pad_HST_RXD_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>HST_RXD RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_HST_RXD_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>HST_RXD force enable for pu/pd </comment>
     </bits>
     <bits name="pad_HST_RXD_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>HST_RXD PUll up</comment>
     </bits>
     <bits name="pad_HST_RXD_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>HST_RXD PUll down</comment>
     </bits>
     <bits name="pad_HST_RXD_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>HST_RXD force enable for outoen. </comment>
     </bits>
     <bits name="pad_HST_RXD_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>HST_RXD force outoen value. </comment>
     </bits>
     <bits name="pad_HST_RXD_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>HST_RXD force output value for output. </comment>
     </bits>
     <bits name="pad_HST_RXD_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>HST_RXD pin output value. </comment>
     </bits>
     <bits name="pad_HST_RXD_sel" pos="3:0" access="rw" rst="0"> 
         <comment>HST_RXD select</comment>
     <options>
            <option name="fun_HST_RXD_sel" value ="0"></option>
            <option name="fun_GPIO_32_sel" value ="1"></option>
            <option name="fun_SPI2_CLK_sel" value ="2"></option>
            <option name="fun_UART3_RXD_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_HST_TXD_cfg" protect="rw">
     <bits name="pad_HST_TXD_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>HST_TXD RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_HST_TXD_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>HST_TXD force enable for pu/pd </comment>
     </bits>
     <bits name="pad_HST_TXD_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>HST_TXD PUll up</comment>
     </bits>
     <bits name="pad_HST_TXD_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>HST_TXD PUll down</comment>
     </bits>
     <bits name="pad_HST_TXD_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>HST_TXD force enable for outoen. </comment>
     </bits>
     <bits name="pad_HST_TXD_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>HST_TXD force outoen value. </comment>
     </bits>
     <bits name="pad_HST_TXD_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>HST_TXD force output value for output. </comment>
     </bits>
     <bits name="pad_HST_TXD_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>HST_TXD pin output value. </comment>
     </bits>
     <bits name="pad_HST_TXD_sel" pos="3:0" access="rw" rst="0"> 
         <comment>HST_TXD select</comment>
     <options>
            <option name="fun_HST_TXD_sel" value ="0"></option>
            <option name="fun_GPIO_33_sel" value ="1"></option>
            <option name="fun_SPI2_CS_sel" value ="2"></option>
            <option name="fun_UART3_TXD_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SWCLK_cfg" protect="rw">
     <bits name="pad_SWCLK_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>SWCLK RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_SWCLK_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SWCLK force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SWCLK_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SWCLK PUll up</comment>
     </bits>
     <bits name="pad_SWCLK_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SWCLK PUll down</comment>
     </bits>
     <bits name="pad_SWCLK_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SWCLK force enable for outoen. </comment>
     </bits>
     <bits name="pad_SWCLK_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SWCLK force outoen value. </comment>
     </bits>
     <bits name="pad_SWCLK_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SWCLK force output value for output. </comment>
     </bits>
     <bits name="pad_SWCLK_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SWCLK pin output value. </comment>
     </bits>
     <bits name="pad_SWCLK_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SWCLK select</comment>
     <options>
            <option name="fun_SWCLK_sel" value ="0"></option>
            <option name="fun_GPIO_34_sel" value ="1"></option>
            <option name="fun_SPI2_DI_0_sel" value ="2"></option>
            <option name="fun_UART3_CTS_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SWDIO_cfg" protect="rw">
     <bits name="pad_SWDIO_res_sel" pos="17:16" access="rw" rst="0x0"> 
         <comment>SWDIO RESISTOR_SEL</comment>
     </bits>
     <bits name="pad_SWDIO_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SWDIO force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SWDIO_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SWDIO PUll up</comment>
     </bits>
     <bits name="pad_SWDIO_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SWDIO PUll down</comment>
     </bits>
     <bits name="pad_SWDIO_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SWDIO force enable for outoen. </comment>
     </bits>
     <bits name="pad_SWDIO_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SWDIO force outoen value. </comment>
     </bits>
     <bits name="pad_SWDIO_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SWDIO force output value for output. </comment>
     </bits>
     <bits name="pad_SWDIO_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SWDIO pin output value. </comment>
     </bits>
     <bits name="pad_SWDIO_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SWDIO select</comment>
     <options>
            <option name="fun_SWDIO_sel" value ="0"></option>
            <option name="fun_GPIO_35_sel" value ="1"></option>
            <option name="fun_SPI2_DI_1_sel" value ="2"></option>
            <option name="fun_UART3_RTS_sel" value ="3"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_CLK_0_cfg" protect="rw">
     <bits name="pad_SIM_CLK_0_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 PUll up</comment>
     </bits>
     <bits name="pad_SIM_CLK_0_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 PUll down</comment>
     </bits>
     <bits name="pad_SIM_CLK_0_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_CLK_0 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_CLK_0 select</comment>
     <options>
            <option name="fun_SIM_CLK_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_RST_0_cfg" protect="rw">
     <bits name="pad_SIM_RST_0_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_RST_0_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 PUll up</comment>
     </bits>
     <bits name="pad_SIM_RST_0_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 PUll down</comment>
     </bits>
     <bits name="pad_SIM_RST_0_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_RST_0 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_RST_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_RST_0 select</comment>
     <options>
            <option name="fun_SIM_RST_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_DIO_0_cfg" protect="rw">
     <bits name="pad_SIM_DIO_0_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 PUll up</comment>
     </bits>
     <bits name="pad_SIM_DIO_0_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 PUll down</comment>
     </bits>
     <bits name="pad_SIM_DIO_0_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_DIO_0 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_0_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_DIO_0 select</comment>
     <options>
            <option name="fun_SIM_DIO_0_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_CLK_1_cfg" protect="rw">
     <bits name="pad_SIM_CLK_1_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 PUll up</comment>
     </bits>
     <bits name="pad_SIM_CLK_1_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 PUll down</comment>
     </bits>
     <bits name="pad_SIM_CLK_1_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_CLK_1 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_CLK_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_CLK_1 select</comment>
     <options>
            <option name="fun_SIM_CLK_1_sel" value ="0"></option>
            <option name="fun_GPIO_36_sel" value ="1"></option>
            <option name="fun_TCO_0_sel" value ="2"></option>
            <option name="fun_PWM_0_sel" value ="3"></option>
            <option name="fun_TCO_2_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_RST_1_cfg" protect="rw">
     <bits name="pad_SIM_RST_1_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_RST_1_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 PUll up</comment>
     </bits>
     <bits name="pad_SIM_RST_1_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 PUll down</comment>
     </bits>
     <bits name="pad_SIM_RST_1_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_RST_1 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_RST_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_RST_1 select</comment>
     <options>
            <option name="fun_SIM_RST_1_sel" value ="0"></option>
            <option name="fun_GPIO_37_sel" value ="1"></option>
            <option name="fun_TCO_1_sel" value ="2"></option>
            <option name="fun_PWM_4_sel" value ="3"></option>
            <option name="fun_TCO_3_sel" value ="5"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
  <reg name="pad_SIM_DIO_1_cfg" protect="rw">
     <bits name="pad_SIM_DIO_1_pull_frc" pos="14" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force enable for pu/pd </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_pull_dn" pos="13" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 PUll up</comment>
     </bits>
     <bits name="pad_SIM_DIO_1_pull_up" pos="12" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 PUll down</comment>
     </bits>
     <bits name="pad_SIM_DIO_1_oen_frc" pos="9" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force enable for outoen. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_oen_reg" pos="8" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force outoen value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_out_frc" pos="5" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 force output value for output. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_out_reg" pos="4" access="rw" rst="0x0"> 
         <comment>SIM_DIO_1 pin output value. </comment>
     </bits>
     <bits name="pad_SIM_DIO_1_sel" pos="3:0" access="rw" rst="0"> 
         <comment>SIM_DIO_1 select</comment>
     <options>
            <option name="fun_SIM_DIO_1_sel" value ="0"></option>
            <mask/><shift/><default/>
     </options>
     </bits>
  </reg>
   </module>
</archive>


<archive relative = "itlv.xml">

<include file="globals.xml"/>

<module name="itlv" category="Baseband">
  <reg name="command" protect="rw">
    <bits access="rw" name="nb_bits" pos="30:20" rst="0x0">
      <comment>Number of bits to be (De)Interleaved.</comment>
    </bits>

    <bits access="rw" name="burst_offset" pos="12:8" rst="0x0">
      <comment>This value gives the write offset (in number of bursts) to be
      added to a Burst Base address (ignored for Type 1b). For normal
      operation, this offset should be even (lsb will be ignored).</comment>
    </bits>

    <bits access="rw" name="itlv_type" pos="7:4" rst="0x0">
      <comment>Selects (de-)interleaving type.</comment>
            <options>
                <option name="TYPE_1A" value="0">
                    <comment>TCH/FS, TCH/EFS, FACCH/F, TCH/F2.4, TCH/AFS (speech, ratscch, sid_first)</comment>
                </option>
                <option name="TYPE_1B" value="1">
                    <comment>SACCH, TCH/AFS(sid_update), PDTCH(CS-1 to CS-4), BCCH, PCH, AGCH, PACCH, PBCCH, PAGCH, PPCH, PNCH, PTCCH/D</comment>
                </option>
                <option name="TYPE_1C" value="2">
                    <comment>FACCH/H</comment>
                </option>
                <option name="TYPE_2A" value="3">
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name="TYPE_2B" value="4">
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name="TYPE_3" value="5">
                    <comment>TCH/F14.4, TCH/F9.6, TCH/F4.8, TCH/H4.8, and TCH/H2.4</comment>
                </option>
                <default/>
                <mask/>
                <shift/>
            </options>
    </bits>

    <bits access="rw" name="int_mask" pos="3" rst="0x0">
      <comment>Sets the interrupt mask ('1': interruption enabled)</comment>
    </bits>

    <bits access="rw" name="ditlv_start" pos="1" rst="0x0">
      <comment>Starts the de-interleaving process.</comment>
    </bits>

    <bits access="rw" name="itlv_start" pos="0" rst="0x0">
      <comment>Starts the interleaving process.</comment>
    </bits>
  </reg>

  <reg name="status" protect="r">
    <bits access="r" name="busy" pos="0" rst="0x0">
      <comment>This bit is high when a (de-)interleaving process is ongoing. It
      stays high if the module is stalled during operation.</comment>
    </bits>
  </reg>

  <reg name="burst_base" protect="rw">
    <bits access="rw" name="burst_base" pos="BB_SRAM_ADDR_WIDTH+1:4" rst="0x0">
      <comment>This is the start address of the burst buffer in SRAM
      </comment>
    </bits>
  </reg>

  <reg name="frame_base" protect="rw">
    <bits access="rw" name="frame_base" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the frame buffer in
      SRAM.</comment>
    </bits>
  </reg>

  <reg name="int_status" protect="r">
    <bits access="r" name="it_status" pos="16" rst="0x0">
      <comment>This bit is the unmasked version of the IT_CAUSE bit.</comment>
    </bits>

    <bits access="r" name="it_cause" pos="0" rst="0x0">
      <comment>This bit is set when the ITLV module finishes an ongoing
      operation. It can be masked by setting ITLV_CMD(IT_MASK) to '1'.
      Resetting this bit is done by writing in IT_CLEAR register. IT_CAUSE is
      the image of the ITLV_DONE_H interrupt line to the CPU. </comment>
    </bits>
  </reg>

  <reg name="int_clear" protect="w">
    <bits access="w" name="it_clear" pos="0" rst="0x0">
      <comment>Setting this bit to '1' resets the Interleaver's
      interrupt.</comment>
    </bits>
  </reg>
</module>

</archive>

<archive relative = "keypad.xml">
<module name="keypad" category="Periph">
  <var name="KEY_NB" value="64">
    <comment> Number of key in the keypad
    </comment>
  </var>
  <var name="LOW_KEY_NB" value="32">
    <comment> Number of key in the low data register 
    </comment>
  </var>
  <var name="HIGH_KEY_NB" value="32">
    <comment> Number of key in the high data register
    </comment>
  </var>

  <reg protect="r" name="KP_DATA_L">
    <bits access="r" name="KP_DATA_L" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 0 to 3) and in line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_L(Idx_KeyOut*8+Idx_KeyIn) :<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_DATA_H">
    <bits access="r" name="KP_DATA_H" pos="31:0" rst="0">
      <comment>For keys in column Idx_KeyOut(from 4 to 7) and line Idx_KeyIn(from 0 to 7), the pressing status are stored in KP_DATA_H(Idx_KeyIn*8-32+Idx_KeyIn):<br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg protect="r" name="KP_STATUS">

    <bits access="r" name="KEYIN_STATUS" pos="7:0" rst="0x08">
      <comment>For keys in lines status <br />0 = Released<br />1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
  </bits>

    <bits access="r" name="KP_ON" pos="31" rst="0">
      <comment>Indicate Key ON pressing status :<br />0 = Release<br />1 = Pressed
      </comment>
      <options><default/><mask/><shift/></options>
    </bits>

  </reg>

  
  <reg protect="rw" name="KP_CTRL">
    <bits access="rw" name="KP_En" pos="0" rst="0">
        <comment>This bit enables key detection. If this bit is '0', the key detection function 
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.<br />
        <br />0 = keypad disable<br />1 = keypad enable  
      </comment>
    </bits>
   
    <bits access="rw" name="KP_DBN_Time" pos="9:2" rst="0">
      <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.
      </comment>
    </bits>

   <bits access="rw" name="KP_ITV_Time" pos="15:10" rst="0">
      <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms. 
      </comment>
    </bits>
    
    <bits access="rw" name="KP_IN_MASK" pos="23:16" rst="0xff">
        <comment>each bit masks one input lines.<br />
            '1' = enabled <br /> '0' = disabled
            
            <br/>The Key In pins 0 to 5 are muxed with the boot mode pins, latched during Reset.
                <br/> Key_In 0: BOOT_MODE_NO_AUTO_PU.
                <br/> Key_In 1: BOOT_MODE_FORCE_MONITOR.
                <br/> Key_In 2: BOOT_MODE_UART_MONITOR_ENABLE.
                <br/> Key_In 3: BOOT_MODE_USB_MONITOR_DISABLE.
                <br/> Key_In 4: reserved

        </comment>
    </bits>

    <bits access="rw" name="KP_OUT_MASK" pos="31:24" rst="0xff">
        <comment>each bit masks one output lines.<br />
            '1' = enabled <br /> '0' = disabled </comment>
    </bits>

  </reg>

  <reg protect="rw" name="KP_IRQ_MASK">
    <bits access="rw" name="KP_EVT0_IRQ_MASK" pos="0" rst="0">
      <comment>This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_EVT1_IRQ_MASK" pos="1" rst="0">
      <comment>This bit mask keypad irq generated by event1 (all keys release event). 
        <br />0 = keypad event irq disable<br />1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits access="rw" name="KP_ITV_IRQ_MASK" pos="2" rst="0">
      <comment>This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time. 
        <br />0 = keypad interval irq disable<br />1 = keypad interval irq enable  
      </comment>
    </bits>

  </reg>

  <reg protect="r" name="KP_IRQ_CAUSE">
    <bits access="r" name="KP_EVT0_IRQ_CAUSE" pos="0" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_CAUSE" pos="1" rst="0">
      <comment>keypad event1(all keys release event) IRQ cause. 
      </comment>
    </bits>

    <bits access="r" name="KP_ITV_IRQ_CAUSE" pos="2" rst="0">
      <comment>keypad interval irq cause. 
      </comment>
    </bits>
    
    <bits access="r" name="KP_EVT0_IRQ_STATUS" pos="16" rst="0">
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status. 
      </comment>
    </bits>

    <bits access="r" name="KP_EVT1_IRQ_STATUS" pos="17" rst="0">
      <comment>keypad event1(all keys release event) irq status. 
      </comment>
    </bits>
  
    <bits access="r" name="KP_ITV_IRQ_STATUS" pos="18" rst="0">
      <comment>keypad interval irq status. 
      </comment>
    </bits>

  </reg>
  
  <reg protect="rw" name="KP_IRQ_CLR">
    <bits access="c" name="KP_IRQ_CLR" pos="0" rst="0">
      <comment>Write '1' to this bit clears key IRQ. </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative = "lps.xml">

<module name="lps" category="Modem">

    
    
	<var name="LP_FRAC_NB_BITS" value="16"/>
	<var name="LP_COUNT_INT_NB_BITS" value="19"/>
	<var name="LP_COUNT_NB_BITS" value="LP_COUNT_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="LP_RATE_INT_NB_BITS" value="12"/>
	<var name="LP_RATE_NB_BITS" value="LP_RATE_INT_NB_BITS + LP_FRAC_NB_BITS"/>
	<var name="SYS_COUNT_NB_BITS" value="29"/>
	<var name="FRAME_COUNT_NB_BITS" value="32"/>
    
	<var name="PU_COUNT_NB_BITS" value="12"/>
    
    
    <reg name="LPS_SF_Ctrl" protect="rw">
        <bits name="LPS_SF_Enable" pos="0" access="rw" rst="0">
            <comment>Lps Skip Frame Enable.
                <br/>When enabled the frame interrupt are masked until the programmed number of frames are elapsed.
                <br/>This is done by masking the frame interrupt line from the regular TCU counter, and counting the frames. Also when activating the LowPower SkipFrame the frame counter is tranfered to the low power counter that will update it based on the 32kHz Clock.
            </comment>
        </bits>
        <bits name="LPS_SF_LowPower" pos="5:4" access="rw" rst="0">
            <comment>Controls the Lps Low Power Counters (counters at 32kHz) usage.
            </comment>
            <options>
                <option name="Stop" value="0"><comment>Disable the Low Power Counters.</comment></option>
                <option name="SkipFrame" value="1"><comment>The Low Power Counters are started in Skip Frame Mode. In this mode the Low Power Counter are used to maintain the Time base, The Skip Frame Must be enabled as this is the Low Power extention of the Skip Frame feature.</comment></option>
                <option name="Calib" value="3"><comment>Start the calibration. The Low Power Counters are used to Calibrate the 32kHz clock against the System Clock, The Calibration is required to compensate from temperature variation. Note that the Skip Frame can also be enabled during calibration (but not with low power).</comment></option>
                <mask/>
                <shift/>
                <default/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0" pos="8" access="rw" rst="0">
            <comment>Enable fake Fint used with wakeupNumber=0. </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="LPS_SF_Wakeup0_cfg" pos="9" access="rw" rst="0">
            <comment>Enable fake Fint when sys_sf_frame_count>=cfg_sf_frame. 
                <br/>Default sys_sf_frame_count>cfg_sf_frame.
            </comment>
            <options>
                <option name="0" value="0"/>
                <option name="1" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="LPS_SF_Status" protect="rw">
        <bits name="LPS_SF_Ready" pos="0" access="r" rst="1">
            <comment>Lps Skip Frame Ready, status of the state machines to keep valid state between system clock and 32Khz clock.
                <br/>Must read as '1' before entering Low Power Skip Frame or Calibration mode.
            </comment>
        </bits>
        <bits name="LPS_SF_SlowRunning" pos="4" access="r" rst="0">
            <comment>'1' when Lps Skip Frame Low Power Counters are Running.
                <br/>When entering Low Power Skip Frame, the counters are not immediately started, they wait for the nextFrame interrupt. Reading this status allow to know if the counters are running, and the System Clock can be safely disabled.
            </comment>
        </bits>
        <bits name="LPS_SF_CalibrationDone" pos="8" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Calibration is Done.
            </comment>
        </bits>
        <bits name="LPS_SF_PU_Reached" pos="12" access="r" rst="0">
            <comment>'1' when the Lps Skip Frame Power-up sequence frame is reached.
            </comment>
        </bits>
        <bits name="LPS_SF_TCU_Restart" pos="16" access="r" rst="0">
            <comment>'1' when tcu counter is restarted.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frames" protect="rw">
        <bits name="LPS_SF_Frame" pos="FRAME_COUNT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Number of frames to Skip.
                <br/>If the power up sequence is enabled, frames are skipped until both this number is reached and the powerup sequence has finished.
                <br/>Note: The power up sequence must be <b>Done</b> before the the frame LPS_SF_Frame ends.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_PU_Frames" protect="rw">
        <bits name="LPS_SF_PU_Frame" pos="FRAME_COUNT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Number of frames before activating the Power-up sequence.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Restart_Time" protect="rw">
        <bits name="LPS_SF_Restart_Time" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw" rst="0">
            <comment>For LowPower SkipFrame mode: Value to restart TCU (and frame interrupt generation) on the system clock counter after a low power phase.
                <br/>For Calibration mode: number of 32k cycles for the calibration.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Frame_Period" protect="rw">
        <bits name="LPS_SF_Frame_Period" pos="LP_COUNT_INT_NB_BITS-1:0" access="rw" rst="0">
            <comment>Value of the frame period in system clock count.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Rate" protect="rw">
        <comment>The rate is the number of System Clocks per 32kHz Clocks.
        </comment>
        <bits name="LPS_SF_Rate_Int" pos="LP_RATE_NB_BITS-1:LP_FRAC_NB_BITS" access="rw" rst="0">
            <comment>Integer part of the rate.
            </comment>
        </bits>
        <bits name="LPS_SF_Rate_Frac" pos="LP_FRAC_NB_BITS-1:0" access="rw" rst="0">
            <comment>Fractional part of the rate.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Elapsed_Frames" protect="rw">
        <bits name="LPS_SF_Elapsed_Frames" pos="FRAME_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Current number of elapsed frames.
                <br/>Valid when Skip Frame is Enabled.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_SF_Sys_Count" protect="rw">
        <bits name="LPS_SF_Sys_Count" pos="SYS_COUNT_NB_BITS-1:0" access="r" rst="0">
            <comment>Value of the system clock counter at the end of calibration (when CalibrationDone is '1' in LPS_SF_Status register).
                <br/>The hardware behind it is reused during other operation, reading that register at any other time will return an undefined value.
            </comment>
        </bits>
    </reg>
    <reg name="LPS_IRQ" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Cause" pos="0" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Cause" pos="1" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Cause" pos="2" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_TCU_Restart_Cause" pos="3" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the tcu counter was restarted.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Cause">
            <entry ref="LPS_IRQ_Calibration_Done_Cause"/>
            <entry ref="LPS_IRQ_Slow_Running_Cause"/>
            <entry ref="LPS_IRQ_PU_Reached_Cause"/>
            <entry ref="LPS_IRQ_TCU_Restart_Cause"/>
        </bitgroup>

        <bits name="LPS_IRQ_Calibration_Done_Status" pos="16" access="rc" rst="0">
            <comment>1 when the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Status" pos="17" access="rc" rst="0">
            <comment>1 when the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Status" pos="18" access="rc" rst="0">
            <comment>1 when the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name="LPS_IRQ_TCU_Restart_Status" pos="19" access="rc" rst="0">
            <comment>1 when the tcu counter was restarted.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="LPS_PU_IRQ_Status">
            <entry ref="LPS_IRQ_Calibration_Done_Status"/>
            <entry ref="LPS_IRQ_Slow_Running_Status"/>
            <entry ref="LPS_IRQ_PU_Reached_Status"/>
            <entry ref="LPS_IRQ_TCU_Restart_Status"/>
        </bitgroup>
    </reg>
    <reg name="LPS_IRQ_Mask" protect="rw">
        <bits name="LPS_IRQ_Calibration_Done_Mask" pos="0" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Calibration_Done is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_Slow_Running_Mask" pos="1" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_Slow_Running is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_PU_Reached_Mask" pos="2" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_PU_Reached is enabled.
            </comment>
        </bits>
        <bits name="LPS_IRQ_TCU_Restart_Mask" pos="3" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_TCU_Restart is enabled.
            </comment>
        </bits>
        <bitgroup name="LPS_IRQ_Mask">
            <entry ref="LPS_IRQ_Calibration_Done_Mask"/>
            <entry ref="LPS_IRQ_Slow_Running_Mask"/>
            <entry ref="LPS_IRQ_PU_Reached_Mask"/>
            <entry ref="LPS_IRQ_TCU_Restart_Mask"/>
        </bitgroup>
    </reg>

</module>

</archive>

<archive relative="lzma.xml">
  <module name="lzma" category="System">
    <reg protect="rw" name="lzma_cmd_reg">
      <bits access="r" name="lzma_cmd_reg_reserved_0" pos="31:1" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="start" pos="0" rst="0">
        <comment>
          Writing 1 starts block decode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_status_reg">
      <bits access="r" name="lzma_status_reg_reserved_0" pos="31:3" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="axi_err" pos="2" rst="0">
        <comment>
          AXI bus error flag. Reading 1 indicates AXI bus operation fails and Lzma should be reset.
        </comment>
      </bits>
      <bits access="rw" name="dec_err" pos="1" rst="0">
        <comment>
          Decode error flag. Reading 1 indicates block decode error and Lzma should be reset.
        </comment>
      </bits>
      <bits access="rw" name="dec_done" pos="0" rst="0">
        <comment>
          Decode done flag. Reading 1 indicates block decode done, writing 1 clears.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_irq_mask">
      <bits access="r" name="lzma_irq_mask_reserved_0" pos="31:3" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="axi_errirqmask" pos="2" rst="0">
        <comment>
          Writing 1 indicates a interrupt will be generated when lzma_status_reg[2]=1
        </comment>
      </bits>
      <bits access="rw" name="dec_errirqmask" pos="1" rst="0">
        <comment>
          Writing 1 indicates a interrupt will be generated when lzma_status_reg[1]=1
        </comment>
      </bits>
      <bits access="rw" name="dec_doneirqmask" pos="0" rst="0">
        <comment>
          Writing 1 indicates a interrupt will be generated when lzma_status_reg[0]=1
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reserve0">
      <bits access="r" name="reserve0_reserved_0" pos="31:0" rst="0">
        <comment>
          not used
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_config_reg1">
      <bits access="r" name="lzma_config_reg1_reserved_0" pos="31:30" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="reg_dict_size" pos="29:17" rst="0">
        <comment>
          Lzma dictionary size in byte
        </comment>
      </bits>
      <bits access="rw" name="reg_block_size" pos="16:0" rst="0">
        <comment>
          lzma block size in byte
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_config_reg2">
      <bits access="r" name="lzma_config_reg2_reserved_0" pos="31:17" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="reg_stream_len" pos="16:0" rst="0">
        <comment>
          lzma zip stream lenght in byte
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_config_reg3">
      <bits access="r" name="lzma_config_reg3_reserved_0" pos="31:3" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="reg_refbyte_en" pos="2" rst="0">
        <comment>
          1: refbyte enable; 0: refbyte disable
        </comment>
      </bits>
      <bits access="rw" name="reg_cabac_movebits" pos="1" rst="0">
        <comment>
          1: cabac_movebits=5; 0: cabac_movebits=4
        </comment>
      </bits>
      <bits access="rw" name="reg_cabac_totalbits" pos="0" rst="0">
        <comment>
          1: cabac_totalbits=11; 0: cabac_totalbits=10
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="lzma_status_reg2">
      <bits access="r" name="lzma_status_reg2_reserved_0" pos="31:17" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="r" name="stream_byte_pos" pos="16:0" rst="0">
        <comment>
          current decoding byte position in zip stream
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="lzma_status_reg3">
      <bits access="r" name="lzma_status_reg3_reserved_0" pos="31:17" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="r" name="dict_byte_pos" pos="16:0" rst="0">
        <comment>
          current recovering byte position in dictionary
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="lzma_error_type">
      <bits access="r" name="lzma_error_type_reserved_0" pos="31:7" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="r" name="inbuf_underflow" pos="6" rst="0">
        <comment>
          Equals to 1 when block decode finishes with zip stream reading byte position less than (reg_stream_len-2)
        </comment>
      </bits>
      <bits access="r" name="outbuf_overflow" pos="5" rst="0">
        <comment>
          Equals to 1 when block decode finishes with block buffer writing byte position exceeds the block size
        </comment>
      </bits>
      <bits access="r" name="symbol_len_err" pos="4" rst="0">
        <comment>
          Equals to 1 when a symbol is decoded as match type with length more than 273
        </comment>
      </bits>
      <bits access="r" name="symbol_reps_err0" pos="3" rst="0">
        <comment>
          Equals to 1 when a symbol is decoded as match type with reps0 more than dictionary size
        </comment>
      </bits>
      <bits access="r" name="symbol_reps_err1" pos="2" rst="0">
        <comment>
          Equals to 1 when a symbol is decoded as match type with reps0 more than dictionary recovery byte postion
        </comment>
      </bits>
      <bits access="r" name="symbol_type_err" pos="1" rst="0">
        <comment>
          Equals to 1 when first symbol in a block is decoded as match type
        </comment>
      </bits>
      <bits access="r" name="inbuf_overflow" pos="0" rst="0">
        <comment>
          Equals to 1 when zip stream reading byte position exceeds the stream length
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reserve1">
      <bits access="r" name="reserve1_reserved_0" pos="31:0" rst="0">
        <comment>
          not used
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reserve2">
      <bits access="r" name="reserve2_reserved_0" pos="31:0" rst="0">
        <comment>
          not used
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="lzma_input_crc">
      <bits access="r" name="input_crc" pos="31:0" rst="0">
        <comment>
          Crc of lzma rdma read bytes
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="lzma_output_crc">
      <bits access="r" name="output_crc" pos="31:0" rst="0">
        <comment>
          Crc of lzma wdma write bytes
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reserve3">
      <bits access="r" name="reserve3_reserved_0" pos="31:0" rst="0">
        <comment>
          not used
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reserve4">
      <bits access="r" name="reserve4_reserved_0" pos="31:0" rst="0">
        <comment>
          not used
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_dma_raddr_reg">
      <bits access="rw" name="dma_raddr_reg" pos="31:0" rst="0">
        <comment>
          Base address of lzma rdma
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_dma_waddr_reg">
      <bits access="rw" name="dma_waddr_reg" pos="31:0" rst="0">
        <comment>
          Base address of lzma wdma
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lzma_inbuf_rwmargin_reg">
      <bits access="r" name="lzma_inbuf_rwmargin_reg_reserved_0" pos="31:6" rst="0">
        <comment>
          not used
        </comment>
      </bits>
      <bits access="rw" name="inbuf_rwmargin_reg" pos="5:0" rst="6">
        <comment>
          Set the margin between input_buf wrptr and rdptr for pending the decode process
        </comment>
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "mailbox.xml">
  <var name="CPUNUM"   value="2" /> 
  <var name="MAILBOX_SIZE"   value="32" />
  <var name="MAILBOX_CPUID_AP"   value="0" />
  <var name="MAILBOX_CPUID_CP"   value="1" />

  
  <module name="mailbox" category="System">
    <struct count="CPUNUM" name="mailbox_reg">
      <reg protect="rw" name="int_raw_status">
        <bits access="rw" name="int_raw_status" pos="31:0" rst="0">
          <comment>Int Raw Status.</comment>
        </bits>
      </reg>

      <reg protect="rw" name="int_enable">
        <bits access="rw1s" name="int_enable" pos="31:0" rst="0">
          <comment>Enable bit, when '1' the int raw is enabled.</comment>
        </bits>
      </reg>

      <reg protect="rw" name="int_disable">
        <bits access="rw1c" name="int_disable" pos="31:0" rst="0">
          <comment>Enable bit, when '1' the int raw is disabled.</comment>
        </bits>
      </reg>

      <reg protect="rw" name="int_mask">
        <bits access="rw" name="int_mask" pos="31:0" rst="0">
          <comment>Int Mask Register, int_status == (int_raw_status &amp; ~int_mask)</comment>
        </bits>
      </reg>

      <reg protect="ro" name="int_status">
        <bits access="ro" name="int_status" pos="31:0" rst="0">
          <comment>Int Status, int_raw_status &amp; (~int_mask)</comment>
        </bits>
      </reg>

      <hole size="96" />

    </struct>

    <hole size="64*32 - CPUNUM*8*32" />

    <struct count="CPUNUM" name="mailbox_ram">
      <reg name="ram_array" count="MAILBOX_SIZE" protect="rw">
        <bits name="data" pos="31:0" access="rw" rst="-">
          <comment>Mailbox Ram Space
            <br/> Memory used for communication between XCPU and BCPU. 
          </comment>
        </bits>
      </reg>
      <hole size="64*32 - MAILBOX_SIZE*32" />
    </struct>

  </module>

</archive>
<archive relative = "mcu_ctrl.xml">

<module name="mcu_ctrl" category="System">

  <reg name="chip_id" protect="r">
    <bits access="r" name="major_id" pos="31:18" rst="0x22CD">
    </bits>
    <bits access="r" name="minor_id" pos="17:13" rst="0x1">
    </bits>
    <bits access="r" name="bond_id" pos="12:12" rst="0x0">
    </bits>
    <bits access="r" name="metal_id" pos="11:0" rst="0x0">
    </bits>
  </reg>

  <reg name="reg_dbg" protect="rw">
    <bits access="rw" name="scratch" pos="15:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_ctrl" protect="rw">
    <bits access="rw" name="cmu_clk_en" pos="21:21" rst="0x0">
    </bits>
    <bits access="rw" name="cmu_clk_sel" pos="20:16" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_clk_en" pos="12:12" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_clk_sel" pos="11:8" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_trig_sel" pos="7:4" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_out_sel" pos="3:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg0" protect="rw">
    <bits access="rw" name="disable_acg0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg1" protect="rw">
    <bits access="rw" name="disable_acg1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg2" protect="rw">
    <bits access="rw" name="disable_acg2" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="dbg_disable_acg3" protect="rw">
    <bits access="rw" name="disable_acg3" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="io_clktest" protect="rw">
    <bits access="rw" name="io_clktest_mux_sel_bit" pos="5:2" rst="0x0">
    </bits>
    <bits access="rw" name="io_clktest_mux2_en" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="io_clktest_mux1_en" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="stcalib" protect="rw">
    <bits access="rw" name="noref" pos="25:25" rst="0x0">
    </bits>
    <bits access="rw" name="skew" pos="24:24" rst="0x0">
    </bits>
    <bits access="rw" name="tenms" pos="23:0" rst="0x270F">
    </bits>
  </reg>

  <reg name="ble_ctrl" protect="rw">
    <bits access="rw" name="bt_clksel" pos="5:0" rst="0xD">
    </bits>
  </reg>

</module>
</archive>

<archive relative = "nb_acc.xml">
  <module name="nb_acc" category="NBIOT_PHY">
    <reg32 name="rNB_ACC_EN" protect="w">
      <bits name="rNB_ACC_EN" pos="0" access="w" rst="0">
        <comment>NB accelerator Enable
        when enable is low, it would wait to the last DMA transfer to go back to idle status.
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_ACC_CTRL" protect="rw">
      <bits name="rCMD_LEN" pos="11:8" access="rw" rst="0">
        <comment>Command Length (unit DW)</comment>
      </bits>
      <bits name="rCMD_NUM" pos="7:0" access="rw" rst="0">
        <comment>Number of Command</comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_CMD_START_ADDR" protect="rw">
      <bits name="rNB_ACC_CMD_START_ADDR" pos="31:2" access="rw" rst="0">
        <comment>Command start address(unit: byte in DW aligned)</comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_DMA_TO_VAL" protect="rw">
      <bits name="rNB_ACC_DMA_TO_VAL" pos="31:0" access="rw" rst="0">
        <comment>Maximum time out value in AHB clock unit
        Default:(0) Disable
        Unit in AHB clock
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_START_ADDR_LIMIT0" protect="rw">
      <bits name="rNB_ACC_START_ADDR_LIMIT0" pos="31:2" access="rw" rst="0">
        <comment>Start address limit0:
        Valid DMA Output address must be not less than Start address limit
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_END_ADDR_LIMIT0" protect="rw">
      <bits name="rNB_ACC_END_ADDR_LIMIT0" pos="31:2" access="rw" rst="0x3FFFFFFF">
        <comment>End address limit0:
        Valid DMA Output address must be less than End start address limit
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_TO_VAL" protect="rw">
      <bits name="rNB_ACC_TO_VAL" pos="31:0" access="rw" rst="0">
        <comment>Maximum time out value in AHB clock unit:
        Default:(0) Disable
        Unit in AHB clock
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_START_ADDR_LIMIT1" protect="rw">
      <bits name="rNB_ACC_START_ADDR_LIMIT1" pos="31:2" access="rw" rst="1">
        <comment>Start address limit1:
        Valid DMA Output address must be not less than Start address limit
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_END_ADDR_LIMIT1" protect="rw">
      <bits name="rNB_ACC_END_ADDR_LIMIT1" pos="31:2" access="rw" rst="0x3FFFFFFF">
        <comment>End address limit1:
        Valid DMA Output address must be less than End start address limit
        </comment>
      </bits>
    </reg32>
    <hole size="3*32" />
    <reg32 name="rNB_ACC_STATUS" protect="rw">
      <bits name="rOAddr_Status" pos="14" access="ro" rst="0">
        <comment>Output address Status
        0: Normal
        1: Error
        </comment>
      </bits>
      <bits name="rHeader_Status" pos="13" access="ro" rst="0">
        <comment>Header Status
        0: Normal
        1: Error
        </comment>
      </bits>
      <bits name="rTimeout" pos="12:10" access="ro" rst="0">
        <comment>Timeout Error
        0: DMA Normal
        1: DMA Error
        Bit 0: Read DMA Error
        Bit 1: Write DMA Error
        Bit 2: Top Error
        </comment>
      </bits>
      <bits name="rCmd_Cnt" pos="9:2" access="ro" rst="0">
        <comment>Current Command Count</comment>
      </bits>
      <bits name="rStatus" pos="1" access="ro" rst="0">
        <comment>
        0: Idle
        1: On-going
        </comment>
      </bits>
      <bits name="rDone" pos="0" access="w1c" rst="0">
        <comment>This bit is read write 1 clear
        0: No Done
        1: Done
        </comment>
      </bits>
    </reg32>
    <reg32 name="rNB_ACC_DMA_STATUS" protect="rw">
      <bits name="rNB_ACC_WDMA_STATUS" pos="25:16" access="ro" rst="0">
        <comment>Write DMA control status report
        </comment>
      </bits>
      <bits name="rNB_ACC_RDMA_STATUS" pos="9:0" access="ro" rst="0">
        <comment>Read DMA control status report
        </comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ca_rx_dump.xml">
  <module name="nb_ca_rx_dump" category="NBIOT_PHY">
    <reg32 name="rCA_RX_DUMP_EN" protect="rw">
      <bits name="rCA_RX_DUMP_EN" pos="0" access="rw" rst="0">
        <comment>RX dump enable
(Auto clear when the RX dump done asserted)</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_START_POS" protect="rw">
      <bits name="rCA_RX_DUMP_START_SF_POS" pos="14:11" access="rw" rst="0">
        <comment>Start offset of subframe. Range is 0 to 9.</comment>
      </bits>
      <bits name="rCA_RX_DUMP_SAMPLE_START_POS" pos="10:0" access="rw" rst="0">
        <comment>Start offset of sample. Range is from 0 to 1919.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_CTRL0" protect="rw">
      <bits name="rDOWNSAMPLE_IDX" pos="9:8" access="rw" rst="0">
        <comment>Downsample index
0: No Downsample
1: Downsample x 2
2: Downsample x 4
3: Downsample x 8</comment>
      </bits>
      <bits name="rCA_NUM" pos="5:0" access="rw" rst="0">
        <comment>Number of CA = 1-16</comment>
      </bits>
    </reg32>
    <reg32 name="rDMA_TIMEOUT_VAL" protect="rw">
      <bits name="rDMA_TIMEOUT_VAL" pos="31:0" access="rw" rst="0xffffffff">
        <comment>DMA timeout value
Default : 0xFFFF_FFFF
0: Disable</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_MEM_BADDR_BYTE" protect="rw">
      <bits name="rCA_RX_DUMP_MEM_BADDR_BYTE" pos="31:0" access="rw" rst="0">
        <comment>CA RX dump Memory base Address in byte (with DW alignment)</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_DEPTH_DW" protect="rw">
      <bits name="rCA_RX_DUMP_DEPTH_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA RX memory depth (with 16 IQ data alignment only) in DW</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_LEN_DW" protect="rw">
      <bits name="rCA_RX_DUMP_LEN_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA RX memory length (with 16 IQ data alignment only) in DW
If Length = 0, length = infinite until disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_OS_BYTE" protect="rw">
      <bits name="rCA_RX_DUMP_OS_BYTE" pos="17:0" access="rw" rst="0">
        <comment>Each CA RX memory offset (with 16 IQ data alignment only) in byte</comment>
      </bits>
    </reg32>
    <hole size="2*32"></hole>
    <reg32 name="rCA_RX_DUMP_TRANS_ADDR" protect="r">
      <bits name="rCA_RX_DUMP_TRANS_ADDR" pos="31:0" access="r" rst="0">
        <comment>RX memory dump transfer current memory address</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_RX_DUMP_TRANS_CNT" protect="r">
      <bits name="rCA_RX_DUMP_TRANS_CNT" pos="31:0" access="rw" rst="0">
        <comment>RX memory dump transfer current count</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rCA_RX_DUMP_STATUS" protect="r">
      <bits name="rDMA_DONE_STATUS" pos="14:13" access="r" rst="0">
        <comment>Indicate the cause of DMA done
0: DMA transfer success done
1: DMA done caused by i_dma_stop
2: DMA done caused by timeout
</comment>
      </bits>
      <bits name="rDMA_CTRL_STATUS" pos="12:5" access="r" rst="0">
        <comment>For DMA debug:
[4:0] dma controller state machine
[5] dma_rfifo0_rdy
[6] dma_rfifo1_rdy
[7] dma_wfifo_rdy
</comment>
      </bits>
      <bits name="rCAPTURE_FIFO_OVERFLOW" pos="3" access="r" rst="0">
        <comment>Capture FIFO Overflow
0: Normal
1: Error
</comment>
      </bits>
      <bits name="rDMA_TIMEOUT" pos="2" access="r" rst="0">
        <comment>DMA Timeout Error
0: Normal
1: Error

</comment>
      </bits>
      <bits name="rSTATUS" pos="1" access="r" rst="0">
        <comment>0: Idle
1: Process
</comment>
      </bits>
      <bits name="rDONE" pos="0" access="w1c" rst="0">
        <comment>(This bit is read write 1 clear)
0: No Done
1: Done
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ca_tx_dump.xml">
  <module name="nb_ca_tx_dump" category="NBIOT_PHY">
    <reg32 name="rCA_TX_DUMP_TIMER_CTRL0" protect="rw">
      <bits name="rMAX_SAMPLE_NUM0" pos="7:0" access="rw" rst="0">
        <comment>Timer status control 0. It can control frame structure for MCA IFFT process.
Maximum Sample number 0 </comment>
      </bits>
      <bits name="rMAX_SAMPLE_NUM1" pos="23:16" access="rw" rst="0">
        <comment>Timer status control 0. It can control frame structure for MCA IFFT process.
Maximum Sample number 1</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TIMER_CTRL1" protect="rw">
      <bits name="rMAX_SYM_IDX" pos="28:24" access="rw" rst="0">
        <comment>Timer status control 1. It can control frame structure for MCA IFFT process.
Maximum symbol Index
Valid:0 to 31 for 0 is maximum symbol = 1
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TIMER_CTRL2" protect="rw">
      <bits name="rMAX_SYM_BMP" pos="31:0" access="rw" rst="0">
        <comment>Symbol bitmap for maximum sample number

For Bit i:
0: Maximum Sample number  0 (rMAX_SAMPLE_NUM0)
1: Maximum Sample number  1 (rMAX_SAMPLE_NUM1)
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_TIMER_STATUS" protect="r">
      <bits name="rCA_TX_SAMPLE_CNT" pos="7:0" access="rw" rst="0">
        <comment>DMA Transferred TX sample counter</comment>
      </bits>
      <bits name="rCA_TX_SYM_CNT" pos="19:16" access="rw" rst="0">
        <comment>DMA Transferred TX symbol counter</comment>
      </bits>
      <bits name="rCA_TX_SF_CNT" pos="27:24" access="rw" rst="0">
        <comment>DMA Transferred TX subframe counter</comment>
      </bits>
    </reg32>
    <hole size="60*32"></hole>
    <reg32 name="rCA_TX_DUMP_EN" protect="rw">
      <bits name="rCA_TX_DUMP_EN" pos="0" access="rw" rst="0">
        <comment>TX dump enable
(Auto clear when the TX dump done asserted)
0: Disable
1: Enable
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_START_CTRL" protect="rw">
      <bits name="rCA_TX_DUMP_START_PREFETCH_SF_POS" pos="30:27" access="rw" rst="0">
        <comment>Prefetch Start offset of subframe. Range is 0 to 9.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SAMPLE_PREFETCH_START_POS" pos="26:16" access="rw" rst="0">
        <comment>Prefetch Start offset of sample. Range is from 0 to 1919.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_START_SF_POS" pos="14:11" access="rw" rst="0">
        <comment>Start offset of subframe. Range is 0 to 9.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SAMPLE_START_POS" pos="10:0" access="rw" rst="0">
        <comment>Start offset of sample. Range is from 0 to 1919.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CTRL" protect="rw">
      <bits name="rSUBSAMPLE_OS_DLY" pos="24:16" access="rw" rst="0">
        <comment>Subsample Offset Delay for TX transmission
Range: 0 - 511 (NB clock unit)
</comment>
      </bits>
      <bits name="rUPSAMPLE_IDX" pos="9:8" access="rw" rst="0">
        <comment>Upsample index with zero insertion
0: No Upsample
1: Upsample x 2
2: Upsample x 4
3: Not support
</comment>
      </bits>
      <bits name="rCA_NUM" pos="5:0" access="rw" rst="0">
        <comment>Number of CA = 1-16</comment>
      </bits>
    </reg32>
    <reg32 name="rINS_ZERO_NUM" protect="rw">
      <bits name="rINS_ZERO_NUM" pos="8:0" access="rw" rst="0">
        <comment>Control the number of zero inserted at the end of the TX transmission.  Remark: stop or disable command would not insert zero at the end.
Valid: 0-511
</comment>
      </bits>
    </reg32>
    <reg32 name="rDMA_TIMEOUT_VAL" protect="rw">
      <bits name="rDMA_TIMEOUT_VAL" pos="31:0" access="rw" rst="0xffffffff">
        <comment>DMA timeout value
Default : 0xFFFF_FFFF
0: Disable</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_MEM_BADDR_BYTE" protect="rw">
      <bits name="rCA_TX_DUMP_MEM_BADDR_BYTE" pos="31:0" access="rw" rst="0">
        <comment>CA TX dump Memory base Address in byte (with DW alignment)</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_DEPTH_DW" protect="rw">
      <bits name="rCA_TX_DUMP_DEPTH_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA TX memory depth (with 16 IQ data alignment only) in DW</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_LEN_DW" protect="rw">
      <bits name="rCA_TX_DUMP_LEN_DW" pos="17:0" access="rw" rst="0">
        <comment>Each CA TX memory length (with 16 IQ data alignment only) in DW
If Length = 0, length = infinite until disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_LEN_OS_BYTE" protect="rw">
      <bits name="rCA_TX_DUMP_LEN_OS_BYTE" pos="17:0" access="rw" rst="0">
        <comment>Each CA TX memory offset  address (with 8 IQ data DW alignment only) in byte</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_STOP_POS" protect="rw">
      <bits name="rCA_TX_DUMP_SAMPLE_STOP_POS" pos="10:0" access="rw" rst="0">
        <comment>Stop offset of sample. Range is from 0 to 1919.</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SF_STOP_POS" pos="14:11" access="rw" rst="0">
        <comment>Stop offset of subframe. Range is 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_STOP_POS_EN" protect="rw">
      <bits name="rCA_TX_DUMP_STOP_POS_EN" pos="0" access="rw" rst="0">
        <comment>CA TX dump stop position enable. Auto clear when the ca_tx_dump_done is asserted
0: Disable
1: Enable

</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CHKSUM_CTRL" protect="rw">
      <bits name="rCA_TX_DUMP_CHKSUM_EN" pos="31" access="rw" rst="0">
        <comment>TX output data checksum enable
1: enable
0: disable
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_CHKSUM_BMP" pos="23:0" access="rw" rst="0">
        <comment>RX memory dump transfer current count</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CHKSUM_CNT" protect="r">
      <bits name="rCA_TX_DUMP_CHKSUM_CNT" pos="31:0" access="r" rst="0">
        <comment>TX output data checksum counter</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_ADDR" protect="r">
      <bits name="rCA_TX_DUMP_ADDR" pos="31:0" access="r" rst="0">
        <comment>TX memory dump transfer current memory address</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_TX_DUMP_CNT" protect="r">
      <bits name="rCA_TX_DUMP_CNT" pos="31:0" access="r" rst="0">
        <comment>TX memory dump transfer current count</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rCA_TX_DUMP_STATUS" protect="r">
      <bits name="rDMA_DONE_STATUS" pos="14:13" access="r" rst="0">
        <comment>Indicate the cause of DMA done
0: DMA transfer success done
1: DMA done caused by i_dma_stop
2: DMA done caused by timeout
</comment>
      </bits>
      <bits name="rDMA_CTRL_STATUS" pos="12:5" access="r" rst="0">
        <comment>For DMA debug:
[4:0] dma controller state machine
[5] dma_rfifo0_rdy
[6] dma_rfifo1_rdy
[7] dma_wfifo_rdy
</comment>
      </bits>
      <bits name="rPREFETCH_ERR" pos="4" access="r" rst="0">
        <comment>IFFT ready signal is not high before TX dump prefetch timing</comment>
      </bits>
      <bits name="rREAD_FIFO_UNDERFLOW" pos="3" access="r" rst="0">
        <comment>Read FIFO Underflow
0: Normal
1: Error
</comment>
      </bits>
      <bits name="rDMA_TIMEOUT" pos="2" access="r" rst="0">
        <comment>DMA Timeout Error
0: Normal
1: Error

</comment>
      </bits>
      <bits name="rSTATUS" pos="1" access="r" rst="0">
        <comment>0: Idle
1: Process
</comment>
      </bits>
      <bits name="rDONE" pos="0" access="w1c" rst="0">
        <comment>(This bit is read write 1 clear)
0: No Done
1: Done
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_cell_search.xml">
  <module name="nb_cell_search" category="NBIOT_PHY">
    <reg32 name="rPSS_CTRL" protect="rw">
      <bits name="rPSS_EN" pos="0" access="rw" rst="0">
        <comment>PSS Enable
1'b0: Stop PSS calculation
1'b1: Start PSS calculation
</comment>
      </bits>
      <bits name="rPSS_HYPO_NUM" pos="3:1" access="rw" rst="0">
        <comment>PSS hypothesis number</comment>
      </bits>
      <bits name="rPSS_OUT_BUF_CFG" pos="4" access="rw" rst="0">
        <comment>PSS output ping-pong buffer selection
1'b1:Select the pong buffer as the first output buffer
1'b0: Select the ping buffer as the first output buffer
</comment>
      </bits>
      <bits name="rPSS_ACC_EN" pos="5" access="rw" rst="0">
        <comment>PSS Accelerator Control
1'b1: PSS works as Accelerator 
1'b0: PSS works Normally</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_START_OS" protect="rw">
      <bits name="rPSS_START_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>PSS start offset of sample within a sbuframe. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rPSS_START_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>PSS start offset of subframe. Range is from 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SF_CNT" protect="r">
      <bits name="rPSS_SF_CNT" pos="3:0" access="r" rst="0">
        <comment>PSS internal sub frame counter(from 0 to 9)</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_OUT_STATUS" protect="r">
      <bits name="rPSS_OBUF_SEL" pos="0" access="r" rst="0">
        <comment>Indicate the buffer selection on current interrupt
1'b0: buffer0 is selection
1'b1: buffer1 is selection</comment>
      </bits>
      <bits name="rPSS_OBUF0_STATUS_0" pos="1" access="w1c" rst="0">
        <comment>PSS output buffer 0 status. Clear by DSP or MCU
1'b1: buffer 0 is ready.
1'b0:buffer0 is idle</comment>
      </bits>
      <bits name="rPSS_OBUF0_STATUS_1" pos="2" access="r" rst="0">
        <comment>PSS output buffer 0 status. 
1'b1: buffer 0 is over written. 
1'b0: buffer 0 is normal
</comment>
      </bits>
      <bits name="rPSS_OBUF1_STATUS_0" pos="3" access="w1c" rst="0">
        <comment>PSS output buffer 1 status. Clear by DSP or MCU
1'b1: buffer 1 is ready.
1'b0:buffer 1 is idle</comment>
      </bits>
      <bits name="rPSS_OBUF1_STATUS_1" pos="4" access="r" rst="0">
        <comment>PSS output buffer 1 status. 
1'b1: buffer 1 is over written. 
1'b0: buffer 1 is normal
</comment>
      </bits>
      <bits name="rPSS_DONE_STATUS" pos="5" access="w1c" rst="0">
        <comment>PSS calculation done status. Update very 1ms and clear by DSP or MCU.
1'b1: PSS calculation done 
1'b0: PSS is idle or under calculating</comment>
      </bits>
      <bits name="rPSS_MEM_ARB_STATUS" pos="7:6" access="r" rst="0">
        <comment>PSS write memory arbitration error status.
1'b1: the memory has conflict
1'b0: the memory is normal</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_NON_ZERO_STATUS" protect="r">
      <bits name="rPSS_NON_ZERO_STATUS" pos="8:0" access="r" rst="0">
        <comment>bit8: pss final output data non-zero status
bit7: pss 148x40 memory out data non-zero status
bit6: pss 148x40 memory in data non-zero status
bit5: pss power non-zero status
bit4: pss 1312x24 memory out data non-zero status
bit3: pss 1312x24 memory in data non-zero status
bit2: pss in local sequence non-zero status
bit1: pss_corr_calc in data non-zero status
bit0: pss_deci in data non-zero status</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_ACC_CTRL" protect="w">
      <bits name="rPSS_ACC_START" pos="0" access="w" rst="0">
        <comment>A pulse to trigger PSS to start to execute the PSS accelerator command.</comment>
      </bits>
      <bits name="rPSS_ACC_STOP" pos="1" access="w" rst="0">
        <comment>A pulse to stop PSS accelerator.</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_ACC_CMD" protect="rw">
      <bits name="rPSS_ACC_NEW_CMD" pos="0" access="rw" rst="0">
        <comment>New Command Indicator
1'b1: Set by DSP
1'b0: Clear by HW after the command is executed.</comment>
      </bits>
      <bits name="rPSS_ACC_MEM_SEL" pos="1" access="rw" rst="0">
        <comment>Memory Indicator
1'b1: Select MEM1 as the input/output memory
1'b0: Select MEM0 as the input/output memory</comment>
      </bits>
      <bits name="rPSS_ACC_RADDR" pos="19:8" access="rw" rst="0">
        <comment>Memory address for reading input data</comment>
      </bits>
      <bits name="rPSS_ACC_RLEN" pos="31:20" access="rw" rst="0">
        <comment>Length of reading input data</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_ACC_DC_PWR" protect="rw">
      <bits name="rPSS_ACC_DC_PWR_RE" pos="11:0" access="rw" rst="0">
        <comment>Real part of DC power for PSS_ACC</comment>
      </bits>
      <bits name="rPSS_ACC_DC_PWR_IM" pos="23:12" access="rw" rst="0">
        <comment>Image part of DC power for PSS_ACC</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PU0" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PU_0" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 0</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_1" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 1</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_2" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 2</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_3" pos="28:24" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PU1" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PU_4" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 0</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_5" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 1</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PU_6" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pu of hypothesis 2</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PL0" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PL_0" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 0</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_1" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 1</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_2" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 2</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_3" pos="28:24" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_SAMPLE_POS_PL1" protect="rw">
      <bits name="rPSS_SAMPLE_POS_PL_4" pos="4:0" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 4</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_5" pos="12:8" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 5</comment>
      </bits>
      <bits name="rPSS_SAMPLE_POS_PL_6" pos="20:16" access="rw" rst="0">
        <comment>PSS sample position for Pl of hypothesis 6</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF00" protect="rw">
      <bits name="rPSS_COEF_SET0_0" pos="7:0" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 0</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_1" pos="15:8" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 1</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_2" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 2</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_3" pos="31:24" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF01" protect="rw">
      <bits name="rPSS_COEF_SET0_4" pos="7:0" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 4</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_5" pos="15:8" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 5</comment>
      </bits>
      <bits name="rPSS_COEF_SET0_6" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 7</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF10" protect="rw">
      <bits name="rPSS_COEF_SET1_0" pos="7:0" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 0</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_1" pos="15:8" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 1</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_2" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 2</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_3" pos="31:24" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 3</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_COEFF11" protect="rw">
      <bits name="rPSS_COEF_SET1_4" pos="7:0" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 4</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_5" pos="15:8" access="rw" rst="0">
        <comment>PSS set 1 coefficient for hypothesis 5</comment>
      </bits>
      <bits name="rPSS_COEF_SET1_6" pos="23:16" access="rw" rst="0">
        <comment>PSS set 0 coefficient for hypothesis 6</comment>
      </bits>
    </reg32>
    <hole size="8*32"></hole>
    <struct count="17" name="PSS_SEQ0_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ0" protect="w">
        <bits name="rPSS_LOCAL_SEQ0_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 0</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ0_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 0</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ1_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ1" protect="w">
        <bits name="rPSS_LOCAL_SEQ1_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 1</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ1_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 1</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ2_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ2" protect="w">
        <bits name="rPSS_LOCAL_SEQ2_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 2</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ2_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 2</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ3_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ3" protect="w">
        <bits name="rPSS_LOCAL_SEQ3_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 3</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ3_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 3</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ4_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ4" protect="w">
        <bits name="rPSS_LOCAL_SEQ4_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 4</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ4_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 4</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ5_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ5" protect="w">
        <bits name="rPSS_LOCAL_SEQ5_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 5</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ5_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 5</comment>
        </bits>
      </reg32>
    </struct>
    <struct count="17" name="PSS_SEQ6_GROUP">
      <reg32 name="rPSS_LOCAL_SEQ6" protect="w">
        <bits name="rPSS_LOCAL_SEQ6_RE" pos="11:0" access="w" rst="0">
          <comment>Real part of the local sequence 6</comment>
        </bits>
        <bits name="rPSS_LOCAL_SEQ6_IM" pos="27:16" access="w" rst="0">
          <comment>Imag part of the local sequence 6</comment>
        </bits>
      </reg32>
    </struct>
    <hole size="177*32" />
    <reg32 name="rPSS_230_CTRL" protect="w">
      <bits name="rPSS_230_START" pos="0" access="w" rst="0">
        <comment>A pulse to trigger PSS to start ot execute the PSS accelerator command</comment>
      </bits>
      <bits name="rPSS_230_STOP" pos="1" access="w" rst="0">
        <comment>A pulse to stop PSS accelerator</comment>
      </bits>
      <bits name="rPSS_230_LOAD_START" pos="2" access="w" rst="0">
        <comment>A pulse to trigger PSS accelerator to load local sequence into local FIFO</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_CMD" protect="rw">
      <bits name="rPSS_230_NEW_CMD" pos="0" access="rw" rst="0">
        <comment>New command indicator</comment>
      </bits>
      <bits name="rPSS_230_CALC_NUM" pos="11:1" access="rw" rst="0">
        <comment>Number to calculate the correlation</comment>
      </bits>
      <bits name="rPSS_230_CALC_START_OS" pos="22:12" access="rw" rst="0">
        <comment>Memory offset for starting to read the input data</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_CLK_CTRL" protect="rw">
      <bits name="rPSS_230_CLK_SEL" pos="0" access="rw" rst="0">
        <comment>0:HW control with NB core clock
1:HW control with AHB clock</comment>
      </bits>
      <bits name="rPSS_230_CLK_DIS" pos="31" access="rw" rst="0">
        <comment>PSS share FIFO clock disable
0: Enable
1: Disable</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_HYPO_NUM" protect="rw">
      <bits name="rPSS_230_HYPO_NUM" pos="3:0" access="rw" rst="0">
        <comment>PSS 230 mode hypothsis number</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_IN_BUF_SIZE" protect="rw">
      <bits name="rPSS_230_IN_BUF_SIZE" pos="9:0" access="rw" rst="0">
        <comment>PSS Ping-Pong input buffer size(range is from 0 to 608)</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_DC_PWR" protect="rw">
      <bits name="rPSS_230_DC_PWR_RE" pos="15:0" access="rw" rst="0">
        <comment>Real Part of the DC power offset</comment>
      </bits>
      <bits name="rPSS_230_DC_PWR_IM" pos="31:16" access="rw" rst="0">
        <comment>Image Part of the DC power offset</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_PARA" protect="rw">
      <bits name="rPSS_SEG_LEN" pos="9:0" access="rw" rst="0">
        <comment>The length per segment.Typical value is 21 for 230 mode.</comment>
      </bits>
      <bits name="rPSS_SEG_NUM" pos="15:10" access="rw" rst="0">
        <comment>The number of segments.Typical value is 6 for 230 mode.</comment>
      </bits>
      <bits name="rPSS_LOCAL_SEQ_LEN" pos="25:16" access="rw" rst="0">
        <comment>Local sequence length.Typical value is 126 for 230 mode.</comment>
      </bits>
      <bits name="rPSS_DN_SAMPLE_CTRL" pos="27" access="rw" rst="0">
        <comment>Local sequence down sample control. Typical valueis 1 for 230 mode.
1'b0:No down sample
1'b1: Down sample by 2</comment>
      </bits>
      <bits name="rPSS_CONJ_EN" pos="28" access="rw" rst="0">
        <comment>Local sequence down sample control. Typical valueis 1 for 230 mode.
1'b0:Disable
1'b1:Enable</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_LOCAL_SEQ_OS" protect="rw">
      <bits name="rPSS_230_LOCAL_SEQ_OS" pos="10:0" access="rw" rst="0">
        <comment>Local sequence read address offset in the internal SRAM.The maximum value is 1312(Internal SRAM size).</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_LOCAL_SEQ_ADDR" protect="rw">
      <bits name="rPSS_230_LOCAL_SEQ_ADDR" pos="31:0" access="rw" rst="0">
        <comment>Local sequence read address in the external PSRAM</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_LOCAL_SEQ_LEN" protect="rw">
      <bits name="rPSS_230_LOCAL_SEQ_LEN" pos="15:0" access="rw" rst="0">
        <comment>Local sequence total length to read from the external PSRAM.The maximu value is 1312(Internal SRAM size)</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_OUT_ADDR" protect="rw">
      <bits name="rPSS_230_OUT_ADDR" pos="31:0" access="rw" rst="0">
        <comment>Address of BIN0 output data in the external PSRAM</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_OUT_ADDR_OS" protect="rw">
      <bits name="rPSS_230_OUT_ADDR_OS" pos="15:0" access="rw" rst="4800">
        <comment>Output data address offset between BINs</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_BIN0_CUR_ADDR" protect="r">
      <bits name="rPSS_230_BIN0_CUR_ADDR" pos="31:0" access="r" rst="0">
        <comment>Real time address of BIN0 output data</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_BIN0_CNT" protect="r">
      <bits name="rPSS_230_BIN0_CNT" pos="31:0" access="r" rst="0">
        <comment>Accumulate counter for BIN0 output data</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_DMA_TIMER" protect="rw">
      <bits name="rPSS_230_DMA_TIMER" pos="31:0" access="rw" rst="0">
        <comment>DMA timer for AHB master read/write cycles.</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_TIMER" protect="rw">
      <bits name="rPSS_230_TIMER" pos="31:0" access="rw" rst="0">
        <comment>Timer for PSS_230. The timer start when receives the pulse of PSS_230_START and stop when receives the pulse of PSS_230_STOP.</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_SHIFT_CTRL" protect="rw">
      <bits name="rPSS_230_PWR_SHIFT" pos="4:0" access="rw" rst="4">
        <comment>Segment internal sum result right shift control. The range is from 0 to 17.
How to caululate: Ceil(log2(Lseg))+7-BitSel1.BitSel1 is from 0 to 7. The suggest value of BitSel1 is 3 by algorism.</comment>
      </bits>
      <bits name="rPSS_230_SHIFT3" pos="11:8" access="rw" rst="4">
        <comment>Segment external sum result right shift control. The range is from 0 to 13.
How to caululate: Ceil(log2(Nseg))+7-BitSel2.BitSel2 is from 0 to 7. The suggest value of BitSel2 is 2 by algorism.</comment>
      </bits>
      <bits name="rPSS_230_SHIFT2" pos="18:16" access="rw" rst="1">
        <comment>Correlate result left shift control. The range is 0 to 7. The suggest value is 1 by algorism.</comment>
      </bits>
      <bits name="rPSS_230_SHIFT1" pos="27:24" access="rw" rst="7">
        <comment>Segment internal power sum result right shift control. The range is from 0 to 10.
How to caululate: Ceil(log2(Lloc_seg)).</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_STATUS" protect="rw">
      <bits name="rPSS_230_PING_DONE" pos="0" access="rw" rst="0">
        <comment>Ping command done status. Clear by DSP or MCU.
1'b1:Done
1'b0:Executing or waiting the ping command</comment>
      </bits>
      <bits name="rPSS_230_PONG_DONE" pos="1" access="rw" rst="0">
        <comment>Pong command done status. Clear by DSP or MCU.
1'b1:Done
1'b0:Executing or waiting the ping command</comment>
      </bits>
      <bits name="rPSS_230_LOCAL_SEQ_DONE" pos="2" access="rw" rst="0">
        <comment>Load local sequence to internal FIFO done status. Clear by DSP or MCU.
1'b1:Done
1'b0:Loading or not started</comment>
      </bits>
      <bits name="rPSS_230_TIME_OUT" pos="3" access="rw" rst="0">
        <comment>PSS_230 time out status.Clear by DSP or MCU.
1'b1:Time out
1'b0:Normal</comment>
      </bits>
      <bits name="rPSS_230_DMA_TIME_OUT" pos="4" access="rw" rst="0">
        <comment>PSS_230 DMA time out status.Clear by DSP or MCU.
1'b1:Time out
1'b0:Normal</comment>
      </bits>
      <bits name="rPSS_230_ARB_ERROR" pos="6:5" access="rw" rst="0">
        <comment>PSS_230 input SRAM arbitration error status.Clear by DSP or MCU.
1'b1:Error
1'b0:Normal
Bit 5:DSP control bus error
Bit 6:Accelerator memory access collusion</comment>
      </bits>
      <bits name="rPSS_230_DMA_WR_STOP" pos="7" access="rw" rst="0">
        <comment>PSS_230 DMA write is stopped by PSS_230_STOP.Clear by DSP or MCU.
1'b1:Stopped by PSS_230_STOP
1'b0:Normal</comment>
      </bits>
      <bits name="rPSS_230_DMA_RD_STOP" pos="8" access="rw" rst="0">
        <comment>PSS_230 DMA read is stopped by PSS_230_STOP.Clear by DSP or MCU.
1'b1:Stopped by PSS_230_STOP
1'b0:Normal</comment>
      </bits>
    </reg32>
    <reg32 name="rPSS_230_ERROR_STATUS" protect="rw">
      <bits name="rPSS_230_NON_ZERO_STATUS" pos="3:0" access="r" rst="0">
        <comment>PSS_230 non zero cheking status
[3]:PSS_230 final output data non-zero status
[2]:PSS_230 power non-zero status
[1]:PSS_230 input local sequence non-zero status
[0]:PSS_230 input data non-zero status</comment>
      </bits>
      <bits name="rPSS_230_DIV_BY_ZERO" pos="4" access="r" rst="0">
        <comment>PSS_230 divided by zero status</comment>
      </bits>
      <bits name="rPSS_230_DMA_CTRL" pos="7:5" access="r" rst="0">
        <comment>PSS_230_DMA_CTRL state machine</comment>
      </bits>
      <bits name="rPSS_230_CTRL" pos="11:8" access="r" rst="0">
        <comment>PSS_230_CTRL state machine</comment>
      </bits>
      <bits name="rPSS_230_DMA_STATUS" pos="25:16" access="r" rst="0">
        <comment>[25:24]:
2'b00:DMA transfer success done
2'b01:DMA done cased by i_dma_stop
2'b11:DMA done caused by time out
[23]:dma_wfifo_rdy
[22]:dma_rfifo1_rdy
[21]:dma_rfifo0_rdy
[20:16]:DMA controller state machine</comment>
      </bits>
      <bits name="rPSS_230_DMA_FIFO_STATUS" pos="29:26" access="r" rst="0">
        <comment>PSS_230 DMA FIFO status
[29]:FIFO half full
[28]:FIFO full
[27]:FIFO half empty
[26]:FIFO empty</comment>
      </bits>
    </reg32>
    <hole size="173*32" />
    <reg32 name="rCFO_START" protect="w">
      <bits name="rCFO_START" pos="0" access="w" rst="0">
        <comment>Start trigger of one CFO calculation process by writing "1" to this register</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_START_OS" protect="rw">
      <bits name="rCFO_START_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>CFO data capture start offset of samples within a sub-frame. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rCFO_START_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>CFO data capture start offset of sub-frame. Range is from 0 to 13.</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CALC_OS" protect="rw">
      <bits name="rCFO_CALC_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>CFO calculation start offset of samples within a sub-frame. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rCFO_CALC_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>CFO calculation start offset of sub-frame. Range is from 0 to 13.</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CTRL" protect="rw">
      <bits name="rCFO_FN_NUM" pos="2:0" access="rw" rst="0">
        <comment>Rotated frequency bin number when 'rCFO_MODE=0'.</comment>
      </bits>
      <bits name="rCFO_MODE" pos="3" access="rw" rst="0">
        <comment>1: Normal mode. CFO module only deal with 1 frequency bin(f0) and 9 sampling positions(Tau). 147 correlation results are reported to corresponding ram at most.
0: Searching mode. CFO module deal with 1~7 frequency bins(f0~6) and 21 sampling positions(Tau). 9 correlation results are reported to corresponding registers.
</comment>
      </bits>
      <bits name="rCFO_RPT_ADDR" pos="13:4" access="rw" rst="0">
        <comment>Start write address of CFO correlation results' reporting ram</comment>
      </bits>
      <bits name="rCFO_GAIN" pos="16:14" access="rw" rst="0">
        <comment>Correlation results truncation (32bits to 16bits).
0:right shift 8    1:right shift 7    2:right shift 6    3:right shift 5 
4:right shift 4    5:right shift 3    6:right shift 2    7:right shift 1</comment>
      </bits>
      <bits name="Reserved" pos="23:17" access="rw" rst="0">
        <comment></comment>
      </bits>
      <bits name="rCFO_TAU_NUM" pos="31:24" access="rw" rst="0">
        <comment>Tau number of CFO correlation when rCFO_MODE=0. </comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_OS_F0TO3" protect="rw">
      <bits name="rCFO_OS_F0" pos="7:0" access="rw" rst="0">
        <comment>Sampling position start offset for bin f0</comment>
      </bits>
      <bits name="rCFO_OS_F1" pos="15:8" access="rw" rst="0">
        <comment>Sampling position start offset for bin f1</comment>
      </bits>
      <bits name="rCFO_OS_F2" pos="23:16" access="rw" rst="0">
        <comment>Sampling position start offset for bin f2</comment>
      </bits>
      <bits name="rCFO_OS_F3" pos="31:24" access="rw" rst="0">
        <comment>Sampling position start offset for bin f3</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_OS_F4TO6" protect="rw">
      <bits name="rCFO_OS_F4" pos="7:0" access="rw" rst="0">
        <comment>Sampling position start offset for bin f4</comment>
      </bits>
      <bits name="rCFO_OS_F5" pos="15:8" access="rw" rst="0">
        <comment>Sampling position start offset for bin f5</comment>
      </bits>
      <bits name="rCFO_OS_F6" pos="23:16" access="rw" rst="0">
        <comment>Sampling position start offset for bin f6</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F0" protect="rw">
      <bits name="rCFO_A_F0" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F1" protect="rw">
      <bits name="rCFO_A_F1" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F2" protect="rw">
      <bits name="rCFO_A_F2" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F3" protect="rw">
      <bits name="rCFO_A_F3" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F4" protect="rw">
      <bits name="rCFO_A_F4" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F5" protect="rw">
      <bits name="rCFO_A_F5" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_A_F6" protect="rw">
      <bits name="rCFO_A_F6" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 8.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F0" protect="rw">
      <bits name="rCFO_B_F0" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F1" protect="rw">
      <bits name="rCFO_B_F1" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F2" protect="rw">
      <bits name="rCFO_B_F2" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F3" protect="rw">
      <bits name="rCFO_B_F3" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F4" protect="rw">
      <bits name="rCFO_B_F4" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F5" protect="rw">
      <bits name="rCFO_B_F5" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_B_F6" protect="rw">
      <bits name="rCFO_B_F6" pos="31:0" access="rw" rst="0">
        <comment>The complex value of  e^(-j2xpixf0xTsa). 'Tsa' means decimation with 9.
[31:16]:Imag part
[15:0]: Real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_DM_CTRL" protect="rw">
      <bits name="rCFO_BITSEL_3" pos="19:17" access="rw" rst="0x3">
        <comment>Bit selection for correlation result</comment>
      </bits>
      <bits name="rCFO_BITSEL_2" pos="16:14" access="rw" rst="0x2">
        <comment>Bit selection for difference multiplication</comment>
      </bits>
      <bits name="rCFO_BITSEL_1" pos="13:10" access="rw" rst="0x3">
        <comment>Bit selection for cfo power calculation</comment>
      </bits>
      <bits name="rCFO_DECI_FACTOR_IDX" pos="9:8" access="rw" rst="0x3">
        <comment>Decimation factor for CFO input data when 'rCFO_INPUT_MODE = 1'
        0: deci_factor = 1
        1: deci_factor = 2
        2: deci_factor = 4
        3: deci_factor = 8(default)
        </comment>
      </bits>
      <bits name="Reserved" pos="7:2" access="rw" rst="0">
        <comment></comment>
      </bits>
      <bits name="rCFO_COR_MODE" pos="1" access="rw" rst="0">
        <comment>
        0: Difference correlation result out
        1: Accumulation correaltion result out
        </comment>
      </bits>
      <bits name="rCFO_INPUT_MODE" pos="0" access="rw" rst="0">
        <comment>
        0: HW mode. After setting start trigger 'rCFO_START', HW will capture CFO input data and correlation sequence by itself and then calculate the CFO results.
        1: DSP mode. DSP should put CFO input data and correlation sequence to input buffer and then start CFO calculation by trigger register 'rCFO_START'.
        </comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <reg32 name="rCFO_ADDR_SET" protect="rw">
      <bits name="rCFO_SEQ_START_ADDR" pos="27:16" access="rw" rst="0">
        <comment>Start address to read CFO input sequence</comment>
      </bits>
      <bits name="Reserved" pos="15:12" access="rw" rst="0">
        <comment></comment>
      </bits>
      <bits name="rCFO_DATA_START_ADDR" pos="11:0" access="rw" rst="0">
        <comment>Start address to read CFO input data</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_LEN_SET" protect="rw">
      <bits name="rCFO_SEQ_LEN" pos="27:16" access="rw" rst="0">
        <comment>Sequence length to read CFO input sequence</comment>
      </bits>
      <bits name="Reserved" pos="15:12" access="rw" rst="0">
        <comment></comment>
      </bits>
      <bits name="rCFO_DATA_LEN" pos="11:0" access="rw" rst="0">
        <comment>Data length to read CFO input data
        (maximum addition value of sequence length and data length is limited to 2688)
        </comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_STATUS" protect="r">
      <bits name="rCFO_DONE_STATUS" pos="0" access="w1c" rst="0">
        <comment>CFO calculation done status. Clear by DSP or MCU.
1'b1: CFO calculation done 
1'b0: CFO is idle or under calculating</comment>
      </bits>
      <bits name="rCFO_WRAM_ERR" pos="2:1" access="r" rst="0">
        <comment>Memory request error for writing of CFO reporting ram when 'rCFO_MOED=0'
0: Normal
1: Error
Bit 2: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR0" protect="r">
      <bits name="rCFO_CORR0" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = -4' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR1" protect="r">
      <bits name="rCFO_CORR1" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = -3' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR2" protect="r">
      <bits name="rCFO_CORR2" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = -2' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR3" protect="r">
      <bits name="rCFO_CORR3" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = -1' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR4" protect="r">
      <bits name="rCFO_CORR4" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = 0' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR5" protect="r">
      <bits name="rCFO_CORR5" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = +1' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR6" protect="r">
      <bits name="rCFO_CORR6" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = +2' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR7" protect="r">
      <bits name="rCFO_CORR7" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = +3' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <reg32 name="rCFO_CORR8" protect="r">
      <bits name="rCFO_CORR8" pos="31:0" access="r" rst="0">
        <comment>When 'rCFO_MODE=1', correlation value of PSS sequence for frequency bin 'rCFO_A/B_F0' and sampling position 'Tau = +4' is reported
[31:16]: imag part
[15:0]: real part</comment>
      </bits>
    </reg32>
    <hole size="30*32" />
    <reg32 name="rSSS_CTRL" protect="rw">
      <bits name="rSSS_EN" pos="0" access="rw" rst="0">
        <comment>1'b1: SSS NB mode is enable
1'b0: SSS NB mode is disable</comment>
      </bits>
      <bits name="rSSS_ACC_EN" pos="1" access="rw" rst="0">
        <comment>1'b1: SSS accelerator mode is enable
1'b0: SSS accelerator mode is disable</comment>
      </bits>
      <bits name="rSSS_230_EN" pos="2" access="rw" rst="0">
        <comment>Used when rSSS_ACC_EN= 1'b1
1'b1: SSS works in 230 mode 
1'b0: SSS works in NB mode</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_START_OS" protect="rw">
      <bits name="rSSS_START_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>SSS start offset of sample within a sbuframe. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rSSS_START_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>SSS start offset of subframe. Range is from 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_START_CALC_OS" protect="rw">
      <bits name="rSSS_START_CALC_SAMPLE_OS" pos="10:0" access="rw" rst="0">
        <comment>SSS start calculation offset of sample within a subframe. Based on 1.92MHz. Range is from 0 to 1920.</comment>
      </bits>
      <bits name="rSSS_START_CALC_SF_OS" pos="14:11" access="rw" rst="0">
        <comment>SSS start calculation offset of subframe. Range is from 0 to 9.</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT0" protect="rw">
      <bits name="rSSS_PHASE_SHIFT0_RE" pos="11:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT0_IM" pos="27:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT1" protect="rw">
      <bits name="rSSS_PHASE_SHIFT1_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 1</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT1_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 1</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT2" protect="rw">
      <bits name="rSSS_PHASE_SHIFT2_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 2</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT2_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 2</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT3" protect="rw">
      <bits name="rSSS_PHASE_SHIFT3_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 3</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT3_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 3</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT4" protect="rw">
      <bits name="rSSS_PHASE_SHIFT4_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 4</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT4_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 4</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT5" protect="rw">
      <bits name="rSSS_PHASE_SHIFT5_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 5</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT5_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 5</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT6" protect="rw">
      <bits name="rSSS_PHASE_SHIFT6_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 6</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT6_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 6</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT7" protect="rw">
      <bits name="rSSS_PHASE_SHIFT7_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 7</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT7_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 7</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT8" protect="rw">
      <bits name="rSSS_PHASE_SHIFT8_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 8</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT8_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 8</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT9" protect="rw">
      <bits name="rSSS_PHASE_SHIFT9_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 9</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT9_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 9</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PHASE_SHIFT10" protect="rw">
      <bits name="rSSS_PHASE_SHIFT10_RE" pos="15:0" access="rw" rst="0">
        <comment>Real part of SSS phase shift 10</comment>
      </bits>
      <bits name="rSSS_PHASE_SHIFT10_IM" pos="31:16" access="rw" rst="0">
        <comment>Imag part of SSS phase shift 10</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_SF_CNT" protect="r">
      <bits name="rSSS_SF_CNT" pos="3:0" access="r" rst="0">
        <comment>SSS internal sub frame counter(from 0 to 9)</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_GLB_CNT" protect="r">
      <bits name="rSSS_GLB_SAMPLE_CNT" pos="10:0" access="r" rst="0">
        <comment>global sample count value at SSS subframe start</comment>
      </bits>
      <bits name="rSSS_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at SSS subframe start</comment>
      </bits>
      <bits name="rSSS_GLB_RF_CNT" pos="17:15" access="r" rst="0">
        <comment>Global radio frame count value at SSS subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_OUT_STATUS" protect="r">
      <bits name="rSSS_OBUF_SEL" pos="1:0" access="r" rst="0">
        <comment>Indicate the buffer selection on current interrupt
2'b00: MEM0 is selectedion
2'b01: MEM1 is selectedion
2'b10: MEM8 is selected
2'b00: Reserved</comment>
      </bits>
      <bits name="rSSS_OBUF0_STATUS_0" pos="2" access="w1c" rst="0">
        <comment>SSS output buffer 0 status. Clear by DSP or MCU
bit 2: 1'b1: MEM2 or MEM0  is ready.1'b0:buffer0 is idle</comment>
      </bits>
      <bits name="rSSS_OBUF0_STATUS_1" pos="3" access="r" rst="0">
        <comment>SSS output buffer 0 status. 
bit 3: 1'b1: MEM2 or MEM0  is over written. 1'b0: buffer 0 is normal</comment>
      </bits>
      <bits name="rSSS_OBUF1_STATUS_0" pos="4" access="w1c" rst="0">
        <comment>SSS output buffer 1 status. Clear by DSP or MCU
bit 4: 1'b1: MEM3 or MEM1  is ready.1'b0:buffer1 is idle</comment>
      </bits>
      <bits name="rSSS_OBUF1_STATUS_1" pos="5" access="r" rst="0">
        <comment>SSS output buffer 1 status.
bit 5: 1'b1: MEM3 or MEM1  is over written. 1'b0: buffer 1 is normal</comment>
      </bits>
      <bits name="rSSS_DONE_STATUS" pos="6" access="w1c" rst="0">
        <comment>SSS calculation done status. Update very 1ms and clear by DSP or MCU.
1'b1: SSS calculation done 
1'b0: SSS is idle or under calculating</comment>
      </bits>
      <bits name="rSSS_MEM_ARB_STATUS" pos="8:7" access="r" rst="0">
        <comment>SSS write memory arbitration error status.
0: Normal
1: Error
Bit 7: DSP control bus error
Bit 8: accelerator memory access collusion</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_FFT_CTRL" protect="rw">
      <bits name="rSSS_FFT_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset which use to locate the FFT windows start position for serving cell.
Value:[0:9]</comment>
      </bits>
      <bits name="rSSS_FFT_SCALE" pos="6:4" access="rw" rst="0">
        <comment>FFT result scaling
3'd0: 2^-3
3'd1: 2^-2
3'd2: 2^-1
3'd3: 2^0
3'd4: 2^1
3'd5: 2^2</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_CORR_CTRL" protect="rw">
      <bits name="rSSS_CORR_SCAL" pos="2:0" access="rw" rst="5">
        <comment>Correlation result sScaling for both power and correlation
3'd0: 20
3'd1: 2-1
3'd2: 2-2
3'd3: 2-3
3'd4: 2-4
3'd5: 2-5(Default)
3'd6: 2-6
3'd7: 2-7</comment>
      </bits>
      <bits name="rSSS_CYCLIC_SHIFT" pos="4:3" access="rw" rst="0">
        <comment>Cyclic shift value 
It is used when rSSS_CYCLIC_SHIFT_FIX_EN = 1'b1.Rang is from 0 to 2.</comment>
      </bits>
      <bits name="rSSS_CYCLIC_SHIFT_FIX_EN" pos="5" access="rw" rst="0">
        <comment>Fix cyclic shift enable</comment>
      </bits>
      <bits name="rSSS_PCI_ID" pos="14:6" access="rw" rst="0">
        <comment>PCI ID 
It is used when rSSS_PCI_ID_FIX_RN = 1'b1 or rSSS_SIC_EN = 1'b1. Range is from 0 to 503.</comment>
      </bits>
      <bits name="rSSS_PCI_ID_FIX_EN" pos="15" access="rw" rst="0">
        <comment>Fix PCI ID Enable.</comment>
      </bits>
      <bits name="rSSS_MEM_CFG" pos="16" access="rw" rst="0">
        <comment>SSS output data selection
1'b1: SSS output data to MEM8(Used when SSS_ACC_EN = 1'b1)
1'b0: SSS output data to MEM0 or MEM1.</comment>
      </bits>
      <bits name="rSSS_SIC_EN" pos="17" access="rw" rst="0">
        <comment>SIC Enable
Used for succesive interference cancellation.</comment>
      </bits>
      <bits name="rSSS_OUT_BUF_CFG" pos="18" access="rw" rst="0">
        <comment>SSS output buffer ping-pong buffer selection in normal mode(Used when rSSS_MEM_CFG = 1'b0)
1'b1:Select MEM1 as the first output buffer
1'b0:Select MEM0 as the first output buffer</comment>
      </bits>
      <bits name="rSSS_CORR_SCAL2" pos="21:19" access="rw" rst="4">
        <comment>Scaling for correlation only
3'd0: 2-4
3'd1: 2-3
3'd2: 2-2
3'd3: 2-1
3'd4: 20(Default)
3'd5: 21
3'd6: 22
3'd7: 23</comment>
      </bits>
      <bits name="Reserved" pos="23:22" access="rw" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rSSS_OUT_ADDR" pos="31:24" access="rw" rst="132">
        <comment>Memory address for output data when SSS_ACC_EN is enabled. Default value is 132.</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_PWR" protect="rw">
      <bits name="rSSS_PWR" pos="15:0" access="rw" rst="0x0">
        <comment>SSS total power</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_CTRL" protect="rw">
      <bits name="rSSS_ACC_SF_START" pos="0" access="rw" rst="0x0">
        <comment>A sub-frame based start or go on calculation for SSS Accelerator</comment>
      </bits>
      <bits name="rSSS_ACC_RF_STOP" pos="1" access="rw" rst="0x0">
        <comment>A radio frame based stop for SSS Accelerator</comment>
      </bits>
      <bits name="rSSS_ACC_RF_START" pos="2" access="rw" rst="0x0">
        <comment>A radio frame based start for SSS Accelerator </comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_PARA" protect="rw">
      <bits name="rSSS_ACC _ZC_LEN" pos="7:0" access="rw" rst="41">
        <comment>Length of Zadoff-Chu sequence for SSS sequence
Default:41</comment>
      </bits>
      <bits name="rSSS_ACC_LOOP_LEN" pos="15:8" access="rw" rst="40">
        <comment>Loop length for SSS sequence
Default:40</comment>
      </bits>
      <bits name="rSSS_ACC_DATA_LEN" pos="23:16" access="rw" rst="41">
        <comment>Data length for SSS sequence
Default:41
</comment>
      </bits>
      <bits name="rSSS_ACC_SUM_SHIFT" pos="26:24" access="rw" rst="0x0">
        <comment>Left Shift after the sum
Algorium:7-min(ceil(log2 rSSS_ACC_DATA_LEN,7))
Default:0</comment>
      </bits>
      <bits name="rSSS_ACC_CORR_MODE" pos="27" access="rw" rst="0x0">
        <comment>SSS final output result control
1'b1: output complex value
1'b0: output magnitude value
Default:0</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_BM0" protect="rw">
      <bits name="rSSS_ACC_BM0" pos="31:0" access="rw" rst="0x0">
        <comment>The Binary Sequence ba(m), b0(0)~ b0(31). (Only Used in Accelerator Mode)
1'b0: 1
1'b1: -1
</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_BM1" protect="rw">
      <bits name="rSSS_ACC_BM1" pos="31:0" access="rw" rst="0x0">
        <comment>The Binary Sequence ba(m), b0(32)~ b0(63). (Only Used in Accelerator Mode)
1'b0: 1
1'b1: -1
</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_BM2" protect="rw">
      <bits name="rSSS_ACC_BM2" pos="31:0" access="rw" rst="0x0">
        <comment>The Binary Sequence ba(m), b0(64)~ b0(95). (Only Used in Accelerator Mode)
1'b0: 1
1'b1: -1
</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_BM3" protect="rw">
      <bits name="rSSS_ACC_BM3" pos="31:0" access="rw" rst="0x0">
        <comment>The Binary Sequence ba(m), b0(96)~ b0(127). (Only Used in Accelerator Mode)
1'b0: 1
1'b1: -1
</comment>
      </bits>
    </reg32>
    <reg32 name="rSSS_ACC_LOCAL_SEQ_OS" protect="rw">
      <bits name="rSSS_ACC_LOCAL_SEQ_OS" pos="5:0" access="rw" rst="0x0">
        <comment>Address offset to read the local sequence.
</comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <struct count="66" name="rSSS_LOCAL_SEQ_GROUP">
      <reg32 name="rSSS_LOCAL_SEQ" protect="w">
        <bits name="rSSS_LOCAL_SEQ_RE" pos="11:0" access="w" rst="0">
          <comment>Real  part of the SSS local sequence</comment>
        </bits>
        <bits name="rSSS_LOCAL_SEQ_IM" pos="27:16" access="w" rst="0">
          <comment>Image  part of the SSS local sequence</comment>
        </bits>
      </reg32>
    </struct>
  </module>
</archive>

<archive relative = "nb_common.xml">
  <module name="nb_common" category="NBIOT_PHY">
    <reg32 name="rRX_INT_DSP_SYM_BMP_MSK" protect="rw">
      <bits name="rRX_INT_DSP_SYM_BMP_MSK" pos="13:0" access="rw" rst="0x1">
        <comment>RX interrupt DSP bitmap mask from 0 to 13. LSB is symbol 0.</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_SYM_BMP_MSK" protect="rw">
      <bits name="rRX_INT_MCU_SYM_BMP_MSK" pos="13:0" access="rw" rst="0x1">
        <comment>RX interrupt DSP bitmap mask from 0 to 13. LSB is symbol 0.</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_OS" protect="rw">
      <bits name="rRX_INT_OS" pos="6:0" access="rw" rst="0x40">
        <comment>RX interrupt output OS 0 - 127</comment>
      </bits>
    </reg32>
    <reg32 name="rNB_TIMER_MODE" protect="rw">
      <bits name="rGLB_SAMPLE_RATE_CTRL" pos="2:0" access="rw" rst="0">
        <comment>Global timer sample rate per input clock source
0: 32 NB clock for 1 sample in global counter (Legacy Mode)
1: 64 NB clock for 1 sample in global counter (L230 Mode)
2: 128 clock for 1 sample in global counter
3: 256 clock for 1 sample in global counter
4: 512 clock for 1 sample in global counter
</comment>
      </bits>
      <bits name="rRX_SAMPLE_CTRL" pos="10:8" access="rw" rst="0">
        <comment>Rx data input sample rate in global sample unit
0: 1 Global Counter Sample (1.92MHz - Legacy Mode)
1: 2 Global Counter Sample (960 Khz)
2: 4 Global Counter Sample (480 Khz)
3: 8 Global Counter Sample (240 Khz - L230 Mode) 
4: 16 Global Counter Sample (120 Khz)
5: 32 Global Counter Sample (60 Khz)
</comment>
      </bits>
      <bits name="rTX_SAMPLE_CTRL" pos="18:16" access="rw" rst="0">
        <comment>Tx data output sample rate in global sample unit
0: 1 Global Counter Sample (1.92MHz - Legacy Mode)
1: 2 Global Counter Sample (960 Khz)
2: 4 Global Counter Sample (480 Khz)
3: 8 Global Counter Sample (240 Khz - L230 Mode) 
4: 16 Global Counter Sample (120 Khz)
5: 32 Global Counter Sample (60 Khz)
</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_DSP_SF_BMP_MSK" protect="rw">
      <bits name="rRX_INT_DSP_SF_BMP_MSK" pos="9:0" access="rw" rst="0x00003fff">
        <comment>RX interrupt DSP bitmap subframe mask from 0 to 9. LSB is subframe 0.
</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_SF_BMP_MSK" protect="rw">
      <bits name="rRX_INT_MCU_SF_BMP_MSK" pos="9:0" access="rw" rst="0x00003fff">
        <comment>RX interrupt MCU bitmap subframe mask from 0 to 9. LSB is subframe 0.
</comment>
      </bits>
    </reg32>
    <hole size="2*32"></hole>
    <reg32 name="rRX_ADJ_CCTRL" protect="rw">
      <bits name="rRX_ADJ_SF_CNT" pos="3:0" access="rw" rst="0">
        <comment>RX adjustment subframe count from 0 - 9 (auto clear in next subframe)</comment>
      </bits>
      <bits name="rRX_ADJ_SYM_CNT" pos="7:4" access="rw" rst="0">
        <comment>RX adjustment symbol count from 0 - 13 (auto clear in next subframe)</comment>
      </bits>
      <bits name="rRX_ADJ_SYM_DIR" pos="8" access="rw" rst="0">
        <comment>RX adjustment symbol direction (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
      <bits name="rRX_ADJ_CSAMPLE_CNT" pos="23:16" access="rw" rst="0">
        <comment>RX coarse adjustment sample count from 0 - 138 in (chip unit) - (auto clear in next subframe)</comment>
      </bits>
      <bits name="rRX_ADJ_CSAMPLE_DIR" pos="24" access="rw" rst="0">
        <comment>RX coarse adjustment sample direction (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_ADJ_FCTRL" protect="rw">
      <bits name="rRX_ADJ_FSAMPLE_CNT" pos="7:0" access="rw" rst="0">
        <comment>NB mode: RX fine adjustment sample count from 0 - 9 in (chip unit)
230 mode: RX fine adjustment sample count from 0 - 128 in (chip unit)
</comment>
      </bits>
      <bits name="rRX_ADJ_FSAMPLE_DIR" pos="8" access="rw" rst="0">
        <comment>RX fine adjustment sample direction (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_POS_STATUS_DSP" protect="r">
      <bits name="rRX_INT_SYM_DSP" pos="3:0" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_SF_DSP" pos="7:4" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_BUF_IDX_DSP" pos="8" access="r" rst="0">
        <comment>RX interrupt buffer index
Mirror rRX_INT_BUF_IDX_MCU register</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_POS_STATUS_MCU" protect="r">
      <bits name="rRX_INT_SYM_MCU" pos="3:0" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_SF_MCU" pos="7:4" access="r" rst="0">
        <comment>RX interrupt symbol number 0-13</comment>
      </bits>
      <bits name="rRX_INT_BUF_IDX_MCU" pos="8" access="r" rst="0">
        <comment>RX interrupt buffer index</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_SFN" protect="rw">
      <bits name="rRX_SFN" pos="9:0" access="rw" rst="0">
        <comment>RX SFN number 0-1023</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_GLB_CNT_SF" protect="r">
      <bits name="rRX_GLB_SAMPLE_CNT_SF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at RX subframe start</comment>
      </bits>
      <bits name="rRX_GLB_SF_CNT_SF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at RX subframe start</comment>
      </bits>
      <bits name="rRX_GLB_RF_CNT_SF" pos="21:15" access="r" rst="0">
        <comment>global sample count value at RX subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_GLB_CNT_RF" protect="r">
      <bits name="rRX_GLB_SAMPLE_CNT_RF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at RX radio frame start</comment>
      </bits>
      <bits name="rRX_GLB_SF_CNT_RF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at RX radio frame start</comment>
      </bits>
      <bits name="rRX_GLB_RF_CNT_RF" pos="21:15" access="r" rst="0">
        <comment>global sample count value at RX radio frame start</comment>
      </bits>
    </reg32>
    <reg32 name="rTCU_GLB_CNT" protect="r">
      <bits name="rTCU_GLB_SAMPLE_CNT" pos="10:0" access="r" rst="0">
        <comment>global sample count value at TCU subframe start</comment>
      </bits>
      <bits name="rTCU_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at TCU subframe start</comment>
      </bits>
      <bits name="rTCU_GLB_RF_CNT" pos="21:15" access="r" rst="0">
        <comment>global sample count value at TCU subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rTCU_GLB_CNT_RF" protect="r">
      <bits name="rTCU_GLB_SAMPLE_CNT_RF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at TCU radio frame start</comment>
      </bits>
      <bits name="rTCU_GLB_SF_CNT_RF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at TCU radio frame start</comment>
      </bits>
      <bits name="rTCU_GLB_RF_CNT_RF" pos="21:15" access="r" rst="0">
        <comment>global sample count value at TCU radio frame start</comment>
      </bits>
    </reg32>
    <hole size="3*32" />
    <reg32 name="rTX_ADJ_CCTRL" protect="rw">
      <bits name="rTX_ADJ_CSAMPLE_CNT" pos="10:0" access="rw" rst="0">
        <comment>TX coarse adjustment sample count from 0 - 1919 in (chip unit) - (auto clear in next subframe)</comment>
      </bits>
      <bits name="rTX_ADJ_CSAMPLE_DIR" pos="11" access="rw" rst="0">
        <comment>TX coarse adjustment sample direction - (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_ADJ_FCTRL" protect="rw">
      <bits name="rTX_ADJ_FSAMPLE_CNT" pos="5:0" access="rw" rst="0">
        <comment>15KHz: TX fine adjustment sample count from 0 - 9 in (chip unit)
3.75Hz: TX fine adjustment sample count from (0 - 9) x 4 in (chip unit) 
Remark: SW should configure the sample boundary which is aligned to 3.75Hz sample if the timing adjustment between TX transmission.
(auto clear in next subframe)</comment>
      </bits>
      <bits name="rTX_ADJ_CSAMPLE_DIR" pos="6" access="rw" rst="0">
        <comment>TX fine adjustment sample direction -  (auto clear in next subframe)
0: advance
1: postpone</comment>
      </bits>
      <bits name="rTX_ADJ_FMODE" pos="8" access="rw" rst="0">
        <comment>TX fine adjustment mode control:
0: adjust the boundary at the end of the current subframe
1: adjust the CP at the first symbol of the next TX </comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rTX_GLB_CNT_SF" protect="r">
      <bits name="rTX_GLB_SAMPLE_CNT_SF" pos="10:0" access="r" rst="0">
        <comment>global sample count value at TX subframe start</comment>
      </bits>
      <bits name="rTX_GLB_SF_CNT_SF" pos="14:11" access="r" rst="0">
        <comment>global subframe count value at TX subframe start</comment>
      </bits>
      <bits name="rTX_GLB_RF_CNT_SF" pos="21:15" access="r" rst="0">
        <comment>global radio frame count value at TX subframe start</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_SUBSAMPLE_CTRL" protect="rw">
      <bits name="rTX_SUBSAMPLE_CTRL" pos="0" access="rw" rst="0">
        <comment>TX subsample control
0: sync with global subsample counter
1: only sync with RX subsample counter when TX is not on transmission</comment>
      </bits>
    </reg32>
    <reg32 name="rCTRL_STATUS" protect="rw">
      <bits name="rCTRL_RX_CADJ_STATUS" pos="0" access="w1c" rst="0">
        <comment>Control RX coarse adjustment status</comment>
      </bits>
      <bits name="rCTRL_RX_FADJ_STATUS" pos="1" access="w1c" rst="0">
        <comment>Control RX fine adjustment status</comment>
      </bits>
      <bits name="rCTRL_TX_CADJ_STATUS" pos="2" access="w1c" rst="0">
        <comment>Control TX coarse adjustment status</comment>
      </bits>
      <bits name="rCTRL_TX_FADJ_STATUS" pos="3" access="w1c" rst="0">
        <comment>Control TX fine adjustment status</comment>
      </bits>
    </reg32>
    <reg32 name="rCTRL_ADJ_EN" protect="rw">
      <bits name="rCTRL_ADJ_EN" pos="0" access="rw" rst="0">
        <comment>Control adjustment enable
1: enable
0: disable</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="CAPTURE1_GLB_CNT" protect="w">
      <bits name="CAPTURE1_GLB_CNT" pos="0" access="w" rst="0">
        <comment>Trigger to sample global counter position for DSP debegging</comment>
      </bits>
    </reg32>
    <reg32 name="rCAPTURE1_GLB_CNT" protect="r">
      <bits name="rCAPTURE1_GLB_CNT" pos="10:0" access="r" rst="0">
        <comment>global counter sample position when CAPTURE1_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE1_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global counter subframe position when CAPTURE1_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE1_GLB_RF_CNT" pos="21:15" access="r" rst="0">
        <comment>global counter radio frame position when CAPTURE1_GLB_CNT is accessed</comment>
      </bits>
    </reg32>
    <reg32 name="CAPTURE2_GLB_CNT" protect="w">
      <bits name="CAPTURE2_GLB_CNT" pos="0" access="w" rst="0">
        <comment>Trigger to sample global counter position for MCU debegging</comment>
      </bits>
    </reg32>
    <reg32 name="rCAPTURE2_GLB_CNT" protect="r">
      <bits name="rCAPTURE2_GLB_SAMPLE_CNT" pos="10:0" access="r" rst="0">
        <comment>global counter sample position when CAPTURE2_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE2_GLB_SF_CNT" pos="14:11" access="r" rst="0">
        <comment>global counter subframe position when CAPTURE2_GLB_CNT is accessed</comment>
      </bits>
      <bits name="rCAPTURE2_GLB_RF_CNT" pos="21:15" access="r" rst="0">
        <comment>global counter radio frame position when CAPTURE2_GLB_CNT is accessed</comment>
      </bits>
    </reg32>
    <reg32 name="SLEEP_W" protect="w">
      <bits name="SLEEP_W" pos="0" access="w" rst="0">
        <comment>For sleep operation
When SLEEP_W is accessed, the start values needed for wake-up are loaded. Then values have to be written before the SLEEP_W is accessed</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_GLB_CNT" protect="rw">
      <bits name="rGLB_SUB_SAMPLE_CNT" pos="4:0" access="r" rst="0">
        <comment>Sample clock/32 (TX/RX sub-sample is always aligned with Global sub-sample) : this would use for alignment of the DFE input valid.
0-31</comment>
      </bits>
      <bits name="rGLB_SAMPLE_CNT" pos="15:5" access="rw" rst="0">
        <comment>global counter sample position in sleep mode (in chip unit)</comment>
      </bits>
      <bits name="rGLB_SF_CNT" pos="19:16" access="rw" rst="0">
        <comment>global counter subframe position </comment>
      </bits>
      <bits name="rGLB_RF_CNT" pos="26:20" access="rw" rst="0">
        <comment>global counter radio frame position</comment>
      </bits>
      <bits name="rGLB_SUB_SAMPLE_CNT_MSB" pos="31:28" access="r" rst="0">
        <comment>Global counter subsample MSB bit [8:5].</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_RX_TX_CNT" protect="rw">
      <bits name="rTX_SAMPLE_CNT" pos="10:0" access="rw" rst="0">
        <comment>Sample clock/32 (TX/RX sub-sample is always aligned with Global sub-sample) : this would use for align the DFE input valid.
0-31</comment>
      </bits>
      <bits name="rRX_SAMPLE_CNT" pos="23:16" access="rw" rst="0">
        <comment>RX sample count value</comment>
      </bits>
      <bits name="rRX_SYM_CNT" pos="27:24" access="rw" rst="0">
        <comment>RX OFDM symbol count value</comment>
      </bits>
      <bits name="rRX_SF_CNT" pos="31:28" access="rw" rst="0">
        <comment>RX subframe count value</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_ELAPSED_CNT" protect="ro">
      <bits name="rSLEEP_ELAPSED_SUBSAMPLE_CNT" pos="9:0" access="ro" rst="0">
        <comment>Sleep Elapsed Subsample counter
Range: 0-511</comment>
      </bits>
      <bits name="rSLEEP_ELAPSED_SAMPLE_CNT" pos="26:16" access="ro" rst="0">
        <comment>Sleep Elapsed Subsample counter
Range: 0-1919</comment>
      </bits>
    </reg32>
    <reg32 name="rSLEEP_ELAPSED_SF_CNT" protect="ro">
      <bits name="rSLEEP_ELAPSED_SF_CNT" pos="31:0" access="ro" rst="0">
        <comment>Sleep Elapsed SF counter
Range: 0-2^32-1</comment>
      </bits>
    </reg32>
    <reg32 name="rR_GLB_CNT" protect="rw">
      <bits name="rR_GLB_SAMPLE_CNT" pos="10:0" access="ro" rst="0">
        <comment>Read global counter sample position</comment>
      </bits>
      <bits name="rR_GLB_SF_CNT" pos="14:11" access="ro" rst="0">
        <comment>Read global counter subframe position </comment>
      </bits>
      <bits name="rR_GLB_RF_CNT" pos="21:15" access="ro" rst="0">
        <comment>Read global counter radio frame position </comment>
      </bits>
    </reg32>
    <hole size="26*32" />
    <reg32 name="rTCU_EVENT_TRIG" protect="rw">
      <bits name="rTCU_EVENT_SAMPLE_TIME" pos="15:5" access="rw" rst="0">
        <comment>TCU event subsample time</comment>
      </bits>
      <bits name="rTCU_EVENT_SF_TIME" pos="19:16" access="rw" rst="0">
        <comment>TCU event subframe time</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_SYNC_MODE" protect="rw">
      <bits name="rRX_SYNC_MODE" pos="1:0" access="rw" rst="0">
        <comment>RX synchronization method mode
0: normal mode
1: sync counter will synchronize with input i_rx_sync_start pulse in DUMP mode only (For testing only)
2: sync counter will synchronize first ca_rx data valid signal in DUMP mode only (For testing only)
3: sync counter will synchronize first rx data valid signal in DUMP mode only (For testing only)
</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_SYNC_INIT_1" protect="rw">
      <bits name="rRX_SF_SYNC_INIT_1" pos="3:0" access="rw" rst="0x9">
        <comment>RX subframe count sync initialization value - 1</comment>
      </bits>
      <bits name="rGLB_SF_SYNC_INIT_1" pos="11:8" access="rw" rst="0x9">
        <comment>Global subframe count sync initialization value - 1</comment>
      </bits>
      <bits name="rGLB_RF_SYNC_INIT_1" pos="18:12" access="rw" rst="0x7">
        <comment>Global radio frame count sync initialization value - 1</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_CAPTURE_EVENT_TRIG" protect="rw">
      <bits name="rRX_CAPTURE_SAMPLE_TIME" pos="15:5" access="rw" rst="0">
        <comment>RX Capture event sample time</comment>
      </bits>
      <bits name="rRX_CAPTURE_SF_TIME" pos="19:16" access="rw" rst="0">
        <comment>RX Capture event subframe time</comment>
      </bits>
    </reg32>
    <hole size="60*32" />
    <reg32 name="rDSP_MEM0_CTRL" protect="rw">
      <bits name="rDSP_MEM0_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 0 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM0_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 0 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM1_CTRL" protect="rw">
      <bits name="rDSP_MEM1_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 1 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM1_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 1 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM2_CTRL" protect="rw">
      <bits name="rDSP_MEM2_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 2 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM2_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 2 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM3_CTRL" protect="rw">
      <bits name="rDSP_MEM3_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 3 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM3_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 3 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM4_CTRL" protect="rw">
      <bits name="rDSP_MEM4_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 4 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM4_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 4 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM5_CTRL" protect="rw">
      <bits name="rDSP_MEM5_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 5 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM5_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 5 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <reg32 name="rDSP_MEM7_CTRL" protect="rw">
      <bits name="rDSP_MEM7_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 7 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM7_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 7 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
    <reg32 name="rDSP_MEM8_CTRL" protect="rw">
      <bits name="rDSP_MEM8_CTRL" pos="1:0" access="rw" rst="0">
        <comment>DSP memory 8 control 
00: HW control with NB core clock
10: HW control with AHB clock
11: DSP control with AHB clock</comment>
      </bits>
      <bits name="rDSP_MEM8_CLK_DISABLE" pos="31" access="rw" rst="0">
        <comment>DSP memory 8 CLK disable
0: enable
1: disable
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ctrl.xml">
  <module name="nb_ctrl" category="NBIOT_PHY">
    <reg32 name="rNBIOT_SW_RST" protect="w">
      <bits name="rRX_FFT_SW_RST" pos="0" access="w" rst="0">
        <comment>RX FFT sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_PSS_SW_RST" pos="1" access="w" rst="0">
        <comment>RX Cell Search PSS sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rRX_SSS_SW_RST" pos="2" access="w" rst="0">
        <comment>RX Cell Search SSS sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_CFO_SW_RST" pos="3" access="w" rst="0">
        <comment>RX CFO sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_VIT_SW_RST" pos="4" access="w" rst="0">
        <comment>RX Viterbi sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rRX_AGC_SW_RST" pos="5" access="w" rst="0">
        <comment>RX AGC sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rDS_BSEL_SW_RST" pos="6" access="w" rst="0">
        <comment>RX DS_BSEL sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rTX_FRONTEND_SW_RST" pos="7" access="w" rst="0">
        <comment>TX frontend sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rPUSCH_ENC_SW_RST" pos="8" access="w" rst="0">
        <comment>PUSCH encoder sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rTX_CHSC_SW_RST" pos="9" access="w" rst="0">
        <comment>TX CHSC sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rFFT_512_SW_RST" pos="10" access="w" rst="0">
        <comment>FFT 512 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rNPRS_ACC1_SW_RST" pos="11" access="w" rst="0">
        <comment>NPRS acc1 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rFINE_IFFT_SW_RST" pos="12" access="w" rst="0">
        <comment>FINE_IFFT sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rNBIOT_SW_RST" pos="13" access="w" rst="0">
        <comment>rNBIOT general part reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
      <bits name="rNBIOT_SW_RST_RSRP" pos="14" access="w" rst="0">
        <comment>RX RSRP sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rCA_RX_DUMP_SW_RST" pos="15" access="w" rst="0">
        <comment>CA RX dump sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_SW_RST" pos="16" access="w" rst="0">
        <comment>CA TX dump sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rMCA_FFT128_SW_RST" pos="17" access="w" rst="0">
        <comment>Multi-CA FFT 128 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rMCA_IFFT128_SW_RST" pos="18" access="w" rst="0">
        <comment>Multi-CA IFFT 128 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rNB_ACC_SW_RST" pos="19" access="w" rst="0">
        <comment>NB ACC sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
      <bits name="rPSS230_SW_RST" pos="20" access="w" rst="0">
        <comment>PSS 230 sub-module reset by software, auto-clear to zero when write 1 to this register by DSP
1'b0: default value;
1'b1: Reset whole sub-module.
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_CLK_EN" protect="rw">
      <bits name="rRX_FFT_CLK_EN" pos="0" access="rw" rst="0">
        <comment>Enable/disable the clock for RX FFT/RSRP module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_PSS_CLK_EN" pos="1" access="rw" rst="0">
        <comment>Enable/disable the clock for RX Cell Search module PSS
0: clock disabled
1: clock enabled.
</comment>
      </bits>
      <bits name="rRX_SSS_CLK_EN" pos="2" access="rw" rst="0">
        <comment>Enable/disable the clock for RX Cell Search module SSS
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_CFO_CLK_EN" pos="3" access="rw" rst="0">
        <comment>Enable/disable the clock for RX CFO module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_VIT_CLK_EN" pos="4" access="rw" rst="0">
        <comment>Enable/disable the clock for RX Viterbi module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rRX_AGC_CLK_EN" pos="5" access="rw" rst="0">
        <comment>Enable/disable the clock for RX AGC module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rDS_BSEL_CLK_EN" pos="6" access="rw" rst="0">
        <comment>Enable/disable the clock for DS_BSEL module 
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rTX_FRONTEND_CLK_EN" pos="7" access="rw" rst="0">
        <comment>Enable/disable the clock for TX Frontend module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rPUSCH_ENC_CLK_EN" pos="8" access="rw" rst="0">
        <comment>Enable/disable the clock for PUSCH encoder module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rTX_CHSC_CLK_EN" pos="9" access="rw" rst="0">
        <comment>Enable/disable the clock for TX TX channel-interleaver and scrambling module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rFFT_512_CLK_EN" pos="10" access="rw" rst="0">
        <comment>Enable/disable the clock for FFT 512 module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rNPRS_ACC1_CLK_EN" pos="11" access="rw" rst="0">
        <comment>Enable/disable the clock for NPRS ACC1 module.
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rFINE_FFT_CLK_EN" pos="12" access="rw" rst="0">
        <comment>Enable/disable the clock for FINE ifft module
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rNBIOT_CLK_EN" pos="13" access="rw" rst="0">
        <comment>Enable/disable the clock for NBIOT module
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rCA_RX_DUMP_EN" pos="14" access="rw" rst="0">
        <comment>Enable/disable the clock for CA Rx Dump module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_EN" pos="15" access="rw" rst="0">
        <comment>Enable/disable the clock for CA Tx Dump module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rMCA_FFT128_EN" pos="16" access="rw" rst="0">
        <comment>Enable/disable the clock for MCA FFT 128 module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rMCA_IFFT128_EN" pos="17" access="rw" rst="0">
        <comment>Enable/disable the clock for MCA IFFT 128 module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
      <bits name="rNB_ACC_EN" pos="18" access="rw" rst="0">
        <comment>Enable/disable the clock for NBIOT module
0: clock disabled
1: clock enabled.</comment>
      </bits>
      <bits name="rPSS230_EN" pos="19" access="rw" rst="0">
        <comment>Enable/disable the clock for PSS 230 module
1'b0: clock disabled
1'b1: clock enabled.
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_MONITOR" protect="rw">
      <bits name="rNBIOT_MONITOR_SEL" pos="8:0" access="rw" rst="0">
        <comment>Debug signal selection</comment>
      </bits>
      <bits name="rNBIOT_MONITOR_EN" pos="9" access="rw" rst="0">
        <comment>Debug signal output enable</comment>
      </bits>
      <bits name="Reserved" pos="31:10" access="rw" rst="0">
        <comment>Reserved for debug only</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_RFIN_SW_RST" protect="w">
      <bits name="rNBIOT_RFIN_SW_RST" pos="0" access="w" rst="0">
        <comment>RFIN reset by DSP, it is used to re-timing the global timer to balance the timing of IQ data input from DFE in sample boundary. Write 1 and auto-clear by HW.
0: default value
1: reset to re-timing the sample boundary in global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_RFIN_STATUS" protect="r">
      <bits name="rNBIOT_RFIN_SUBSMAPLE_CNT" pos="16:8" access="r" rst="0">
        <comment>Sample the glb_subsample_cnt with input rx_data_vld to check the phase change of the input</comment>
      </bits>
      <bits name="rNBIOT_RFIN_STATUS_ERR" pos="0" access="r" rst="0">
        <comment>Keep track the RFIN data strobe in valid window.
0: Normal
1: Error</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_COARSE_CLK_GATING" protect="rw">
      <bits name="rPSS_COS_CLK_GATING" pos="1" access="rw" rst="0">
        <comment>PSS Correlator coarse clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module PSS Correlator.</comment>
      </bits>
      <bits name="rSSS_COS_CLK_GATING" pos="2" access="rw" rst="0">
        <comment>SSS Correlator coarse clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module SSS Correlator.</comment>
      </bits>
      <bits name="Reserved" pos="12:3" access="rw" rst="0">
        <comment></comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_FINE_CLK_GATING" protect="rw">
      <bits name="rFFT_RSRP_FT_CLK_GATING" pos="0" access="rw" rst="0">
        <comment>FFT_RSRP fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module FFT_RSRP.
</comment>
      </bits>
      <bits name="rPSS_FT_CLK_GATING" pos="1" access="rw" rst="0">
        <comment>PSS Correlator fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module PSS Correlator.</comment>
      </bits>
      <bits name="rSSS_FT_CLK_GATING" pos="2" access="rw" rst="0">
        <comment>SSS Correlator fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module SSS Correlator.</comment>
      </bits>
      <bits name="rCFO_FT_CLK_GATING" pos="3" access="rw" rst="0">
        <comment>CFO Correlator fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module CFO Correlator.</comment>
      </bits>
      <bits name="rVIT_FT_CLK_GATING" pos="4" access="rw" rst="0">
        <comment>Viterbi fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module Viterbi.</comment>
      </bits>
      <bits name="rAGC_FT_CLK_GATING" pos="5" access="rw" rst="0">
        <comment>AGC fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module AGC.</comment>
      </bits>
      <bits name="rDS_BSEL_FT_CLK_GATING" pos="6" access="rw" rst="0">
        <comment>DS_BSEL fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module DS_BSEL.
</comment>
      </bits>
      <bits name="rTX_FRONTEND_FT_CLK_GATING" pos="7" access="rw" rst="0">
        <comment>TX_FRONTEND fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module TX_FRONTEND.
</comment>
      </bits>
      <bits name="rPUSCH_ENC_CLK_GATING" pos="8" access="rw" rst="0">
        <comment>PUSCH_ENC fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module PUSCH_ENC.</comment>
      </bits>
      <bits name="rTX_CHSC_CLK_GATING" pos="9" access="rw" rst="0">
        <comment>TX_CHSC fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module TX_CHSC.</comment>
      </bits>
      <bits name="rFFT_512_CLK_GATING" pos="10" access="rw" rst="0">
        <comment>FFT 512 fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module FFT 512.</comment>
      </bits>
      <bits name="rNPRS_ACC1_CLK_GATING" pos="11" access="rw" rst="0">
        <comment>NPRS ACC1 fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module NPRS ACC1.</comment>
      </bits>
      <bits name="rFINE_IFFT_CLK_GATING" pos="12" access="rw" rst="0">
        <comment>FIne IFFT fine clock gating,
0: free running
1: clock gated by the clock enabled signal which generated from sub-module FINE_IFFT.</comment>
      </bits>
      <bits name="rRSRP_CLK_GATING" pos="13" access="rw" rst="0">
        <comment>RSRP fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module FFT_RSRP
</comment>
      </bits>
      <bits name="rCA_RX_DUMP_CLK_GATING" pos="14" access="rw" rst="0">
        <comment>CA RX dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module CA RX dump
</comment>
      </bits>
      <bits name="rCA_TX_DUMP_CLK_GATING" pos="15" access="rw" rst="0">
        <comment>CA TX dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module CA TX dump
</comment>
      </bits>
      <bits name="rMCA_FFT128_CLK_GATING" pos="16" access="rw" rst="0">
        <comment>MCA FFT128 dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module Multi CA FFT 128
</comment>
      </bits>
      <bits name="rMCA_IFFT128_CLK_GATING" pos="17" access="rw" rst="0">
        <comment>MCA IFFT128 dump fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module Multi CA IFFT 128
</comment>
      </bits>
      <bits name="rNB_ACC_CLK_GATING" pos="18" access="rw" rst="0">
        <comment>NB ACC fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module NB ACC
</comment>
      </bits>
      <bits name="rPSS230_CLK_GATING" pos="19" access="rw" rst="0">
        <comment>PSS230 fine clock gating,
1'b0: free running
1'b1: clock gated by the clock enabled signal which generated from sub-module PSS230
</comment>
      </bits>
    </reg32>
    <reg32 name="rAPB_SW_RST" protect="w">
      <bits name="rAPB_SW_RST" pos="0" access="w" rst="0">
        <comment>NBIOT CORE APB domain reset by software, auto-clear to zero when write 1 to this register by DSP
0: default value;
1: Reset whole sub-module.</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_DEBUG_GPO" protect="rw">
      <bits name="rNBIOT_DEBUF_GPO" pos="3:0" access="rw" rst="0">
        <comment>Debug General Purpose Output 
Remark: need to set rNBIOT_MONITOR to 0x1a3</comment>
      </bits>
    </reg32>
    <hole size="1*32"></hole>
    <reg32 name="rNBIOT_RX_ICTRL" protect="rw">
      <bits name="rNBIOT_RX_ICTRL" pos="9:0" access="rw" rst="0">
        <comment>RX data input control: Please refer to diagram below in detail
CA RX input data right shift control
bit 9-7:
0: No left shift
1: Right shift 1 bit
2: Right shift 2 bit
3: Right shift 3 bit
4: Right shift 4 bit
5~7: Reserved
bit 6-3:
Select the CA RX source input stage 0 data to RX input data stream path if rNBIOT_RX_ICTRL[0]=1
0: LVDS CA RX input 0
1: LVDS CA RX input 1
...
15: LVDS CA RX input 15
bit 2:
Select the source to CA RX dump CA data 0
0: CA RX source input stage 0
1: DFE RX input
bit 1:
Select the CA RX source input stage 0 data path
0: LVDS CA RX input
1: NB CA TX output
bit 0:
Select the source to RX input data stream path
0: DFE RX input 
1: LVDS CA RX input
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_TX_OCTRL" protect="rw">
      <bits name="rNBIOT_TX_OCTRL" pos="1:0" access="rw" rst="0">
        <comment>TX data output control: Please refer to diagram below in detail:
bit 1:
Select the source to LVDSTX data path
0: CA TX dump CA Tx data 0 output 
1: TX frontend output
bit 0:
Select the source to DFE TX data path
0: TX frontend output
1: CA TX dump CA Tx data 0 output
</comment>
      </bits>
    </reg32>
    <reg32 name="rNBIOT_CA_STATUS" protect="w1c">
      <bits name="rNBIOT_CA_STATUS" pos="0" access="w1c" rst="0">
        <comment>CA data valid status (Write 1 clear status)
0: no CA data valid occur
1: CA data valid occur
</comment>
      </bits>
    </reg32>    
    <hole size="51*32"></hole>
    <reg32 name="rNBIOT_REVISION" protect="r">
      <bits name="rMINOR_REV" pos="7:0" access="r" rst="0">
        <comment>Minor Revision</comment>
      </bits>
      <bits name="rMAJOR_REV" pos="15:8" access="r" rst="0">
        <comment>MAJOR Revision</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_ds_bsel.xml">
  <module name="nb_ds_bsel" category="NBIOT_PHY">
    <reg32 name="rDS_BSEL_START" protect="w1c">
      <bits name="rDS_BSEL_START" pos="0" access="w1c" rst="0x0">
        <comment>DS_BSEL accelerator start</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_CTRL" protect="rw">
      <bits name="rTIMEOUT_VAL" pos="15:0" access="rw" rst="0x7fff">
        <comment>Maximum time out value for TX bit level processing in 61.44Mhz unit</comment>
      </bits>
      <bits name="rNUM_CANDIDATE" pos="17:16" access="rw" rst="0">
        <comment>Number of Candidate
0: 1 candidate
1: 2 candidate
2: 3 candidate
3: 4 candidate</comment>
      </bits>
      <bits name="rDBSP_EN" pos="18" access="rw" rst="0">
        <comment>Bit de-selection and combining
0: Disable
1: enable
Remark: When this bit is disabled, the output data number is equal to rDESCR_SIZE0 and it only support 1 candidate.</comment>
      </bits>
      <bits name="rDESCR_EN" pos="19" access="rw" rst="0">
        <comment>Descramble enable
0: Disable
1: enable</comment>
      </bits>
      <bits name="rNCB_MINUS_SIZE" pos="27:20" access="rw" rst="0">
        <comment>NCB minus:  NCB - 3ND</comment>
      </bits>
      <bits name="rMEM_SEL" pos="31" access="rw" rst="0">
        <comment>Memory Selection
0: Memory 5
1: Memory 4 + Memory 7
</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_0" protect="rw">
      <bits name="rDS_X1_0" pos="30:0" access="rw" rst="0">
        <comment>Descramble X1 value for candidate 0</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_1" protect="rw">
      <bits name="rDS_X1_1" pos="30:0" access="rw" rst="0">
        <comment>Descramble X1 value for candidate 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_2" protect="rw">
      <bits name="rDS_X1_2" pos="30:0" access="rw" rst="0">
        <comment>Descramble X1 value for candidate 2</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X1_3" protect="rw">
      <bits name="rDS_X1_3" pos="30:0" access="rw" rst="0x40">
        <comment>Descramble X1 value for candidate 3</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_0" protect="rw">
      <bits name="rDS_X2_0" pos="30:0" access="rw" rst="0">
        <comment>Descramble X2 value for candidate 0</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_1" protect="rw">
      <bits name="rDS_X2_1" pos="30:0" access="rw" rst="0">
        <comment>Descramble X2 value for candidate 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_2" protect="rw">
      <bits name="rDS_X2_2" pos="30:0" access="rw" rst="0">
        <comment>Descramble X2 value for candidate 2</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_X2_3" protect="rw">
      <bits name="rDS_X2_3" pos="30:0" access="rw" rst="0x40">
        <comment>Descramble X2 value for candidate 3</comment>
      </bits>
    </reg32>
    <reg32 name="rDESR_CFG1" protect="rw">
      <bits name="rIDATA_SIZE0" pos="13:0" access="rw" rst="0">
        <comment>Descramble size 0 / Demapping size 0</comment>
      </bits>
      <bits name="rIDATA_SIZE1" pos="29:16" access="rw" rst="0">
        <comment>Descramble size 1 / Demapping size 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDESR_CFG2" protect="rw">
      <bits name="rIDATA_SIZE3" pos="13:0" access="rw" rst="0">
        <comment>Descramble size 3 / Demapping size 3</comment>
      </bits>
      <bits name="rIDATA_SIZE2" pos="29:16" access="rw" rst="0">
        <comment>Descramble size 2 / Demapping size 2</comment>
      </bits>
    </reg32>
    <reg32 name="rDESR_CFG3" protect="rw">
      <bits name="rDESR_IBUF_START_ADDR_0" pos="12:0" access="rw" rst="0">
        <comment>Descramble/Demapping input buffer start address 0</comment>
      </bits>
      <bits name="rDESR_IBUF_START_ADDR_1" pos="28:16" access="rw" rst="0">
        <comment>Descramble/Demapping input buffer start address 1</comment>
      </bits>
    </reg32>
    <reg32 name="rDESR_CFG4" protect="rw">
      <bits name="rDESR_IBUF_START_ADDR_3" pos="12:0" access="rw" rst="0">
        <comment>Descramble/Demapping input buffer start address 3</comment>
      </bits>
      <bits name="rDESR_IBUF_START_ADDR_2" pos="28:16" access="rw" rst="0">
        <comment>Descramble/Demapping input buffer start address 4</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_OMEM_START_ADDR" protect="rw">
      <bits name="rDS_BSEL_OMEM_START_SADDR" pos="28:16" access="rw" rst="0">
        <comment>RX DS_BSEL output memory start X1/X2 state address</comment>
      </bits>
      <bits name="rDS_BSEL_OMEM_START_ADDR" pos="12:0" access="rw" rst="0">
        <comment>DS_BSEL output memory start address</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_DS_X1" protect="r">
      <bits name="rDS_BSEL_DS_X1" pos="30:0" access="r" rst="0">
        <comment>The last candidate Descramble X2 state value</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_DS_X2" protect="r">
      <bits name="rDS_BSEL_DS_X2" pos="30:0" access="r" rst="0">
        <comment>The last candidate Descramble X2 state value</comment>
      </bits>
    </reg32>
    <reg32 name="rDS_BSEL_STATUS" protect="r">
      <bits name="rDone" pos="0" access="wc" rst="0">
        <comment>(This bit is write 1 clear)
0: No Done
1: Done</comment>
      </bits>
      <bits name="rOverwritten" pos="1" access="r" rst="0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
0: Normal
1: Error</comment>
      </bits>
      <bits name="rBUS_Error" pos="3:2" access="r" rst="0">
        <comment>0: Normal
1: Error
Bit 0: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
      <bits name="rTimeout" pos="4" access="r" rst="0">
        <comment>0: Normal
1: Error</comment>
      </bits>
      <bits name="rStatus" pos="5" access="r" rst="0">
        <comment>0: Idle
1: On-going
</comment>
      </bits>
    </reg32>
    <reg32 name="rDEMAP_CTRL" protect="rw">
      <bits name="rDEMAP_EN" pos="0" access="rw" rst="0">
        <comment>Demapping Enable
0: disable
1: enable
</comment>
      </bits>
      <bits name="rMOD_TYPE" pos="2:1" access="rw" rst="0">
        <comment>Modulation Type
0: Not available
1: QPSK
2: QAM16
3: QAM64
</comment>
      </bits>
      <bits name="rDEMAP_LLR_FMT" pos="5:3" access="rw" rst="0">
        <comment>Demapping LLR format selection
0: 8.0x2^-5
1: 8.0x2^-4
2: 8.0x2^-3
3: 8.0x2^-2
4: 8.0x2^-1
5: 8.0x2^0
6: 8.0x2^1
7: 8.0x2^2
</comment>
      </bits>
      <bits name="rDEMAP_IFMT" pos="6" access="rw" rst="0">
        <comment>DEMAP input format
0: 1 H for 1 Y
1: 2 H for 1 Y
</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_fft_rsrp.xml">
  <module name="nb_fft_rsrp" category="NBIOT_PHY">
    <reg32 name="rFFT_CTRL" protect="rw">
      <bits name="rFFT_EN" pos="0" access="rw" rst="0x0">
        <comment>FFT calculation enable</comment>
      </bits>
      <bits name="rFFT_DONE_INT_PERIOD" pos="1" access="rw" rst="0x0">
        <comment>the period of FFT done interrupt, 0: one time per-subframe; 1: twice per-subframe.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_CFG" protect="rw">
      <bits name="rFFT_RSRP_EN" pos="0:0" access="rw" rst="0x0">
        <comment>FFT/RSRP enable</comment>
      </bits>
      <bits name="rSCALING_ALPHA" pos="3:1" access="rw" rst="0x3">
        <comment>FFT result scaling</comment>
      </bits>
      <bits name="rFFT_RSRP_MODE" pos="4" access="rw" rst="0x0">
        <comment>0: FFT disabled, 5 RSRP CELLs calculation mode; 1:  FFT + 2 RSRP Cell calculation mode.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_OFDM_CP_OS" protect="rw">
      <bits name="rFFT_OFDM_CP_OS" pos="3:0" access="rw" rst="0x0">
        <comment>FFT OFDM symbol CP offset</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL_EN" protect="rw">
      <bits name="rRSRP_CELL0_EN" pos="0" access="rw" rst="0">
        <comment>RSRP Cell0 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL1_EN" pos="1" access="rw" rst="0">
        <comment>RSRP Cell1 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL2_EN" pos="2" access="rw" rst="0">
        <comment>RSRP Cell2 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL3_EN" pos="3" access="rw" rst="0">
        <comment>RSRP Cell3 Enabled.</comment>
      </bits>
      <bits name="rRSRP_CELL4_EN" pos="4" access="rw" rst="0">
        <comment>RSRP Cell4 Enabled.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL0_START_POS" protect="rw">
      <bits name="rRSRP_CELL0_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell0 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL1_START_POS" protect="rw">
      <bits name="rRSRP_CELL1_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell1 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL2_START_POS" protect="rw">
      <bits name="rRSRP_CELL2_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell2 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL3_START_POS" protect="rw">
      <bits name="rRSRP_CELL3_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell3 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_CELL4_START_POS" protect="rw">
      <bits name="rRSRP_CELL4_START_POS" pos="14:0" access="rw" rst="0">
        <comment>Frame start position of RSRP Cell4 based on global timer.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL0_OFDM_CP_OS" protect="rw">
      <bits name="rCELL0_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL0.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL1_OFDM_CP_OS" protect="rw">
      <bits name="rCELL1_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL1.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL2_OFDM_CP_OS" protect="rw">
      <bits name="rCELL2_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL2.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL3_OFDM_CP_OS" protect="rw">
      <bits name="rCELL3_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL3.</comment>
      </bits>
    </reg32>
    <reg32 name="rCELL4_OFDM_CP_OS" protect="rw">
      <bits name="rCELL4_OFDM_CP_OS" pos="3:0" access="rw" rst="0">
        <comment>OFDM symbol CP offset for NCELL4.</comment>
      </bits>
    </reg32>
    <reg32 name="rNCELL_V_SHIFT" protect="rw">
      <bits name="rNCELL0_V_SHIFT" pos="2:0" access="rw" rst="0">
        <comment>vshift of NCELL0.</comment>
      </bits>
      <bits name="rNCELL1_V_SHIFT" pos="5:3" access="rw" rst="0">
        <comment>vshift of NCELL1.</comment>
      </bits>
      <bits name="rNCELL2_V_SHIFT" pos="8:6" access="rw" rst="0">
        <comment>vshift of NCELL2.</comment>
      </bits>
      <bits name="rNCELL3_V_SHIFT" pos="11:9" access="rw" rst="0">
        <comment>vshift of NCELL3.</comment>
      </bits>
      <bits name="rNCELL4_V_SHIFT" pos="14:12" access="rw" rst="0">
        <comment>vshift of NCELL4.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_SUBF_IDX" protect="rw">
      <bits name="rNCELL0_CFG_SUBF_IDX" pos="3:0" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL1_CFG_SUBF_IDX" pos="7:4" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL2_CFG_SUBF_IDX" pos="11:8" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL3_CFG_SUBF_IDX" pos="15:12" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
      <bits name="rNCELL4_CFG_SUBF_IDX" pos="19:16" access="rw" rst="0">
        <comment>confiugred subframe idx when RSRX cell enabled.</comment>
      </bits>
    </reg32>
    <reg32 name="rRSRP_MEM_BADDR" protect="rw">
      <bits name="rRSRP_MEM_BADDR" pos="8:0" access="rw" rst="0">
        <comment>Offset address for RSRP write memory buffer.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_STATUS" protect="r">
      <bits name="RESERVED" pos="0" access="rw" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rFFT_BUF_STATUS" pos="2:1" access="w1c" rst="0">
        <comment>Indicated whether the data in ping-pong buffer is updated.</comment>
      </bits>
      <bits name="rFFT_BUF_SWITCH_STATUS" pos="3" access="r" rst="0">
        <comment>FFT buffer ping-pong flag</comment>
      </bits>
      <bits name="rNCELL0_TRIPLE_BUF_STATUS" pos="6:4" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL0_TRIPLE_BUF_SWITCH_FLAG" pos="8:7" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL1_TRIPLE_BUF_STATUS" pos="11:9" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL1_TRIPLE_BUF_SWITCH_FLAG" pos="13:12" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL2_TRIPLE_BUF_STATUS" pos="16:14" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL2_TRIPLE_BUF_SWITCH_FLAG" pos="18:17" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL3_TRIPLE_BUF_STATUS" pos="21:19" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL3_TRIPLE_BUF_SWITCH_FLAG" pos="23:22" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
      <bits name="rNCELL4_TRIPLE_BUF_STATUS" pos="26:24" access="w1c" rst="0">
        <comment>Indicated which triple buffer is UPDATED</comment>
      </bits>
      <bits name="rNCELL4_TRIPLE_BUF_SWITCH_FLAG" pos="28:27" access="r" rst="3">
        <comment>Indicated which buffer is just updated when interrupt asserted.</comment>
      </bits>
    </reg32>
    <reg32 name="rSV_CELL_SUBF_IDX" protect="r">
      <bits name="rSV_CELL_SUBF_IDX" pos="3:0" access="r" rst="0">
        <comment>subframe index of serving cell</comment>
      </bits>
    </reg32>
    <reg32 name="rNCELL_SUBF_IDX" protect="r">
      <bits name="rNCELL0_SUBF_IDX" pos="3:0" access="r" rst="0">
        <comment>subframe idx of NCELL0</comment>
      </bits>
      <bits name="rNCELL1_SUBF_IDX" pos="7:4" access="r" rst="0">
        <comment>subframe idx of NCELL1</comment>
      </bits>
      <bits name="rNCELL2_SUBF_IDX" pos="11:8" access="r" rst="0">
        <comment>subframe idx of NCELL2</comment>
      </bits>
      <bits name="rNCELL3_SUBF_IDX" pos="15:12" access="r" rst="0">
        <comment>subframe idx of NCELL3</comment>
      </bits>
      <bits name="rNCELL4_SUBF_IDX" pos="19:16" access="r" rst="0">
        <comment>subframe idx of NCELL4</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_BUF_OVWR" protect="r">
      <bits name="rFFT_BUF_OVWR" pos="1:0" access="r" rst="0">
        <comment>FFT pingpong buffer overwritten status</comment>
      </bits>
      <bits name="rRSRP_CELL0_BUF_OVWR" pos="4:2" access="r" rst="0">
        <comment>RSRP Cell0 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL1_BUF_OVWR" pos="7:5" access="r" rst="0">
        <comment>RSRP Cell1 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL2_BUF_OVWR" pos="10:8" access="r" rst="0">
        <comment>RSRP Cell2 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL3_BUF_OVWR" pos="13:11" access="r" rst="0">
        <comment>RSRP Cell3 triple buffer over-written status.</comment>
      </bits>
      <bits name="rRSRP_CELL4_BUF_OVWR" pos="16:14" access="r" rst="0">
        <comment>RSRP Cell4 triple buffer over-written status.</comment>
      </bits>
      <bits name="rFFT_MEM_WR_ERR" pos="18:17" access="r" rst="0">
        <comment>FFT write buffer bus error</comment>
      </bits>
      <bits name="rRSRP0_MEM_WR_ERR" pos="20:19" access="r" rst="0">
        <comment>RSRP CELL0 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP1_MEM_WR_ERR" pos="22:21" access="r" rst="0">
        <comment>RSRP CELL1 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP2_MEM_WR_ERR" pos="24:23" access="r" rst="0">
        <comment>RSRP CELL2 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP3_MEM_WR_ERR" pos="26:25" access="r" rst="0">
        <comment>RSRP CELL3 write buffer bus error</comment>
      </bits>
      <bits name="rRSRP4_MEM_WR_ERR" pos="28:27" access="r" rst="0">
        <comment>RSRP CELL4 write buffer bus error</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_BUF_IDX" protect="r">
      <bits name="rFFT_PINGPONG_BUF_IDX" pos="0" access="r" rst="0">
        <comment>FFT pingpong buf idx</comment>
      </bits>
      <bits name="rRSRP0_TRI_BUF_IDX" pos="2:1" access="r" rst="0">
        <comment>RSRP0 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP1_TRI_BUF_IDX" pos="4:3" access="r" rst="0">
        <comment>RSRP1 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP2_TRI_BUF_IDX" pos="6:5" access="r" rst="0">
        <comment>RSRP2 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP3_TRI_BUF_IDX" pos="8:7" access="r" rst="0">
        <comment>RSRP3 Triple buffer idx</comment>
      </bits>
      <bits name="rRSRP4_TRI_BUF_IDX" pos="10:9" access="r" rst="0">
        <comment>RSRP4 Triple buffer idx</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_RSRP_SUBF_IDX" protect="r">
      <bits name="rFFT_SUBF_IDX" pos="3:0" access="r" rst="0">
        <comment>FFT subframe idx</comment>
      </bits>
      <bits name="rRSRP0_SUBF_IDX" pos="7:4" access="r" rst="0">
        <comment>RSRP Cell0 subframe idx</comment>
      </bits>
      <bits name="rRSRP1_SUBF_IDX" pos="11:8" access="r" rst="0">
        <comment>RSRP Cell1 subframe idx</comment>
      </bits>
      <bits name="rRSRP2_SUBF_IDX" pos="15:12" access="r" rst="0">
        <comment>RSRP Cell2 subframe idx</comment>
      </bits>
      <bits name="rRSRP3_SUBF_IDX" pos="19:16" access="r" rst="0">
        <comment>RSRP Cell3 subframe idx</comment>
      </bits>
      <bits name="rRSRP4_SUBF_IDX" pos="23:20" access="r" rst="0">
        <comment>RSRP Cell4 subframe idx</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_intc.xml">
  <module name="nb_intc" category="NBIOT_PHY">
    <reg32 name="rRX_INT_DSP_MASKING" protect="rw">
      <bits name="rRX_INT_DSP_MASKING" pos="0:0" access="rw" rst="0x0">
        <comment>Interrupt Masking bit for RX_INT_DSP</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_MASKING" protect="rw">
      <bits name="rRX_INT_MCU_MASKING" pos="0:0" access="rw" rst="0x0">
        <comment>Interrupt Masking bit for RX_INT_MCU</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_INT_DSP_MASKING" protect="rw">
      <bits name="rTX_INT_DSP_MASKING" pos="0:0" access="rw" rst="0x0">
        <comment>Interrupt Masking bit for TX_INT_DSP</comment>
      </bits>
    </reg32>
    <reg32 name="rACC_INT_MASKING" protect="rw">
      <bits name="rFFT_DONE_INT_MASKING" pos="0:0" access="rw" rst="0">
        <comment>Interrupt masking bit from the interrupt of fft_done_int</comment>
      </bits>
      <bits name="rNCELL0_RSRP_DEC_DONE_INT_MASKING" pos="1:1" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL0 decode done intterupt</comment>
      </bits>
      <bits name="rNCELL1_RSRP_DEC_DONE_INT_MASKING" pos="2:2" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL1 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL2_RSRP_DEC_DONE_INT_MASKING" pos="3:3" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL2 decode done interrpt</comment>
      </bits>
      <bits name="rNCELL3_RSRP_DEC_DONE_INT_MASKING" pos="4:4" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL3 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL4_RSRP_DEC_DONE_INT_MASKING" pos="5:5" access="rw" rst="0">
        <comment>Interrupt masking bit of NCELL4 decode done interrupt</comment>
      </bits>
      <bits name="rPSS_SF_DONE_INT_MASKING" pos="6:6" access="rw" rst="0">
        <comment>Interrupt masking bit of PSS SF done interrupt</comment>
      </bits>
      <bits name="rSSS_SF_DONE_INT_MASKING" pos="7:7" access="rw" rst="0">
        <comment>Interrupt masking bit of SSS SF done interrupt</comment>
      </bits>
      <bits name="rCFO_SF_DONE_INT_MASKING" pos="8:8" access="rw" rst="0">
        <comment>Interrupt masking bit of CFO SF done interrupt</comment>
      </bits>
      <bits name="rVIT_DEC_DONE_INT_MASKING" pos="9:9" access="rw" rst="0">
        <comment>Interrupt masking bit of Viterbi decode done interrupt</comment>
      </bits>
      <bits name="rAGC_PWR_INT_MASKING" pos="10:10" access="rw" rst="0">
        <comment>Interrupt masking bit of AGC interrupt masking</comment>
      </bits>
      <bits name="rDS_BSEL_INT_MASKING" pos="11:11" access="rw" rst="0">
        <comment>Interrupt masking bit of DS_BSEL interrupt</comment>
      </bits>
      <bits name="rPUSCH_ENC_INT_MASKING" pos="12:12" access="rw" rst="0">
        <comment>Interrupt masking bit of PUSCH encoder interrupt</comment>
      </bits>
      <bits name="rTX_CHSC_INT_MASKING" pos="13:13" access="rw" rst="0">
        <comment>Interrupt masking bit of TX_CHSC interrupt</comment>
      </bits>
      <bits name="rFFT_512_DONE_INT_MASKING" pos="14:14" access="rw" rst="0">
        <comment>Interrupt masking bit of FFT_512 done interrupt</comment>
      </bits>
      <bits name="rNPRS_ACC1_DONE_INT_MASKING" pos="15:15" access="rw" rst="0">
        <comment>Interrupt masking bit of NPRS_ACC1 done interrupt</comment>
      </bits>
      <bits name="rFINE_IFFT_DONE_INT_MASKING" pos="16:16" access="rw" rst="0">
        <comment>Interrupt masking bit of FINE_IFFT done interrupt</comment>
      </bits>
      <bits name="rTX_DUMP_DONE_INT_MASKING" pos="17:17" access="rw" rst="0">
        <comment>Interrupt masking bit of TX dump done interrupt</comment>
      </bits>
      <bits name="rCA_RX_DUMP_DONE_INT_MASK" pos="18:18" access="rw" rst="0">
        <comment>Interrupt masking bit of CA RX Dump done interrupt</comment>
      </bits>
      <bits name="rCA_TX_DUMP_DONE_INT_MASK" pos="19:19" access="rw" rst="0">
        <comment>Interrupt masking bit of CA TX dump done interrupt</comment>
      </bits>
      <bits name="rMCA_FFT_DONE_INT_MASK" pos="20:20" access="rw" rst="0">
        <comment>Interrupt masking bit of multiple CA FFT done interrupt</comment>
      </bits>
      <bits name="rMCA_IFFT_DONE_INT_MASK" pos="21:21" access="rw" rst="0">
        <comment>Interrupt masking bit of multiple CA IFFT done interrupt</comment>
      </bits>
      <bits name="rNB_ACC_DONE_INT_MASK" pos="22:22" access="rw" rst="0">
        <comment>Interrupt masking bit of NB ACC done interrupt</comment>
      </bits>
      <bits name="rPSS230_DONE_INT_MASK" pos="23:23" access="rw" rst="0">
        <comment>Interrupt masking bit of PSS230 done interrupt</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_DSP_STATUS" protect="w1c">
      <bits name="rRX_INT_DSP_STATUS" pos="0" access="w1c" rst="0">
        <comment>interrupt status of RX_INT_DSP, write 1 clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rRX_INT_MCU_STATUS" protect="w1c">
      <bits name="rRX_INT_MCU_STATUS" pos="0:0" access="w1c" rst="0">
        <comment>Interrupt status of RX_INT_MCU, write 1 clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_INT_DSP_STATUS" protect="w1c">
      <bits name="rTX_INT_DSP_STATUS" pos="0:0" access="w1c" rst="0">
        <comment>Interrupt status of TX_INT_DSP, write 1 clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rACC_INT_STATUS" protect="w1c">
      <bits name="rFFT_INT_STATUS" pos="0:0" access="w1c" rst="0">
        <comment>Interrupt status of fft_sf_done_int</comment>
      </bits>
      <bits name="rNCELL0_RSRP_DEC_DONE_INT_STATUS" pos="1:1" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell0 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL1_RSRP_DEC_DONE_INT_STATUS" pos="2" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell1 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL2_RSRP_DEC_DONE_INT_STATUS" pos="3" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell20 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL3_RSRP_DEC_DONE_INT_STATUS" pos="4" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell3 decode done interrupt</comment>
      </bits>
      <bits name="rNCELL4_RSRP_DEC_DONE_INT_STATUS" pos="5" access="w1c" rst="0">
        <comment>Interrupt status of RSRP Cell4 decode done interrupt</comment>
      </bits>
      <bits name="rPSS_SF_DONE_INT_STATUS" pos="6" access="w1c" rst="0">
        <comment>Interrupt status of PSS SF done interrupt</comment>
      </bits>
      <bits name="rSSS_SF_DONE_INT_STATUS" pos="7" access="w1c" rst="0">
        <comment>Interrupt status of SSS SF done interrupt</comment>
      </bits>
      <bits name="rCFO_SF_DONE_INT_STATUS" pos="8" access="w1c" rst="0">
        <comment>Interrupt status of CFO SF done interrupt</comment>
      </bits>
      <bits name="rVIT_DEC_DONE_INT_STATUS" pos="9" access="w1c" rst="0">
        <comment>Interrupt status of Viterbi decode done</comment>
      </bits>
      <bits name="rAGC_INT_STATUS" pos="10" access="w1c" rst="0">
        <comment>Interrupt status of AGC interrupt</comment>
      </bits>
      <bits name="rDS_BSEL_INT_STATUS" pos="11" access="w1c" rst="0">
        <comment>Interrupt status of DS_BSEL interrupt</comment>
      </bits>
      <bits name="rPUSCH_ENC_INT_STATUS" pos="12" access="w1c" rst="0">
        <comment>Interrupt status of PUSCH Encoder interrupt</comment>
      </bits>
      <bits name="rTX_CHSC_INT_STATUS" pos="13" access="w1c" rst="0">
        <comment>Interrupt status of TX_CHSC interrupt</comment>
      </bits>
      <bits name="rFFT_512_DONE_INT_STATUS" pos="14" access="w1c" rst="0">
        <comment>Interrupt status of FFT_512 done interrupt</comment>
      </bits>
      <bits name="rNPRS_ACC1_DONE_INT_STATUS" pos="15" access="w1c" rst="0">
        <comment>Interrupt status of NPRS_ACC1 done interrupt</comment>
      </bits>
      <bits name="rFINT_IFFT_DONE_INT_STATUS" pos="16" access="w1c" rst="0">
        <comment>Interrupt status of FINE IFFT done interrupt</comment>
      </bits>
      <bits name="rTX_DUMP_DONE_INT_STATUS" pos="17:17" access="w1c" rst="0">
        <comment>Interrupt status of TX dump done interrupt</comment>
      </bits>
      <bits name="rCA_RX_DUMP_DONE_INT_STATUS" pos="18:18" access="w1c" rst="0">
        <comment>Interrupt status of CA RX dump done interrupt</comment>
      </bits>
      <bits name="rCA_TX_DUMP_DONE_INT_STATUS" pos="19:19" access="w1c" rst="0">
        <comment>Interrupt status of CA TX dump done interrupt</comment>
      </bits>
      <bits name="rMCA_FFT_DONE_INT_STATUS" pos="20:20" access="w1c" rst="0">
        <comment>Interrupt status of multiple CA FFT done interrupt</comment>
      </bits>
      <bits name="rMCA_IFFT_DONE_INT_STATUS" pos="21:21" access="w1c" rst="0">
        <comment>Interrupt status of multiple CA IFFT done interrupt</comment>
      </bits>
      <bits name="rNB_ACC_DONE_INT_STATUS" pos="22:22" access="w1c" rst="0">
        <comment>Interrupt status of NB ACC done interrupt</comment>
      </bits>
      <bits name="rPSS230_DONE_INT_STATUS" pos="23:23" access="w1c" rst="0">
        <comment>Interrupt status of PSS230 done interrupt</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_meas.xml">
  <module name="nb_meas" category="NBIOT_PHY">
    <reg32 name="rASP_ON" protect="w">
      <bits name="rASP_ON" pos="0" access="w" rst="0">
        <comment>Symbol power accumulation enable/disable signal and effective at subframe boundary.
      1 : enable
      0 : disable</comment>
      </bits>
    </reg32>
    <reg32 name="rASP_CTRL" protect="rw">
      <bits name="rASP_INPUT_MODE" pos="13" access="rw" rst="0">
        <comment>Switching register to choose input source data for symbol power calculation
0: normal rx data
1: rx data without dc offset</comment>
      </bits>
      <bits name="rASP_GAIN" pos="12:9" access="rw" rst="0">
        <comment>Gain used in shift and saturation of accumulation power value.
Bit[3:0]	Gain
0000	        2^-24 (default)
0001	        2^-23 
0010	        2^-22
0011	        2^-21</comment>
      </bits>
      <bits name="rASP_LENGTH" pos="8:7" access="rw" rst="0">
        <comment>Accumulation length of samples in every symbol.
    0: 128   
    1: 64
    2: 32
    3: 16</comment>
      </bits>
      <bits name="rASP_OFFSET" pos="6:0" access="rw" rst="0">
        <comment>Offset of samples from symbols' boundaries which is the start boundary of agc symbol power calculation.</comment>
      </bits>
    </reg32>
    <reg32 name="rASP_RD_ADDR" protect="rw">
      <bits name="rASP_RD_ADDR" pos="5:0" access="rw" rst="0">
        <comment>Reading address for DSP to read asp response ram, and this register would auto-increment whenever access the 'rASP_RD_DATA' register
PING buffer address: 0~20
PONG buffer address: 21~41
</comment>
      </bits>
    </reg32>
    <reg32 name="rDC_OFS_CFG_DATA" protect="rw">
      <bits name="rDC_OFS_CFG_DATA" pos="31:0" access="rw" rst="0">
        <comment>Bit[27:16]: Q DC offset configuration
Bit[11:0]:   I DC offset configuration
</comment>
      </bits>
    </reg32>
    <hole size="7*32"></hole>
    <reg32 name="rASP_STATUS" protect="r">
      <bits name="rASP_DONE_STATUS" pos="0" access="w1c" rst="0">
        <comment>Report agc symbol power and DCC done status, write '1' to clear this status</comment>
      </bits>
      <bits name="rASP_BUF_PING_PONG_IDX" pos="1" access="r" rst="0">
        <comment>Index bit to indicate which buffer is updated of PING-PONG   
1: PONG buffer data is updated
0: PING buffer data is updated</comment>
      </bits>
    </reg32>
    <reg32 name="rASP_RD_DATA" protect="r">
      <bits name="rASP_RD_DATA" pos="31:0" access="r" rst="0">
        <comment>Data = mem[rASP_RD_ADDR] which is the ASP response memory data content. The ASP_RD_ADDR would auto increase whenever access this register. 
ASP response Memory address range is 0-41
Address(0~6,21~27): symbol power, bit[15:0] for symbol 0,2,4,6,8,10,12 and bit[31:16] for symbol 1,3,5,7,9,11,13
Address(7~20,28~41):dc_offset value, bit[15:0] for I and bit[31:16] for Q
</comment>
      </bits>
    </reg32>
    <hole size="51*32"></hole>
    <reg32 name="rFFT_512_CTRL" protect="rw">
      <bits name="rFFT_FWD_INV" pos="0" access="rw" rst="0">
        <comment>Forward/Inverse FFT transform computing selection</comment>
      </bits>
      <bits name="rFFT_BUF_IDX" pos="1" access="rw" rst="0">
        <comment>PING-PONG memory selection
1'b0: Memory0;
1'b1: Memory1.</comment>
      </bits>
      <bits name="rFFT_SCALING_FACTOR" pos="4:2" access="rw" rst="0">
        <comment>alphaFFT scaling, it can be implemented by bit shift,
3'd0: 2^-3
3'd1: 2^-2
3'd2: 2^-1
3'd3: 2^0  (default)
3'd4: 2^1
3'd5: 2^2
3'd6: 2^3
3'd7: 2^4
</comment>
      </bits>
      <bits name="rFFT_AMP_SCALING_FACTOR" pos="7:5" access="rw" rst="0">
        <comment>alphaFFT_amp_out scaling for amplitude square output, it can be implemented by bit shift,
3'd0: 2^-3
3'd1: 2^-2
3'd2: 2^-1
3'd3: 2^0  (default)
3'd4: 2^1
3'd5: 2^2
3'd6: 2^3
3'd7: 2^4 
</comment>
      </bits>
      <bits name="rFFT_AMP_CAL_EN" pos="8" access="rw" rst="0">
        <comment>IFFT Output amptitude data
1'b0: IFFT output normal data(I+j*Q);
1'b1: IFFT output amptitude data(I^2+Q^2).</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_512_START" protect="w">
      <bits name="rFFT_512_START" pos="0" access="w" rst="0">
        <comment>FFT start indication, when write 1 to this register, a high active pulse will be generated and input to FFT engine to start FFT calculation.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_512_STATUS" protect="r">
      <bits name="rFFT_DONE" pos="0" access="w1c" rst="0">
        <comment>FFT done status, write 1 clear.</comment>
      </bits>
      <bits name="rMEM_BUS_ERR" pos="2:1" access="r" rst="0">
        <comment>An error grant is received when FFT request memory write bus to store FFT result. 
Bit1: DSP control error;
Bit0: Accelerator memory access error.</comment>
      </bits>
      <bits name="rFFT_IN_UNDERFLOW" pos="3" access="r" rst="0">
        <comment>This register is used to check the range of FFT/IFFT input,  
1'b1: absolute maximum FFT/IFFT input less than 32, in this case, the resolution of FFT/IFFT output will loss 1bit;
1'b0: normally.
</comment>
      </bits>
    </reg32>
    <hole size="61*32"></hole>
    <reg32 name="rNPRS_ACC1_START" protect="w">
      <bits name="rNPRS_ACC1_START" pos="0" access="w" rst="0">
        <comment>NPRS accelerator 1 Start</comment>
      </bits>
    </reg32>
    <reg32 name="rNPRS_ACC1_CTRL" protect="rw">
      <bits name="rTIMEOUT_VAL" pos="15:0" access="rw" rst="0x7ff">
        <comment>Maximum time out value in 61.44Mhz unit</comment>
      </bits>
      <bits name="rMODE" pos="17:16" access="rw" rst="0">
        <comment>Mode selection:
2'b00: copy + dot product
2'b01: dot product 
2'b10: copy</comment>
      </bits>
      <bits name="rCP_SRC_MEM" pos="18" access="rw" rst="0">
        <comment>Copy Source memory before sequence dot product
0: Memory 0
1: Memory 1</comment>
      </bits>
      <bits name="rCP_BR_ADDR_EN" pos="19" access="rw" rst="0">
        <comment>Copy memory with bit-reversed address write location enable
0: Disable
1: Enable</comment>
      </bits>
      <bits name="rDP_DST_MEM" pos="20" access="rw" rst="0">
        <comment>Destination memory after sequence dot product
0: Memory 0
1: Memory 1</comment>
      </bits>
      <bits name="rDP_BR_ADDR_EN" pos="21" access="rw" rst="0">
        <comment>Dot Product from memory 5 to memory 0/1 with bit-reversed address write location enable
0: Disable
1: Enable</comment>
      </bits>
      <bits name="rCONJ_SEQ_EN" pos="22" access="rw" rst="0">
        <comment>Conjugate Sequence data Enable
0: Disable
1: Enable</comment>
      </bits>
    </reg32>
    <reg32 name="rNPRS_ACC1_LEN" protect="rw">
      <bits name="rNPRS_ACC1_LEN" pos="8:0" access="rw" rst="0x1ff">
        <comment>Operation length -1 
Default : (511)</comment>
      </bits>
    </reg32>
    <reg32 name="rSEQ_START_OFS_ADDR" protect="rw">
      <bits name="rSEQ_START_OFS_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Sequence Memory Start Offset Address</comment>
      </bits>
    </reg32>
    <reg32 name="rNPRS_ACC1_STATUS" protect="r">
      <bits name="rDone" pos="0" access="w1c" rst="0">
        <comment>(This bit is read write 1 clear)
0: No Done
1: Done</comment>
      </bits>
      <bits name="rOverwritten" pos="1" access="r" rst="0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
0: Normal
1: Error</comment>
      </bits>
      <bits name="rBUS Error 0" pos="3:2" access="r" rst="0">
        <comment>Read/Write process in Memory 0/1 (FFT/IFFT input/output memory)
0: Normal
1: Error
Bit 0: DSP control bus error
Bit 1: accelerator memory access collusion</comment>
      </bits>
      <bits name="rBUS Error 1" pos="5:4" access="r" rst="0">
        <comment>Read/Write process in Memory 5 (Copied FFT memory)</comment>
      </bits>
      <bits name="rBUS Error 2" pos="7:6" access="r" rst="0">
        <comment>Read process in Memory 4 (Sequence memory)</comment>
      </bits>
      <bits name="rTimeout" pos="8" access="r" rst="0">
        <comment>0: Normal
1: Error</comment>
      </bits>
    </reg32>
    <hole size="59*32"></hole>
    <reg32 name="rFINE_IFFT_START" protect="w">
      <bits name="rFINE_IFFT_START" pos="0" access="w" rst="0">
        <comment>Fine IFFT START
A pulse to grigger the Fine IFFT</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_CALC_CTRL" protect="rw">
      <bits name="rFINE_IFFT_T" pos="8:0" access="rw" rst="0">
        <comment>NPRS Coarse Timing Result  
Range is from 0 to 272</comment>
      </bits>
      <bits name="rFINE_IFFT_CALC_OS" pos="22:16" access="rw" rst="0">
        <comment>Fine IFFT calculation offset. Range is from 0 to 95.</comment>
      </bits>
      <bits name="rFINE_IFFT_CALC_LEN" pos="30:24" access="rw" rst="0">
        <comment>Fine IFFT calculation length. Range is from 1 to 96.</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_IOOUT_CTRL" protect="rw">
      <bits name="rFINE_IFFT_OUT_IQ_SCALE" pos="2:0" access="rw" rst="0">
        <comment>Fine IFFT output a+bj scaling
3'd0:x2^0(default)
3'd1:x2^-1
3'd2:x2^-2
3'd3:x2^-3
3'd4:x2^-4
3'd5:x2^-5
3'd6:x2^-6
3'd7:x2^-7
</comment>
      </bits>
      <bits name="rFINE_IFFT_OUT_PWR_SCALE" pos="10:8" access="rw" rst="0">
        <comment>Fine IFFT output power scaling
3'd0:x2^-3
3'd1:x2^-2
3'd2:x2^-1
3'd3:x2^0 (default)
3'd4:x2^1
3'd5:x2^2
3'd6:x2^3
3'd7:x2^4</comment>
      </bits>
      <bits name="rFINE_IFFT_OUT_SEL" pos="16" access="rw" rst="0">
        <comment>Fine IFFT output selection
1'b0: Output IFFT result: a+bj
1'b1: Output power result: a^2+b^2</comment>
      </bits>
      <bits name="rFINE_IFFT_IN_CTRL" pos="17" access="rw" rst="0">
        <comment>Fine IFFT input data control
1'b0: Input data in inverse order 
1'b1: Input data in inverse order and swap bit0~bit255 with bit256~bit511</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_INPUT_ADDR" protect="rw">
      <bits name="rFINE_IFFT_INPUT_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Fine IFFT input data start address</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_OUTPUT_ADDR" protect="rw">
      <bits name="rFINE_IFFT_OUTPUT_ADDR" pos="10:0" access="rw" rst="0">
        <comment>Fine IFFT output data start address</comment>
      </bits>
    </reg32>
    <reg32 name="rFINE_IFFT_STATUS" protect="r">
      <bits name="rFINE_IFFT_DONE_STATUS" pos="0" access="w1c" rst="0">
        <comment>Fine IFFT calculation done status.
1'b1: Fine IFFT calculation done
1'b0: Fine IFFT is idle or under calculating</comment>
      </bits>
      <bits name="rFINE_IFFT_OW_STATUS" pos="1" access="w1c" rst="0">
        <comment>Fine IFFT output buffer status
1'b1: Fine IFFT output buffer is over written
1'b0: Fine IFFT output buffer is normal</comment>
      </bits>
      <bits name="rFINE_IFFT_ERR_STATUS" pos="3:2" access="r" rst="0">
        <comment>Fine IFFT calculation done status.
1'b1: Fine IFFT calculation done
1'b0: Fine IFFT is idle or under calculating</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_multi_ca_fft.xml">
  <module name="NBIOT_MULTI_CA_FFT" category="NBIOT_PHY">
    <reg32 name="rFFT_CMD_START_ADDR" protect="rw">
      <bits name="rFFT_CMD_START_ADDR" pos="31:0" access="rw" rst="0x0">
        <comment>The start address of memory where FFT command stored.
Figure 5.4 2 shows the FFT command format.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_START" protect="wo">
      <bits name="rCA_FFT_START" pos="0:0" access="wo" rst="0x0">
        <comment>Pulse that high asserted which start CA FFT calculation. Once start, HW will perform FFT calculation </comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_STOP" protect="wo">
      <bits name="rCA_FFT_STOP" pos="0:0" access="wo" rst="0x0">
        <comment>High active pulse, when asserted, HW accelerator continue to finish FFT calculation based on current FFT command, then stop.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_CTRL" protect="rw">
      <bits name="rCA_FFT_CMD_FMT" pos="0:0" access="rw" rst="0">
        <comment>0: FFT command format0, whose length is 9 DWs.
1: FFT command format1, whose length is 10 DWs which include the information of DC offset cancellation and calculation.</comment>
      </bits>
    </reg32>
    <reg32 name="rDMA_TIMER" protect="rw">
      <bits name="rDMA_TIMER" pos="31:0" access="rw" rst="0">
        <comment>DMA timer, maximum DMA time limited.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_TIMER" protect="rw">
      <bits name="rCA_FFT_TIMER" pos="31:0" access="rw" rst="0">
        <comment>CA FFT timer, limited the time from DSP program CA FFT start to HW finish all of FFT calculation in FFT commands</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_MEM_SPACE_START" protect="rw">
      <bits name="rCA_FFT_MEM_SPACE_START" pos="31:0" access="rw" rst="0">
        <comment>The start address in share memory used for CA_FFT, co-use with i_ ca_fft_mem_space_end, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_FFT_MEM_SPACE_END" protect="rw">
      <bits name="rCA_FFT_MEM_SPACE_END" pos="31:0" access="rw" rst="0">
        <comment>The end address in share memory used for CA_FFT, co-use with i_ ca_fft_mem_space_start, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_DMA_STATUS" protect="ro">
      <bits name="rFFT_DMA_STATUS" pos="9:0" access="ro" rst="0">
        <comment>[9:8]: DMA done status
0: DMA success done;
1: DMA done by DMA stop;
2: DMA done by DMA timeout;
3: Reserved. 
[7]: dma write FIFO ready status, for debug
[6]: dma read FIFO1 ready ststus, for debug
[5]: dma read FIFO0 ready status, for debug
[4:0]: dma controller state machine, for debug</comment>
      </bits>
      <bits name="rCA_FFT_DMA_BUSY" pos="10:10" access="ro" rst="0">
        <comment>1: DMA busy;
0: DMA IDLE.</comment>
      </bits>
      <bits name="rCA_FFT_DMA_TIMEOUT" pos="11:11" access="ro" rst="0">
        <comment>1: DMA timer out
0: DMA finish in a setting time normally.</comment>
      </bits>
      <bits name="rCA_FFT_FIFO_STATUS" pos="15:12" access="ro" rst="0">
        <comment>FFT FIFO status
Bit0: FIFO empty
Bit1: FIFO half empty
Bit2: FIFO full
Bit3: FIFO half full</comment>
      </bits>
    </reg32>
    <reg32 name="rFFT_STATUS" protect="rw">
      <bits name="rCA_FFT_STATUS" pos="0:0" access="ro" rst="0">
        <comment>0: CA FFT idle;
1: CA FFT busy.</comment>
      </bits>
      <bits name="rCA_FFT_DONE" pos="1:1" access="w1c" rst="0">
        <comment>1: CA FFT done
0: CA FFT ongoing or idle.</comment>
      </bits>
      <bits name="rCA_FFT_TIMEOUT" pos="2:2" access="ro" rst="0">
        <comment>When SW start CA FFT, CA FFT timer begin to count, and stop when CA FFT done, during this time, if timer count reach to rDMA_TIMER, it reports time out.
0: no time out.
1: CA FFT calculation does not finish in a setting time, and time out.</comment>
      </bits>
      <bits name="rCA_FFT_CMD_ERR" pos="4:3" access="w1c" rst="0">
        <comment>FFT command error, asserted when FFT command format error, write 1 clear
0: FFT command valid;
1: FFT command invalid;
2: DMA address out of range which set by [rCA_FFT_MEM_SPACE_START, rCA_FFT_MEM_SPACE_END].
3: Reserved.</comment>
      </bits>
      <bits name="rONGOING_FFT_CMD_IDX" pos="20:5" access="ro" rst="0">
        <comment>Indicated which the ongoing FFT is triggered by which FFT Command.</comment>
      </bits>
      <bits name="rONGOING_FFT_CMD_LOOP_CNT" pos="24:21" access="ro" rst="0">
        <comment>Indicated which loop counter is a FFT command is served.</comment>
      </bits>
    </reg32>
  </module>
</archive>

<archive relative = "nb_multi_ca_ifft.xml">
  <module name="NBIOT_MULTI_CA_IFFT" category="NBIOT_PHY">
    <reg32 name="rCA_IFFT_CMD_START_ADDR" protect="rw">
      <bits name="rFFT_CMD_START_ADDR" pos="31:0" access="rw" rst="0x0">
        <comment>The start address of memory where FFT command stored.
Figure 5.4 2 shows the FFT command format.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_CMD_MEM_DEPTH" protect="rw">
      <bits name="rCA_IFFT_CMD_MEM_DEPTH" pos="15:0" access="rw" rst="0x0">
        <comment>A circular buffer is provided for DSP to program IFFT command data, the register defines the depth of this memory. The depth of command in memory is programmed in unit of byte, each IFFT command occupy 4 DWs, which is 16 bytes, so the programmed number always is times of 16. </comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_CTRL" protect="rw">
      <bits name="rCA_IFFT_HW_MODE" pos="0:0" access="rw" rst="0x0">
        <comment>0: Software mode. Hardware accelerator performs FFT calculation according to FFT command. DSP need to make sure the data is transmitted before start next IFFT calculation.
1: Hardware mode. Hardware accelerator automatically performs FFT calculation by monitoring the data dump number form TX_DUMP module. </comment>
      </bits>
      <bits name="rDSP_CFG_ZC_TW_RAM" pos="1:1" access="rw" rst="0x0">
        <comment>0: DSP can not write ZC twiddle RAM;
1: DSP can write ZC twiddle RAM.</comment>
      </bits>
      <bits name="rZC_SEQ_LEN" pos="8:2" access="rw" rst="0x0">
        <comment>Zadoff-CHU sequence length, prime number, default value 43.</comment>
      </bits>
      <bits name="rRACH_SC_OS" pos="16:9" access="rw" rst="0x0">
        <comment>RACH sub-carrier offset, default value is equal to 42. 
Conifigured value = rZC_SEQ_LEN -1;</comment>
      </bits>
      <bits name="rRACH_IFFT_PI_ROTATE_MODE" pos="17" access="rw" rst="0x0">
        <comment>0: PRACH symbol generation without pi rotate at odd symbol;
1: PRACH symbol generateion with pi rotate at odd symbol.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_START" protect="wo">
      <bits name="rCA_IFFT_START" pos="0:0" access="wo" rst="0x0">
        <comment>Pulse that high asserted which start CA IFFT calculation. Once start, HW will perform DFT/IFFT calculation </comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_STOP" protect="wo">
      <bits name="rCA_IFFT_STOP" pos="0:0" access="wo" rst="0x0">
        <comment>High active pulse, when asserted, HW accelerator continue to finish IFFT calculation based on current FFT command, then stop.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_DMA_TIMER" protect="rw">
      <bits name="rCA_IFFT_DMA_TIMER" pos="31:0" access="rw" rst="0">
        <comment>DMA timer, maximum DMA time limited.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_TIMER" protect="rw">
      <bits name="rCA_IFFT_TIMER" pos="31:0" access="rw" rst="0">
        <comment>CA IFFT timer, limited the time from DSP program CA IFFT start to HW finish all of IFFT calculation in IFFT commands</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_MEM_SPACE_START" protect="rw">
      <bits name="rCA_IFFT_MEM_SPACE_START" pos="31:0" access="rw" rst="0">
        <comment>The start address in share memory used for CA_IFFT, co-use with rCA_FFT_MEM_SPACE_END, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_MEM_SPACE_END" protect="rw">
      <bits name="rCA_IFFT_MEM_SPACE_START" pos="31:0" access="rw" rst="0">
        <comment>The end address in share memory used for CA_IFFT, co-use with rCA_IFFT_MEM_SPACE_START, all of AHB access cycle whose address is out of the range will be rejected.</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_DMA_STATUS" protect="ro">
      <bits name="rCA_IFFT_DMA_STATUS" pos="9:0" access="ro" rst="0">
        <comment>[9:8]: DMA done status
0: DMA success done;
1: DMA done by DMA stop;
2: DMA done by DMA timeout;
3: Reserved. 
[7]: dma write FIFO ready status, for debug
[6]: dma read FIFO1 ready ststus, for debug
[5]: dma read FIFO0 ready status, for debug
[4:0]: dma controller state machine, for debug</comment>
      </bits>
      <bits name="rCA_IFFT_DMA_BUSY" pos="10:10" access="ro" rst="0">
        <comment>1: DMA busy;
0: DMA IDLE.</comment>
      </bits>
      <bits name="rCA_IFFT_DMA_TIMEOUT" pos="11:11" access="ro" rst="0">
        <comment>1: DMA timer out
0: DMA finish in a setting time normally.</comment>
      </bits>
      <bits name="rCA_IFFT_FIFO_STATUS" pos="15:12" access="ro" rst="0">
        <comment>FFT FIFO status
Bit0: FIFO empty
Bit1: FIFO half empty
Bit2: FIFO full
Bit3: FIFO half full</comment>
      </bits>
    </reg32>
    <reg32 name="rCA_IFFT_STATUS" protect="rw">
      <bits name="rCA_IFFT_STATUS" pos="0:0" access="ro" rst="0">
        <comment>0: CA IFFT idle;
1: CA IFFT busy.</comment>
      </bits>
      <bits name="rCA_IFFT_DONE" pos="1:1" access="w1c" rst="0">
        <comment>1: CA FFT done
0: CA FFT ongoing or idle.</comment>
      </bits>
      <bits name="rCA_IFFT_TIMEOUT" pos="2:2" access="ro" rst="0">
        <comment>When SW start CA IFFT, CA IFFT timer begin to count, and stop when CA IFFT done, during this time, if timer count reach to rDMA_TIMER, it reports time out.
0: no time out.
1: CA IFFT calculation does not finish in a setting time, and time out.</comment>
      </bits>
      <bits name="rCA_IFFT_CMD_ERR" pos="4:3" access="w1c" rst="0">
        <comment>Asserted which IFFT command format error.
0: no error
1: current IFFT command invalid
2: next IFFT command invalid
3: DMA address out of range.</comment>
      </bits>
      <bits name="rONGOING_IFFT_CMD_IDX" pos="20:5" access="ro" rst="0">
        <comment>Indicated which the ongoing IFFT is triggered by which IFFT Command.</comment>
      </bits>
      <bits name="rONGOING_IFFT_CMD_LOOP_CNT" pos="24:21" access="ro" rst="0">
        <comment>Indicated which loop counter is a IFFT command is served.</comment>
      </bits>
      <bits name="rCA_DUMP_UD" pos="25:25" access="w1c" rst="0">
        <comment>CA DUMP underflow, asserted when CA DUMP symbol cnt is more than IFFT finished symbol cnt, which means no data for tx dump to transmit.
When asserted, it need DSP write 1 to clear.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA0" protect="rw">
      <bits name="rTX_GAIN_CA0" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA0.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA1" protect="rw">
      <bits name="rTX_GAIN_CA1" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA1.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA2" protect="rw">
      <bits name="rTX_GAIN_CA2" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA2.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA3" protect="rw">
      <bits name="rTX_GAIN_CA3" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA3.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA4" protect="rw">
      <bits name="rTX_GAIN_CA4" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA4.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA5" protect="rw">
      <bits name="rTX_GAIN_CA5" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA6.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA6" protect="rw">
      <bits name="rTX_GAIN_CA6" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA6.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA7" protect="rw">
      <bits name="rTX_GAIN_CA7" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA7.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA8" protect="rw">
      <bits name="rTX_GAIN_CA8" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA8.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA9" protect="rw">
      <bits name="rTX_GAIN_CA9" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA9.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA10" protect="rw">
      <bits name="rTX_GAIN_CA10" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA10.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA11" protect="rw">
      <bits name="rTX_GAIN_CA11" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA11.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA12" protect="rw">
      <bits name="rTX_GAIN_CA12" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA12.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA13" protect="rw">
      <bits name="rTX_GAIN_CA13" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA13.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA14" protect="rw">
      <bits name="rTX_GAIN_CA14" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA14.</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN_CA15" protect="rw">
      <bits name="rTX_GAIN_CA15" pos="31:0" access="rw" rst="0">
        <comment>TX Gain for CA15.</comment>
      </bits>
    </reg32>
  </module>
</archive>


<archive relative = "nb_tx_chsc.xml">

<module name="nb_tx_chsc" category="NBIOT_PHY">
 
  <reg32 name="rTX_CHSC_CTRL" protect="rw">
    <bits access="rw" name="rTIMEOUT_VAL" pos="15:0" rst="0x0">
      <comment>Maximum time out value for  TX channel-interleaver and scrambling in 61.44Mhz unit. </comment>
    </bits>
    <bits access="rw" name="rTX_CHSC_START_CTRL" pos="16" rst="0x0">
      <comment>Start control:
                     0: Trigger by SW start
                     1: Trigger by HW start.
      </comment>
    </bits>
    <bits access="rw" name="rCH_INTRLVR_EN" pos="17" rst="0x0">
      <comment>Channel interleaver enable
                     0: Disable
                     1: Enable.
      </comment>
    </bits>
    <bits access="rw" name="rSCR_EN" pos="18" rst="0x0">
      <comment>Scramble enable
                    0: Disable
                    1: Enable.
      </comment>
    </bits>
  </reg32>

  <reg32 name="rTX_CHSC_START" protect="w1c">
    <bits access="w1c" name="rTX_CHSC_START" pos="0" rst="0x0">
        <comment>TX channel-interleaver and scrambling accelerator 2 start. </comment>
    </bits>
  </reg32>
  
  <reg32 name="rMEM_START_ADDR" protect="rw">
    <bits access="rw" name="rBSEL_MEM_START_ADDR" pos="10:0" rst="0x0">
        <comment>Bit selection memory start address. </comment>
    </bits>
    <bits access="rw" name="rSCR_MEM_START_ADDR" pos="26:16" rst="0x0">
        <comment>Scramble memory start output address. </comment>
    </bits>
  </reg32>
  
  <reg32 name="rBSEL_CFG" protect="rw">
    <bits access="rw" name="NCB Minus" pos="14:0" rst="0x0">
        <comment>Ncb minus NCB - 3ND. </comment>
    </bits>
    <bits access="rw" name="rK0_MINUS" pos="30:16" rst="0x0">
        <comment>K0 minus: K0 position without dummy bit.. </comment>
    </bits>
  </reg32>
  
 <reg32 name="rCH_INTRLVR_CFG" protect="rw">
    <bits access="rw" name="rROW_SZ" pos="7:0" rst="0x0">
        <comment>Row size for ch-interleaver. </comment>
    </bits>
    <bits access="rw" name="rMOD_TYPE" pos="9:8" rst="0x0">
        <comment>Modulation type
                        0: BPSK
                        1: QPSK
                        2: 16QAM
                        3: 64QAM 
        </comment>
    </bits>
    <bits access="rw" name="rCOL_SZ_PRE_RSE_UNIT" pos="22:16" rst="0x0">
        <comment>Column size in each resource unit:
                 (NUL_sym-1)* Nul_slot. 
        </comment>
    </bits>
  </reg32>
  
  <reg32 name="rSCR_SIZE" protect="rw">
    <bits access="rw" name="rSCR_SIZE" pos="13:0" rst="0x0">
        <comment>scrambling size in current subframe. </comment>
    </bits>
  </reg32>  
  
  <reg32 name="rSCR_X1" protect="rw">
    <bits access="rw" name="rSCR_X1" pos="30:0" rst="0x0">
        <comment>scrambling X1. </comment>
    </bits>
  </reg32>  

  <reg32 name="rSCR_X2" protect="rw">
    <bits access="rw" name="rSCR_X2" pos="30:0" rst="0x0">
        <comment>scrambling X2. </comment>
    </bits>
  </reg32> 

 <reg32 name="rLAST_SCR_X1" protect="rw">
    <bits access="rw" name="rLAST_SCR_X1" pos="30:0" rst="0x0">
        <comment>Last scrambling state in X1. </comment>
    </bits>
  </reg32> 

 <reg32 name="rLAST_SCR_X2" protect="rw">
    <bits access="rw" name="rLAST_SCR_X2" pos="30:0" rst="0x0">
        <comment>Last scrambling state in X2. </comment>
    </bits>
  </reg32>

 <reg32 name="rTX_CHSC_STATUS" protect="ro">
    <bits access="w1c" name="Done" pos="0" rst="0x0">
        <comment>(This bit is read write 1 clear)
                   0: No Done
                   1: Done.
        </comment>
    </bits>
    <bits access="ro" name="Overwritten" pos="1" rst="0x0">
        <comment>If Done bit would not clear before this engine re-engine would indicate overwritten output buffer
                              0: Normal
                              1: Error
        </comment>
    </bits>
    <bits access="ro" name="BUS Error" pos="3:2" rst="0x0">
        <comment>0: Normal
                 1: Error
                 Bit 0: DSP control bus error
                 Bit 1: accelerator memory access collusion
        </comment>
    </bits>
    <bits access="ro" name="Timeout" pos="4" rst="0x0">
        <comment>0: Normal
                 1: Error
        </comment>
    </bits>
  </reg32>  
  

</module>

</archive>


<archive relative = "nb_tx_frontend.xml">
  <module name="nb_tx_frontend" category="NBIOT_PHY">
    <reg32 name="rTX_OS" protect="rw">
      <bits name="rPUSCH_OS1" pos="7:0" access="rw" rst="0xb">
        <comment>PUSCH offset1 for 3.75K process delay</comment>
      </bits>
      <bits name="rPUSCH_OS0" pos="15:8" access="rw" rst="0x63">
        <comment>PUSCH offset0 for 15K process delay</comment>
      </bits>
      <bits name="rPRACH_OS" pos="23:16" access="rw" rst="0xb">
        <comment>PRACH offset for process delay</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_TA_VALUE" protect="rw">
      <bits name="rTX_TA_VALUE" pos="10:0" access="rw" rst="0x0">
        <comment>TA Value</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_RACH_START_ADJ" protect="rw">
      <bits name="rTX_RACH_START_ADJ" pos="10:0" access="rw" rst="0x0">
        <comment>the advance time of PRACH start adjustment</comment>
      </bits>
    </reg32>
   <reg32 name="rTX_RF_DELAY" protect="rw">
      <bits name="rTX_RF_DELAY" pos="15:0" access="rw" rst="0x0">
        <comment>RF delay from NBIOT_CORE to chip output</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_EN" protect="rw">
      <bits name="rPUSCH_EN" pos="0" access="rw" rst="0">
        <comment>PUSCH Enable</comment>
      </bits>
      <bits name="rPRACH_EN" pos="1" access="rw" rst="0">
        <comment>PRACH Enable</comment>
      </bits>
    </reg32>
    <reg32 name="rDELTA_CP_ADJ" protect="rw">
      <bits name="rDELTA_CP_ADJ" pos="5:0" access="rw" rst="0">
        <comment>Delta CP adjustment</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_CFG" protect="rw">
      <bits name="rTX_FRM_MODE" pos="0" access="rw" rst="0">
        <comment>TX frame mode for PUSCH</comment>
      </bits>
      <bits name="rMOD_TYPE" pos="1" access="rw" rst="0">
        <comment>Module type</comment>
      </bits>
      <bits name="rTX_BUF_IDX" pos="2" access="rw" rst="0">
        <comment>TX Buffer idx</comment>
      </bits>
      <bits name="rPRACH_CP_MODE" pos="3" access="rw" rst="0">
        <comment>CP length of PRACH0/1</comment>
      </bits>
      <bits name="rTONE_MODE" pos="4" access="rw" rst="0">
        <comment>PUSCH Tone mode</comment>
      </bits>
      <bits name="rSHORTEN_PUSCH_EN" pos="5" access="rw" rst="0">
        <comment>Shorten PUSCH Enable</comment>
      </bits>
      <bits name="rPUSCH_SC_IDX" pos="11:6" access="rw" rst="0">
        <comment>PUSCH Subcarrier POsition</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_GAIN" protect="rw">
      <bits name="rTX_GAIN" pos="11:0" access="rw" rst="0">
        <comment>TX Gain</comment>
      </bits>
    </reg32>
    <reg32 name="rPUSCH_CFG" protect="rw">
      <bits name="rTHETAL_SYMB_INCR" pos="7:0" access="rw" rst="0">
        <comment>thetal symbol incremental step value</comment>
      </bits>
      <bits name="rSYMB_NUM_MOD2" pos="8" access="rw" rst="0">
        <comment>symbol number modulo 2</comment>
      </bits>
    </reg32>
    <reg32 name="rMEM_BUS_ERR" protect="rw">
      <bits name="rMEM_BUS_ERR" pos="1:0" access="r" rst="0">
        <comment>memory bus access error</comment>
      </bits>
      <bits name="rTX_STATUS" pos="3:2" access="r" rst="0">
        <comment>TX Status, 2'b00: IDLE; 2'b01: PRACH; 2'b10: PUSCH 3.75K; 2'b11: PUSCH 15K</comment>
      </bits>
      <bits name="rTX_START_SF_IDX" pos="7:4" access="r" rst="0">
        <comment>Subframe index of NPRACH or NPUSCH transmitted</comment>
      </bits>
    </reg32>
    <hole size="2*32" />
    <reg32 name="rPRACH_CMD_FIFO0" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="5:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_CMD_FIFO1" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="5:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_CMD_FIFO2" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="5:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_CMD_FIFO3" protect="rw">
      <bits name="rPRACH_SC_IDX" pos="5:0" access="rw" rst="0">
        <comment>PRACH sub-carrier index 0~47</comment>
      </bits>
      <bits name="RSV" pos="29:6" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rPRACH_CFG_STATUS" pos="30" access="rw" rst="0">
        <comment>PRACH CFG Status</comment>
      </bits>
      <bits name="rPRACH_NXT_EN" pos="31" access="rw" rst="0">
        <comment>Next PRACH symbol group enabled</comment>
      </bits>
    </reg32>
    <reg32 name="rPRACH_NXT_CMD_RD_PTR" protect="r">
      <bits name="rPRACH_NXT_CMD_RD_PTR" pos="1:0" access="r" rst="0">
        <comment>PRACH Nxt Command Read Pointer</comment>
      </bits>
      <bits name="RSV" pos="31:2" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <hole size="4*32" />
    <reg32 name="rTX_DOUT_CHECKSUM" protect="r">
      <bits name="rTX_DOUT_CHECKSUM" pos="30:0" access="r" rst="0">
        <comment>TX dout checksum</comment>
      </bits>
      <bits name="rTX_DOUT_CHECKSUM_EN" pos="31" access="rw" rst="0">
        <comment>TX dout Checksum Enable</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_FLT_TAIL_BIT_NUM" protect="rw">
      <bits name="rTX_FLT_TAIL_BIT_NUM" pos="7:0" access="rw" rst="0x80">
        <comment>Configurable Number of zero data padded at the end of TX transmission</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_DUMP_OS" protect="rw">
      <bits name="rTX_DUMP_OS" pos="7:0" access="rw" rst="0x08">
        <comment>TX DUMP offset for processing delay</comment>
      </bits>
      <bits name="RSV" pos="31:8" access="ro" rst="0x00">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_DUMP_CTRL" protect="rw">
      <bits name="rTX_DUMP_MODE_EN" pos="0:0" access="rw" rst="0x00">
        <comment>TX dump mode, the data from IFFT memeory will be transmitted directly</comment>
      </bits>
      <bits name="rTX_DUMP_MEM_IDX" pos="1:1" access="rw" rst="0x00">
        <comment>Indicated which memory will be accessed when frame start</comment>
      </bits>
      <bits name="RSV" pos="31:2" access="ro" rst="0x00">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_DUMP_MEM0_CMD_FIFO" protect="rw">
      <bits name="rTX_DUMP_MEM0_DATA_RDY" pos="0:0" access="rw" rst="0x00">
        <comment>Indicated whether the data in memory0 is ready or not, setted by DSP and cleared by HW</comment>
      </bits>
      <bits name="rTX_DUMP_MEM0_DATA_LEN" pos="11:1" access="rw" rst="0x00">
        <comment>Indicated the valid data number in memory0 and all of valid data should be transmitted</comment>
      </bits>
      <bits name="RSV" pos="31:12" access="ro" rst="0x00">
        <comment>Reserved</comment>
      </bits>
    </reg32>
        <reg32 name="rTX_DUMP_MEM1_CMD_FIFO" protect="rw">
      <bits name="rTX_DUMP_MEM1_DATA_RDY" pos="0:0" access="rw" rst="0x00">
        <comment>Indicated whether the data in memory1 is ready or not, setted by DSP and cleared by HW</comment>
      </bits>
      <bits name="rTX_DUMP_MEM1_DATA_LEN" pos="11:1" access="rw" rst="0x00">
        <comment>Indicated the valid data number in memory1 and all of valid data should be transmitted</comment>
      </bits>
      <bits name="RSV" pos="31:12" access="ro" rst="0x00">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rTX_DUMP_STATUS" protect="rw">
      <bits name="rTX_DUMP_MEM0_ERR" pos="1:0" access="rw" rst="0x00">
        <comment>Memory0 bus error when TX dump request to read data from memory buffer</comment>
      </bits>
      <bits name="rTX_DUMP_MEM1_ERR" pos="3:2" access="rw" rst="0x00">
        <comment>Memory1 bus error when TX dump request to read data from memory buffer</comment>
      </bits>
      <bits name="rTX_DUMP_SUBFRAME" pos="7:4" access="rw" rst="0x00">
        <comment>Subframe index of TX dump transmission, for debug</comment>
      </bits>
      <bits name="RSV" pos="31:8" access="ro" rst="0x00">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF1_COEF0" protect="rw">
      <bits name="rLPF1_COEF00" pos="9:0" access="rw" rst="0">
        <comment>LPF1 coefficient0</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF01" pos="25:16" access="rw" rst="0">
        <comment>LPF1 coefficient1</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF1_COEF1" protect="rw">
      <bits name="rLPF1_COEF10" pos="9:0" access="rw" rst="0">
        <comment>LPF1 coefficient2</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF11" pos="25:16" access="rw" rst="0">
        <comment>LPF1 coefficient3</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF1_COEF2" protect="rw">
      <bits name="rLPF1_COEF10" pos="9:0" access="rw" rst="0">
        <comment>LPF1 coefficient4</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF11" pos="25:16" access="rw" rst="0">
        <comment>LPF1 coefficient5</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF1_COEF3" protect="rw">
      <bits name="rLPF1_COEF10" pos="9:0" access="rw" rst="0">
        <comment>LPF1 coefficient6</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF1_COEF11" pos="25:16" access="rw" rst="0">
        <comment>LPF1 coefficient7</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF2_COEF0" protect="rw">
      <bits name="rLPF2_COEF00" pos="9:0" access="rw" rst="0">
        <comment>LPF2 coefficient0</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF2_COEF01" pos="25:16" access="rw" rst="0">
        <comment>LPF2 coefficient1</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF2_COEF1" protect="rw">
      <bits name="rLPF2_COEF00" pos="9:0" access="rw" rst="0">
        <comment>LPF2 coefficient2</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF2_COEF01" pos="25:16" access="rw" rst="0">
        <comment>LPF2 coefficient3</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
    <reg32 name="rLPF2_COEF2" protect="rw">
      <bits name="rLPF2_COEF00" pos="9:0" access="rw" rst="0">
        <comment>LPF2 coefficient4</comment>
      </bits>
      <bits name="RESERVED" pos="15:10" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
      <bits name="rLPF2_COEF01" pos="25:16" access="rw" rst="0">
        <comment>LPF2 coefficient5</comment>
      </bits>
      <bits name="RESERVED" pos="31:26" access="r" rst="0">
        <comment>Reserved</comment>
      </bits>
    </reg32>
  </module>
</archive>


<archive relative = "nb_tx_pusch_encoder.xml">
<module name="nb_tx_pusch_encoder" category="NBIOT_PHY">

  <reg32 name="PUSCH_ENC_CTRL" protect="rw">
    <bits access="rw" name="rTIMEOUT_VAL" pos="15:0" rst="0x0">
      <comment>Maximum time out value for pusch encoder in 61.44Mhz unit. </comment>
  </bits>    
  <bits access="rw" name="Swap" pos="18:16" rst="0x0">
      <comment>Endian SWAP control for bit, byte and word. </comment>
  </bits>             
  </reg32>

  <reg32 name="PUSCH_ENC_START" protect="wo">
    <bits access="wo" name="PUSCH_ENC_START" pos="0" rst="0x0">
      <comment> Write this register will trigger pusch encoder start </comment>
  </bits>              
  </reg32> 

  <reg32 name="TBS" protect="rw">
    <bits access="rw" name="TBS" pos="12:0" rst="0x0">
      <comment>TB Size for PUSCH. </comment>
  </bits>              
  </reg32>                 

  <reg32 name="Alpha_ini" protect="rw">
    <bits access="rw" name="Alpha_ini" pos="12:0" rst="0x0">
      <comment>Alpha init value for QPP interleaver. </comment>
  </bits>              
  </reg32> 

  <reg32 name="Alpha_step" protect="rw">
    <bits access="rw" name="Alpha_step" pos="12:0" rst="0x0">
      <comment>Alpha Step value for QPP interleaver. </comment>
  </bits>              
  </reg32> 

  <reg32 name="PUSCH_ENC_RD_ADDR" protect="rw">
    <bits access="rw" name="PUSCH_ENC_RD_ADDR" pos="10:0" rst="0x0">
      <comment>Rd address to DSP memory for pusch encoder. </comment>
  </bits>              
  </reg32>

  <reg32 name="PUSCH_ENC_WR_ADDR" protect="rw">
    <bits access="rw" name="PUSCH_ENC_WR_ADDR" pos="10:0" rst="0x0">
      <comment>WR address to DSP memory for pusch encoder. </comment>
  </bits>              
  </reg32>     

  <reg32 name="PUSCH_ENC_STATUS" protect="ro">
    <bits access="w1c" name="Done" pos="0" rst="0x0">
        <comment>(This bit is read write 1 clear)
                   0: No Done
                   1: Done.
        </comment>
    </bits>
    <bits access="ro" name="Overwritten" pos="1" rst="0x0">
        <comment>Indicate overwritten happen for pusch encoder
                  0: Normal
                  1: Error
        </comment>
    </bits>
    <bits access="ro" name="BUS Error" pos="3:2" rst="0x0">
        <comment>Bit 0: DSP control bus error, 0-Normal, 1-Error
                 Bit 1: accelerator memory access collusion, 0-Normal, 1-Error
        </comment>
    </bits>
    <bits access="ro" name="Timeout" pos="4" rst="0x0">
        <comment>0: Normal
                 1: Error
        </comment>
    </bits>                                                    
  </reg32>     

</module>

</archive>


<archive relative = "nb_viterbi.xml">
  <module name="nb_viterbi" category="NBIOT_PHY">
    <reg32 name="rVD_DEC_START" protect="w">
      <bits name="rVD_DEC_START" pos="0" access="w" rst="0">
        <comment>Start trigger of one sequential decoding of viterbi decoder which is generated by writing '1' to this register</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CTRL" protect="rw">
      <bits name="rVD_PL_SIZE" pos="28:16" access="rw" rst="0">
        <comment>Payload size of CBs to be decoded in one sequential decoding</comment>
      </bits>
      <bits name="rVD_DEC_NUM" pos="15:13" access="rw" rst="0">
        <comment>Indicate the number(1~4) of coded blocks to be decoded in one sequential decoding process</comment>
      </bits>
      <bits name="rVD_DEINT_EN" pos="12" access="rw" rst="1">
        <comment>Function of de-interleaving in hardware enable/disable
        1: Enable
        0: Disable
        </comment>
      </bits>
      <bits name="rVD_CRCMASK_EN" pos="11" access="rw" rst="0">
        <comment>CRC mask checking enable/disable(for RNTI and antenna port number)
        1: Enable
        0: Disable
        </comment>
      </bits>
      <bits name="rVD_CRC_TYPE" pos="10" access="rw" rst="0">
        <comment>Indicate the CRC type of  sequential decoding
        1:24
        0:16
        </comment>
      </bits>
      <bits name="Reserved" pos="9:2" access="rw" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SCALE_DIS" pos="1" access="rw" rst="0">
        <comment>Enable/disable scaling of input soft data with viterbi decoder
        0: Enable(Maximum supported TBS is 3060 and input data is W in DW aligned)
        1: Disable(Maximum supported TBS is 6120 and input data is BYTE in DW aligned)
        </comment>
      </bits>
      <bits name="rVD_LVA_EN" pos="0" access="rw" rst="0">
        <comment>List viterbi mode enable/disable.(The maximum TBsize supported by list viterbi is 680)
        1: Enable
        0: Disable
        </comment>
      </bits>
    </reg32>
    <reg32 name="rVD_ADDR_CTRL" protect="rw">
      <bits name="rVD_VOR_ADDR_O" pos="30:22" access="rw" rst="0">
        <comment>This register indicates the start address of viterbi output odd buffer for payload.</comment>
      </bits>
      <bits name="rVD_VOR_ADDR_E" pos="21:13" access="rw" rst="0">
        <comment>This register indicates the start address of viterbi output even buffer for payload.</comment>
      </bits>
      <bits name="rVD_VIR_ADDR" pos="12:0" access="rw" rst="0">
        <comment>This register indicates the start address of data in viterbi input ram.</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CRC_MASK01" protect="rw">
      <bits name="rVD_CRC_MASK1" pos="31:16" access="rw" rst="0">
        <comment>Indicate CRC mask1(for RNTI and antenna port number)</comment>
      </bits>
      <bits name="rVD_CRC_MASK0" pos="15:0" access="rw" rst="0">
        <comment>Indicate CRC mask0(for RNTI and antenna port number)</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CRC_MASK23" protect="rw">
      <bits name="rVD_CRC_MASK3" pos="31:16" access="rw" rst="0">
        <comment>Indicate CRC mask1(for RNTI and antenna port number)</comment>
      </bits>
      <bits name="rVD_CRC_MASK2" pos="15:0" access="rw" rst="0">
        <comment>Indicate CRC mask0(for RNTI and antenna port number)</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_LONG_CFG" protect="rw">
      <bits name="rVD_PL_SWAP" pos="26:24" access="rw" rst="0">
        <comment>Reorder the 32bit data written to viterbi output buffer
    2: Reverse the word sequence in the Dword(1Dword)
    1: Reverse the byte sequence in every word(2words).
    0: Reverse the bit sequence in every byte(4bytes).</comment>
      </bits>
      <bits name="rVD_TIMECNT_LIMIT" pos="23:0" access="rw" rst="0xFFFFFF">
        <comment>In a sequential decoding process, if the corresponding time counter exceeds this set value of rVD_TIMECNT_LIMIT, bit4 of rVD_DEC_SATUS will be set to 1 and sent to high layer.
        Default value is 24'hFFFFFF.
        Besides, if this register is set to 0, the funcion of reporting time out is disabled.
        </comment>
      </bits>
    </reg32>
    <hole size="2*32" />
    <reg32 name="rVD_VOR_EO" protect="rw">
      <bits name="rVD_VOR_EO" pos="0" access="rw" rst="0">
        <comment>Indicate even/odd viterbi output buffer to be written by decoder:
1: odd output buffer
0: even output buffer</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_DEC_CTRL" protect="rw">
      <bits name="rVD_SCALING_BW_Y" pos="31:28" access="rw" rst="0">
        <comment>Bit width of output scaling data's fractional part(S8.y)</comment>
      </bits>
      <bits name="rVD_SCALING_BW_X" pos="27:24" access="rw" rst="0">
        <comment>Bit width of input scaling data's fractional part(S16.x)</comment>
      </bits>
      <bits name="rVD_SCALING_FACTOR" pos="23:16" access="rw" rst="0">
        <comment>This register(U8.7) is multiplied by scaling input data(S16.x)</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP3" pos="15:12" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB3 to be decoded</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP2" pos="11:8" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB2 to be decoded</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP1" pos="7:4" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB1 to be decoded</comment>
      </bits>
      <bits name="rVD_CRCMASK_BITMAP0" pos="3:0" access="rw" rst="0">
        <comment>Bitmap of CRC masks(0~3) used in blind decoding for the CB0 to be decoded</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CANDI_CFG" protect="rw">
      <bits name="Reserved" pos="18:16" access="rw" rst="0">
        <comment>
        </comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB3" pos="15:12" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB3(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB3
</comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB2" pos="11:8" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB2(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB2
</comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB1" pos="7:4" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB1(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB1
</comment>
      </bits>
      <bits name="rVD_CANDI_CFG_CB0" pos="3:0" access="rw" rst="0">
        <comment>15: Antenna number for candidate CB0(0: 1 antenna 1: 2 antennas)
14:12: 80ms SFN for candidate CB0
</comment>
      </bits>
    </reg32>
    <hole size="1*32" />
    <reg32 name="rVD_CRCREAD" protect="r">
      <bits name="rVD_CRCRESULT_O" pos="31:16" access="r" rst="0">
        <comment>CRC checking result of the corresponding code block for output buffer odd, and CRC results from CB0 to CB3 have to be written sequentially to bit[0]~bit[15] of this register. 
1: good    0: fail
If rVD_CRCMASK_EN =1, 4 bits mask checking result is reported for every candidate CB
    [31:28] for CB3(28:MASK0, 29:MASK1, 30:MASK2, 31:MASK3)
    [27:24] for CB2(24:MASK0, 25: MASK1, 26: MASK2, 27: MASK3)
    [23:20] for CB1(20: MASK0, 21: MASK1, 22: MASK2, 23: MASK3)
    [19:16] for CB0(16: MASK0, 17: MASK1, 18: MASK2, 19: MASK3)
And if rVD_CRCMASK_EN =0, 1 bit crc checking result is reported for every candidate CB
    [28] for CB3
    [24] for CB2
    [20] for CB1
    [16] for CB0</comment>
      </bits>
      <bits name="rVD_CRCRESULT_E" pos="15:0" access="r" rst="0">
        <comment>CRC check result of the corresponding code block for output buffer even, and CRC results from CB0 to CB3 have to be written sequentially to bit[0]~bit[15] of this register. 
1: good    0: fail
If rVD_CRCMASK_EN =1, 4 bits mask checking result is reported for every candidate CB
    [15:12] for CB3(12: MASK0, 13: MASK1, 14: MASK2, 15: MASK3)
    [11:8] for CB2(8: MASK0, 9: MASK1, 10: MASK2, 11: MASK3)
    [7:4] for CB1(4: MASK0, 5: MASK1, 6: MASK2, 7: MASK3)
    [3:0] for CB0(0: MASK0, 1: MASK1, 2: MASK2, 3: MASK3)
And if rVD_CRCMASK_EN =0, 1 bit crc checking result is reported for every candidate CB
    [12] for CB3
    [8] for CB2
    [4] for CB1
    [0] for CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD01_E" protect="r">
      <bits name="rVD_SER_1" pos="30:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_0" pos="14:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD01_O" protect="r">
      <bits name="rVD_SER_1" pos="30:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_0" pos="14:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD23_E" protect="r">
      <bits name="rVD_SER_3" pos="30:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_2" pos="14:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_SERREAD23_O" protect="r">
      <bits name="rVD_SER_3" pos="30:16" access="r" rst="0">
        <comment>Symbol error number of the candidate CB1</comment>
      </bits>
      <bits name="Reserved" pos="15" access="r" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_SER_2" pos="14:0" access="r" rst="0">
        <comment>Symbol error number of the candidate CB0</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CANDI_RPT_E" protect="r">
      <bits name="rVD_CANDI_RPT_E" pos="31:0" access="r" rst="0">
        <comment>Report some configurations to MCU for output buffer even
        [31:19] Report payload size
        [18:16] Reserved
        [15:0]  Report configuration of register 'rVD_CANDI_CFG'</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_CANDI_RPT_O" protect="r">
      <bits name="rVD_CANDI_RPT_O" pos="31:0" access="r" rst="0">
        <comment>Report some configurations to MCU for output buffer even
        [31:19] Report payload size
        [18:16] Reserved
        [15:0]  Report configuration of register 'rVD_CANDI_CFG'</comment>
      </bits>
    </reg32>
    <reg32 name="rVD_DEC_STATUS" protect="rw">
      <bits name="rVD_ZERO_IND" pos="31:16" access="ro" rst="0">
        <comment>Result of checking in case that the decoded data is all zero 
    1:  All zero
    0 : Not zero data.
    Bit[23:16] for output even buffer:
    [17:16] for CB0, bit16 indicates list Viterbi 1st path, bit17 indicates list Viterbi 2nd path(if 2nd path is needed )
    [19:18] for CB1, bit18 indicates list Viterbi 1st path, bit19 indicates list Viterbi 2nd path(if 2nd path is needed )
    [21:20] for CB2, bit20 indicates list Viterbi 1st path, bit21 indicates list Viterbi 2nd path(if 2nd path is needed )
    [23:22] for CB3, bit22 indicates list Viterbi 1st path, bit23 indicates list Viterbi 2nd path(if 2nd path is needed )
    Bit[31:24]for output odd buffer;
    [25:24] for CB0, bit24 indicates list Viterbi 1st path, bit25 indicates list Viterbi 2nd path(if 2nd path is needed )
    [27:26] for CB1, bit26 indicates list Viterbi 1st path, bit27 indicates list Viterbi 2nd path(if 2nd path is needed )
    [29:28] for CB2, bit28 indicates list Viterbi 1st path, bit29 indicates list Viterbi 2nd path(if 2nd path is needed )
    [31:30] for CB3, bit30 indicates list Viterbi 1st path, bit31 indicates list Viterbi 2nd path(if 2nd path is needed )
    For NPDSCH, only bit[17:16] and bit[25:24] are used for CB0.</comment>
      </bits>
      <bits name="Reserved" pos="15:9" access="ro" rst="0">
        <comment></comment>
      </bits>
      <bits name="rVD_VOR_REQ_FAIL" pos="8:7" access="ro" rst="0">
        <comment>Viterbi-in ram reading error</comment>
      </bits>
      <bits name="rVD_VIR_REQ_FAIL" pos="6:5" access="ro" rst="0">
        <comment>Viterbi output buffer writing error</comment>
      </bits>
      <bits name="rVD_TIMECNT_OUT" pos="4" access="w1c" rst="0">
        <comment>This bit indicate that the time counter is exceed the limit of set value</comment>
      </bits>
      <bits name="rVD_VOR_OVERWRITE" pos="3:2" access="w1c" rst="0">
        <comment>3: This bit is to indicate that the odd memory is overwritten or not before 'UPDATED' is cleared.
2: This bit is to indicate that the even memory is overwritten or not before 'UPDATED' is cleared.</comment>
      </bits>
      <bits name="rVD_VOR_UPDATED" pos="1:0" access="w1c" rst="0">
        <comment>1: This bit is to indicate that the odd memory is updated or not.
0: This bit is to indicate that the even memory is updated or not.</comment>
      </bits>
    </reg32>
  </module>
</archive>


<archive relative = "page_spy.xml">

<module name="page_spy" category="Debug">

  <var name="NB_BITS_ADDR_PAGE_SPY"     value="32"/>
  <var name="PAGE_SPY_NB_PAGE" value="30"/>

  <reg protect="rw" name="enable">
    <bits access="rs" name="enable_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="enable_page">
      <comment>Writing '1' enable the page (n), writing '0' leave the page in
      it's current state. Reading returns '1' if the page is active (hit or
      not).</comment>
    </bits>
  </reg>

  <reg protect="rw" name="disable">
    <bits access="rc" name="disable_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="disable_page">
      <comment>Writing '1' disable the page (n) and clears the hit status if
      any, writing '0' leave the page in it's current state. Reading returns
      '1' if the page is active (hit or not).</comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="status_page" pos="PAGE_SPY_NB_PAGE-1:0" rst="0" cut="1" cutprefix="status_page">
      <options>
        <option name="NOT_HIT" value="0" />
        <option name="HIT" value="1" />
        <default />
      </options>
      <comment>Status of the page.</comment>
    </bits>
  </reg>

  <hole size="32" />

  <struct count="PAGE_SPY_NB_PAGE" name="page">
    <reg protect="rw" name="start">
      <bits access="rw" name="start_address" pos="NB_BITS_ADDR_PAGE_SPY-1:0" rst="no">
        <comment>Start address of page (n) (included). </comment>
      </bits>
    </reg>

    <reg protect="rw" name="end">
      <bits access="rw" name="end_address" pos="NB_BITS_ADDR_PAGE_SPY-1:0" rst="no">
        <comment>End address of page (n) (excluded).</comment>
      </bits>
    </reg>

    <reg protect="r" name="master">
      <bits access="r" name="master" pos="3:0" rst="0">
        <options>
          <option name="cm4i_bcpu    " value="0b0001" />
          <option name="cm4d_nbiot   " value="0b0010" />
          <option name="cm4s_spi2ahb " value="0b0011" />
          <option name="sysdma_bbdma " value="0b0100" />
          <option name="aes_f8       " value="0b0101" />
          <option name="lzma_rfif    " value="0b0110" />
          <option name="sysifc_bbifc " value="0b0111" />
          <option name="bb2sys_sys2bb" value="0b1000" />
          <option name="cm4ic        " value="0b1001" />
          <option name="cm4dc        " value="0b1010" />
          <option name="bt_bdm       " value="0b1011" />
          <default />
        </options>
        <comment>The master that wrote in the page (n). </comment>
      </bits>

      <bits access="r" name="hit_read" pos="30" rst="no">
        <comment>If '1' a read has triggered the page.</comment>
      </bits>

      <bits access="r" name="hit_write" pos="31" rst="no">
        <comment>If '1' a write has triggered the page.</comment>
      </bits>
    </reg>

    <reg protect="r" name="addr">
      <bits access="r" name="hit_addr" pos="NB_BITS_ADDR_PAGE_SPY-1:0" rst="no">
        <comment>Address that triggered page (n). </comment>
      </bits>
    </reg>
  </struct>

  <reg protect="rw" name="detect_write_reg">
    <bits access="rw" name="detect_write" pos="PAGE_SPY_NB_PAGE-1:0" rst="no" cut="1" cutprefix="detect_write">
      <comment>If '1' any write within the range will trigger the
      page.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="detect_read_reg">
    <bits access="rw" name="detect_read" pos="PAGE_SPY_NB_PAGE-1:0" rst="no" cut="1" cutprefix="detect_read">
      <comment>If '1' any read within the range will trigger the
      page.</comment>
    </bits>
  </reg>

</module>

</archive>
<archive relative="pmuc.xml">
  <module name="pmuc" category="System">
    <reg protect="rw" name="ldo_buck1_vcore_cfg_1">
      <bits access="r" name="ldo_buck1_vcore_cfg_1_reserved_0" pos="31:18" rst="0">
      </bits>
      <bits access="rw" name="low_sense_bit_buck1" pos="17:16" rst="1">
        <comment>
          increase peak detect current to increase load current
        </comment>
      </bits>
      <bits access="r" name="ref_ready_buck1" pos="15" rst="0">
        <comment>
          complete soft_start
        </comment>
      </bits>
      <bits access="rw" name="pfm_mode_sel_buck1_reg" pos="14" rst="0">
      </bits>
      <bits access="rw" name="pfm_mode_sel_buck1_dr" pos="13" rst="0">
        <comment>
          pfm mode select_x000D_
1:pfm mode and pwm mode auto switch_x000D_
0:force pwm mode
        </comment>
      </bits>
      <bits access="rw" name="dis_lowbat_buck1" pos="12" rst="0">
        <comment>
          disable detection of lowvbat
        </comment>
      </bits>
      <bits access="rw" name="slopex2_buck1" pos="11" rst="0">
        <comment>
          200% of slope compensation 
        </comment>
      </bits>
      <bits access="rw" name="en_irdelay_buck1" pos="10" rst="0">
        <comment>
          delay 2ns of ir detection
        </comment>
      </bits>
      <bits access="rw" name="ir_cmp_lr_buck1" pos="9" rst="1">
        <comment>
          reduce or increase Vref of ircmp 
        </comment>
      </bits>
      <bits access="rw" name="ir_cmp_bit_buck1" pos="8:6" rst="0">
        <comment>
          adjustment of ircmp
        </comment>
      </bits>
      <bits access="rw" name="heavy_load_buck1" pos="5" rst="0">
        <comment>
          increase peak detect current to increase load current
        </comment>
      </bits>
      <bits access="rw" name="heavy_load2_buck1" pos="4" rst="0">
        <comment>
          increase peak detect current to increase load current
        </comment>
      </bits>
      <bits access="rw" name="dis_antiring_sleep_buck1" pos="3" rst="1">
        <comment>
          disable antiring sleep when antiring_disable_buck1=1
        </comment>
      </bits>
      <bits access="rw" name="antiring_disable_buck1" pos="2" rst="1">
        <comment>
          disable antiring active
        </comment>
      </bits>
      <bits access="rw" name="pfm_clk_disable_buck1" pos="1" rst="1">
        <comment>
          disable pfm_clk
        </comment>
      </bits>
      <bits access="rw" name="vout_sel_buck1" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_buck1_vcore_cfg_2">
      <bits access="r" name="ldo_buck1_vcore_cfg_2_reserved_0" pos="31:27" rst="0">
      </bits>
      <bits access="rw" name="pfm_mode_clk_buck1_sel" pos="26:25" rst="2">
        <comment>
          00: 32k div2 01: 32K div4 10:32k div8 11:32k div16
        </comment>
      </bits>
      <bits access="rw" name="pfm_mode_clk_buck1_en" pos="24" rst="1">
      </bits>
      <bits access="rw" name="vbuck1_bit_lp" pos="23:19" rst="16">
      </bits>
      <bits access="rw" name="vbuck1_bit_pm0" pos="18:14" rst="16">
      </bits>
      <bits access="rw" name="nonov_delay_buck1" pos="13:12" rst="0">
        <comment>
          dcdc nonovlap clk dead time adjust
        </comment>
      </bits>
      <bits access="rw" name="osc_freq_buck1" pos="11:9" rst="2">
        <comment>
          internal clock frequency control
        </comment>
      </bits>
      <bits access="rw" name="pfm_threshold_buck1" pos="8:7" rst="2">
        <comment>
          pfm mode current threshold
        </comment>
      </bits>
      <bits access="rw" name="gdrv_n_en_100ma_buck1" pos="6" rst="1">
        <comment>
          more nldmos for 100ma load
        </comment>
      </bits>
      <bits access="rw" name="gdrv_p_en_100ma_buck1" pos="5" rst="1">
        <comment>
          more pldmos for 100ma load
        </comment>
      </bits>
      <bits access="rw" name="soft_en_buck1" pos="4" rst="1">
        <comment>
          dcdc soft_start
        </comment>
      </bits>
      <bits access="rw" name="ldo_cc_disable_buck1" pos="3" rst="0">
        <comment>
          reduce bandwidth of ldo
        </comment>
      </bits>
      <bits access="rw" name="counter_disable_buck1" pos="2" rst="0">
        <comment>
          disable internal counter
        </comment>
      </bits>
      <bits access="rw" name="discharge_enb_buck1" pos="1" rst="1">
        <comment>
          discharge the output of buck when power down
        </comment>
      </bits>
      <bits access="rw" name="slopex0p75_buck1" pos="0" rst="1">
        <comment>
          75% of slope compensation 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="buck1_sync_clk_cfg">
      <bits access="r" name="buck1_sync_clk_cfg_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck1_en" pos="9" rst="1">
      </bits>
      <bits access="rw" name="sync_clk_buck1_pol" pos="8" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck1_phase_mod" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck1_dither_sel" pos="4:1" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck1_dither_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_buck2_vcore_cfg_1">
      <bits access="r" name="ldo_buck2_vcore_cfg_1_reserved_0" pos="31:17" rst="0">
      </bits>
      <bits access="rw" name="low_sense_bit_buck2" pos="16:15" rst="1">
        <comment>
          increase peak detect current to increase load current
        </comment>
      </bits>
      <bits access="r" name="ref_ready_buck2" pos="14" rst="0">
        <comment>
          complete soft_start
        </comment>
      </bits>
      <bits access="rw" name="pfm_mode_sel_buck2" pos="13" rst="0">
        <comment>
          pfm mode select_x000D_
1:pfm mode and pwm mode auto switch_x000D_
0:force pwm mode
        </comment>
      </bits>
      <bits access="rw" name="dis_lowbat_buck2" pos="12" rst="0">
        <comment>
          disable detection of lowvbat
        </comment>
      </bits>
      <bits access="rw" name="slopex2_buck2" pos="11" rst="0">
        <comment>
          200% of slope compensation 
        </comment>
      </bits>
      <bits access="rw" name="en_irdelay_buck2" pos="10" rst="0">
        <comment>
          delay 2ns of ir detection
        </comment>
      </bits>
      <bits access="rw" name="ir_cmp_lr_buck2" pos="9" rst="1">
        <comment>
          reduce or increase Vref of ircmp 
        </comment>
      </bits>
      <bits access="rw" name="ir_cmp_bit_buck2" pos="8:6" rst="0">
        <comment>
          adjustment of ircmp
        </comment>
      </bits>
      <bits access="rw" name="heavy_load_buck2" pos="5" rst="0">
        <comment>
          increase peak detect current to increase load current
        </comment>
      </bits>
      <bits access="rw" name="heavy_load2_buck2" pos="4" rst="0">
        <comment>
          increase peak detect current to increase load current
        </comment>
      </bits>
      <bits access="rw" name="dis_antiring_sleep_buck2" pos="3" rst="1">
        <comment>
          disable antiring sleep when antiring_disable_buck2=1
        </comment>
      </bits>
      <bits access="rw" name="antiring_disable_buck2" pos="2" rst="1">
        <comment>
          disable antiring active
        </comment>
      </bits>
      <bits access="rw" name="pfm_clk_disable_buck2" pos="1" rst="1">
        <comment>
          disable pfm_clk
        </comment>
      </bits>
      <bits access="rw" name="vout_sel_buck2" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_buck2_vcore_cfg_2">
      <bits access="r" name="ldo_buck2_vcore_cfg_2_reserved_0" pos="31:27" rst="0">
      </bits>
      <bits access="rw" name="pfm_mode_clk_buck2_sel" pos="26:25" rst="2">
      </bits>
      <bits access="rw" name="pfm_mode_clk_buck2_en" pos="24" rst="1">
      </bits>
      <bits access="rw" name="vbuck2_bit_lp" pos="23:19" rst="16">
      </bits>
      <bits access="rw" name="vbuck2_bit_pm0" pos="18:14" rst="16">
      </bits>
      <bits access="rw" name="nonov_delay_buck2" pos="13:12" rst="0">
        <comment>
          dcdc nonovlap clk dead time adjust
        </comment>
      </bits>
      <bits access="rw" name="osc_freq_buck2" pos="11:9" rst="2">
        <comment>
          internal clock frequency control
        </comment>
      </bits>
      <bits access="rw" name="pfm_threshold_buck2" pos="8:7" rst="2">
        <comment>
          pfm mode current threshold
        </comment>
      </bits>
      <bits access="rw" name="gdrv_n_en_70ma_buck2" pos="6" rst="1">
        <comment>
          more nldmos for 100ma load
        </comment>
      </bits>
      <bits access="rw" name="gdrv_p_en_70ma_buck2" pos="5" rst="1">
        <comment>
          more pldmos for 100ma load
        </comment>
      </bits>
      <bits access="rw" name="soft_en_buck2" pos="4" rst="1">
        <comment>
          dcdc soft_start
        </comment>
      </bits>
      <bits access="rw" name="ldo_cc_disable_buck2" pos="3" rst="0">
        <comment>
          reduce bandwidth of ldo
        </comment>
      </bits>
      <bits access="rw" name="counter_disable_buck2" pos="2" rst="0">
        <comment>
          disable internal counter
        </comment>
      </bits>
      <bits access="rw" name="discharge_enb_buck2" pos="1" rst="1">
        <comment>
          discharge the output of buck when power down
        </comment>
      </bits>
      <bits access="rw" name="slopex0p75_buck2" pos="0" rst="1">
        <comment>
          75% of slope compensation 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="buck2_sync_clk_cfg">
      <bits access="r" name="buck2_sync_clk_cfg_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck2_en" pos="9" rst="1">
      </bits>
      <bits access="rw" name="sync_clk_buck2_pol" pos="8" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck2_phase_mod" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck2_dither_sel" pos="4:1" rst="0">
      </bits>
      <bits access="rw" name="sync_clk_buck2_dither_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vrf28_rfio_cfg">
      <bits access="r" name="ldo_vrf28_rfio_cfg_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="rw" name="vrfio_vbit" pos="22:20" rst="4">
      </bits>
      <bits access="rw" name="vrfio_vsel" pos="19:18" rst="3">
      </bits>
      <bits access="rw" name="pu_vrfio_dly" pos="17" rst="0">
      </bits>
      <bits access="rw" name="pu_vrfio" pos="16" rst="0">
      </bits>
      <bits access="r" name="ldo_vrf28_rfio_cfg_reserved_1" pos="15:5" rst="0">
      </bits>
      <bits access="rw" name="vrf28_vbit" pos="4:2" rst="4">
      </bits>
      <bits access="rw" name="pu_vrf28_dly" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_vrf28" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vspimem_cfg">
      <bits access="r" name="ldo_vspimem_cfg_reserved_0" pos="31:8" rst="0">
      </bits>
      <bits access="rw" name="vspimem_vbit" pos="7:4" rst="8">
      </bits>
      <bits access="rw" name="vspimem_cc_disable" pos="3" rst="0">
        <comment>
          current sensing disalbe_x000D_
1:disable_x000D_
0: enable
        </comment>
      </bits>
      <bits access="rw" name="vspimem_cur_limit_enb" pos="2" rst="0">
        <comment>
          currnt limiting_x000D_
1: disable _x000D_
0: enable
        </comment>
      </bits>
      <bits access="rw" name="pu_vspimem_dly" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_vspimem" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="ldo_vsim0_cfg">
      <bits access="r" name="ldo_vsim0_cfg_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="vsim0_vbit" pos="6:4" rst="4">
      </bits>
      <bits access="rw" name="vsim0_vsel" pos="3:2" rst="0">
        <comment>
          00:1.8v, 01:2.0v,10: 2.8v, 11: 3.0v
        </comment>
      </bits>
      <bits access="rw" name="pu_vsim0_dly" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_vsim0" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vsim1_cfg">
      <bits access="r" name="ldo_vsim1_cfg_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="vsim1_vbit" pos="6:4" rst="4">
      </bits>
      <bits access="rw" name="vsim1_vsel" pos="3:2" rst="0">
        <comment>
          00:1.8v, 01:2.0v,10: 2.8v, 11: 3.0v
        </comment>
      </bits>
      <bits access="rw" name="pu_vsim1_dly" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_vsim1" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vibr_cfg">
      <bits access="r" name="ldo_vibr_cfg_reserved_0" pos="31:7" rst="0">
      </bits>
      <bits access="rw" name="vibr_vbit" pos="6:4" rst="4">
      </bits>
      <bits access="rw" name="vibr_vsel" pos="3" rst="0">
        <comment>
          00:1.8v, 01:2.0v,10: 2.8v, 11: 3.0v
        </comment>
      </bits>
      <bits access="rw" name="vibr_cc_disable" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pu_vibr_dly" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_vibr" pos="0" rst="0">
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="pmu1_cfg_misc">
      <bits access="r" name="pmu1_cfg_misc_reserved_0" pos="31:12" rst="0">
      </bits>
      <bits access="rw" name="thermal_check_bypass" pos="11" rst="1">
        <comment>
          0: Enable the thermal check
1: Disable the thermal check
        </comment>
      </bits>
      <bits access="rw" name="thermal_sel" pos="10:9" rst="0">
        <comment>
          over temp threshold sel_x000D_
00: 142 _x000D_
01: 130_x000D_
10: 120_x000D_
11: 108
        </comment>
      </bits>
      <bits access="rw" name="pu_thermal_protect" pos="8" rst="0">
        <comment>
          enable thermal protect function_x000D_
0:disable_x000D_
1:enable
        </comment>
      </bits>
      <bits access="rw" name="charge_pump_ldo_en" pos="7" rst="1">
        <comment>
          enable charge pump for ldo_usb/ldo_vio
        </comment>
      </bits>
      <bits access="r" name="pmu1_cfg_misc_reserved_1" pos="6:1" rst="0">
      </bits>
      <bits access="rw" name="vbat_monitor_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="clk_gpadc_cfg">
      <bits access="r" name="clk_gpadc_cfg_reserved_0" pos="31:5" rst="0">
      </bits>
      <bits access="rw" name="cfg_clk_gpadc" pos="4:0" rst="5">
      </bits>
    </reg>
    <reg protect="rw" name="gpadc_cfg_0">
      <bits access="rw" name="gpadc_start_interval" pos="31:16" rst="65535">
      </bits>
      <bits access="rw" name="gpadc_channel_sel" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="gpadc_sar_mode" pos="7" rst="0">
      </bits>
      <bits access="rw" name="sar_adc_out_pol" pos="6" rst="0">
      </bits>
      <bits access="rw" name="gpadc_auto_en" pos="5" rst="0">
      </bits>
      <bits access="rw" name="gpadc_vref_bit" pos="4:3" rst="2">
      </bits>
      <bits access="rw" name="gpadc_vref_ms_enable" pos="2" rst="0">
      </bits>
      <bits access="rw" name="key_pullup2x" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_gpadc_sw" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="gpadc_cfg_1">
      <bits access="r" name="gpadc_cfg_1_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="conv_wait_time" pos="23:16" rst="0">
      </bits>
      <bits access="rw" name="samp_time" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="samp_wait_time" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="gpadc_cfg_3">
      <bits access="r" name="gpadc_cfg_3_reserved_0" pos="31:14" rst="0">
      </bits>
      <bits access="rc" name="gpadc_end_stat_inn" pos="13" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="conv_time" pos="12:3" rst="8">
      </bits>
      <bits access="rw" name="gpadc_en" pos="2" rst="0">
      </bits>
      <bits access="rw" name="rst_gpadc_sw" pos="1" rst="1">
      </bits>
      <bits access="rw" name="gpadc_int_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc0_value">
      <bits access="r" name="gpadc0_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc0_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc1_value">
      <bits access="r" name="gpadc1_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc1_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc2_value">
      <bits access="r" name="gpadc2_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc2_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc3_value">
      <bits access="r" name="gpadc3_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc3_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc4_value">
      <bits access="r" name="gpadc4_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc4_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc5_value">
      <bits access="r" name="gpadc5_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc5_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc6_value">
      <bits access="r" name="gpadc6_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc6_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="gpadc7_value">
      <bits access="r" name="gpadc7_value_reserved_0" pos="31:10" rst="0">
      </bits>
      <bits access="r" name="gpadc7_value_inn" pos="9:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_cfg">
      <bits access="r" name="efuse_cfg_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="efuse_prot_cfg" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse_time_cfg">
      <bits access="r" name="efuse_time_cfg_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="efuse_avdd_time" pos="23:14" rst="8">
      </bits>
      <bits access="rw" name="efuse_pgm_time" pos="13:4" rst="8">
      </bits>
      <bits access="rw" name="efuse_read_time" pos="3:0" rst="4">
      </bits>
    </reg>
    <reg protect="rw" name="efuse0_cfg">
      <bits access="r" name="efuse0_cfg_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rc" name="efuse_done_0" pos="18" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="efuse_pgm_0" pos="17" rst="0">
      </bits>
      <bits access="rw" name="efuse_read_0" pos="16" rst="0">
      </bits>
      <bits access="rw" name="efuse_prot_0" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse0_pgm_data_0">
      <bits access="rw" name="efuse0_pgm_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse0_pgm_data_1">
      <bits access="rw" name="efuse0_pgm_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse0_pgm_data_2">
      <bits access="rw" name="efuse0_pgm_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse0_pgm_data_3">
      <bits access="rw" name="efuse0_pgm_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse0_read_data_0">
      <bits access="r" name="efuse0_read_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse0_read_data_1">
      <bits access="r" name="efuse0_read_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse0_read_data_2">
      <bits access="r" name="efuse0_read_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse0_read_data_3">
      <bits access="r" name="efuse0_read_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse1_cfg">
      <bits access="r" name="efuse1_cfg_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rc" name="efuse_done_1" pos="18" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="efuse_pgm_1" pos="17" rst="0">
      </bits>
      <bits access="rw" name="efuse_read_1" pos="16" rst="0">
      </bits>
      <bits access="rw" name="efuse_prot_1" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse1_pgm_data_0">
      <bits access="rw" name="efuse1_pgm_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse1_pgm_data_1">
      <bits access="rw" name="efuse1_pgm_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse1_pgm_data_2">
      <bits access="rw" name="efuse1_pgm_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse1_pgm_data_3">
      <bits access="rw" name="efuse1_pgm_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse1_read_data_0">
      <bits access="r" name="efuse1_read_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse1_read_data_1">
      <bits access="r" name="efuse1_read_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse1_read_data_2">
      <bits access="r" name="efuse1_read_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse1_read_data_3">
      <bits access="r" name="efuse1_read_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse2_cfg">
      <bits access="r" name="efuse2_cfg_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rc" name="efuse_done_2" pos="18" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="efuse_pgm_2" pos="17" rst="0">
      </bits>
      <bits access="rw" name="efuse_read_2" pos="16" rst="0">
      </bits>
      <bits access="rw" name="efuse_prot_2" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse2_pgm_data_0">
      <bits access="rw" name="efuse2_pgm_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse2_pgm_data_1">
      <bits access="rw" name="efuse2_pgm_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse2_pgm_data_2">
      <bits access="rw" name="efuse2_pgm_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse2_pgm_data_3">
      <bits access="rw" name="efuse2_pgm_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse2_read_data_0">
      <bits access="r" name="efuse2_read_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse2_read_data_1">
      <bits access="r" name="efuse2_read_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse2_read_data_2">
      <bits access="r" name="efuse2_read_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse2_read_data_3">
      <bits access="r" name="efuse2_read_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse3_cfg">
      <bits access="r" name="efuse3_cfg_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rc" name="efuse_done_3" pos="18" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="efuse_pgm_3" pos="17" rst="0">
      </bits>
      <bits access="rw" name="efuse_read_3" pos="16" rst="0">
      </bits>
      <bits access="rw" name="efuse_prot_3" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse3_pgm_data_0">
      <bits access="rw" name="efuse3_pgm_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse3_pgm_data_1">
      <bits access="rw" name="efuse3_pgm_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse3_pgm_data_2">
      <bits access="rw" name="efuse3_pgm_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="efuse3_pgm_data_3">
      <bits access="rw" name="efuse3_pgm_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse3_read_data_0">
      <bits access="r" name="efuse3_read_data_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse3_read_data_1">
      <bits access="r" name="efuse3_read_data_63_32" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse3_read_data_2">
      <bits access="r" name="efuse3_read_data_95_64" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="efuse3_read_data_3">
      <bits access="r" name="efuse3_read_data_127_96" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rampdac_cfg">
      <bits access="r" name="rampdac_cfg_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="ramp_dac_din" pos="15:6" rst="512">
      </bits>
      <bits access="rw" name="ramp_dac_gain" pos="5:1" rst="4">
      </bits>
      <bits access="rw" name="pu_ramp_dac" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_reserved_vcore_in">
      <bits access="rw" name="pmu1_rsvd_in_vcore" pos="31:16" rst="61440">
      </bits>
      <bits access="rw" name="pmu2_rsvd_in_vcore" pos="15:0" rst="61440">
      </bits>
    </reg>
    <reg protect="r" name="pmu_reserved_vcore_out">
      <bits access="r" name="pmu_reserved_vcore_out_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="pmu1_rsvd_out_vcore" pos="15:8" rst="0">
      </bits>
      <bits access="r" name="pmu2_rsvd_out_vcore" pos="7:0" rst="0">
      </bits>
    </reg>
    <hole size="160"/>
    <reg protect="r" name="pmu_powr_state">
      <bits access="r" name="pmu_powr_state_reserved_0" pos="31:27" rst="0">
      </bits>
      <bits access="r" name="pmu_pm3_wakeup_exist" pos="26" rst="0">
      </bits>
      <bits access="r" name="pmu_pm2_wakeup_exist" pos="25" rst="0">
      </bits>
      <bits access="r" name="pmu_pm1_wakeup_exist" pos="24" rst="0">
      </bits>
      <bits access="r" name="pmu_powr_state_reserved_1" pos="23" rst="0">
      </bits>
      <bits access="r" name="pmu_pm03_sw_state" pos="22:18" rst="0">
      </bits>
      <bits access="r" name="pmu_pm02_sw_state" pos="17:13" rst="0">
      </bits>
      <bits access="r" name="pmu_pm01_sw_state" pos="12:8" rst="0">
        <comment>
          current  pmuc state
        </comment>
      </bits>
      <bits access="r" name="first_pwon_state" pos="7:4" rst="0">
      </bits>
      <bits access="r" name="pmu_pm_state" pos="3:0" rst="0">
        <comment>
          current  pmuc state
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="mcu_power_mode_ctrl">
      <bits access="rw" name="mcu_reg_pu_done" pos="31" rst="0">
      </bits>
      <bits access="r" name="mcu_power_mode_ctrl_reserved_0" pos="30:17" rst="0">
      </bits>
      <bits access="rc" name="soft_mcu_sleep" pos="16" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          only used for debug
        </comment>
      </bits>
      <bits access="rw" name="mcu_mem_ret1n_cfg" pos="15" rst="0">
      </bits>
      <bits access="r" name="mcu_pm3_enter_done" pos="14" rst="0">
      </bits>
      <bits access="r" name="mcu_pm2_enter_done" pos="13" rst="0">
      </bits>
      <bits access="r" name="mcu_pm1_enter_done" pos="12" rst="0">
      </bits>
      <bits access="rw" name="mcu_sw_26m_en" pos="11" rst="1">
      </bits>
      <bits access="rw" name="mcu_sw_32k_en" pos="10" rst="1">
      </bits>
      <bits access="r" name="mcu_pm3_wakeup_exist" pos="9" rst="0">
      </bits>
      <bits access="r" name="mcu_pm2_wakeup_exist" pos="8" rst="0">
      </bits>
      <bits access="r" name="mcu_pm1_wakeup_exist" pos="7" rst="0">
      </bits>
      <bits access="r" name="mcu_sub_sys_state" pos="6:2" rst="0">
      </bits>
      <bits access="rw" name="mcu_pm_mode" pos="1:0" rst="3">
        <comment>
          power mode for mcu sub sys
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bb_power_mode_ctrl">
      <bits access="rw" name="bb_reg_pu_done" pos="31" rst="0">
      </bits>
      <bits access="r" name="bb_power_mode_ctrl_reserved_0" pos="30:17" rst="0">
        <comment>
          only used for debug
        </comment>
      </bits>
      <bits access="rc" name="soft_bcpu_sleep" pos="16" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="bb_mem_ret1n_cfg" pos="15" rst="0">
      </bits>
      <bits access="r" name="bb_pm3_enter_done" pos="14" rst="0">
      </bits>
      <bits access="r" name="bb_pm2_enter_done" pos="13" rst="0">
      </bits>
      <bits access="r" name="bb_pm1_enter_done" pos="12" rst="0">
      </bits>
      <bits access="rw" name="bb_sw_26m_en" pos="11" rst="1">
      </bits>
      <bits access="rw" name="bb_sw_32k_en" pos="10" rst="1">
      </bits>
      <bits access="r" name="bb_pm3_wakeup_exist" pos="9" rst="0">
      </bits>
      <bits access="r" name="bb_pm2_wakeup_exist" pos="8" rst="0">
      </bits>
      <bits access="r" name="bb_pm1_wakeup_exist" pos="7" rst="0">
      </bits>
      <bits access="r" name="bb_sub_sys_state" pos="6:2" rst="0">
      </bits>
      <bits access="rw" name="bb_pm_mode" pos="1:0" rst="3">
        <comment>
          power mode for bb sub sys
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="power_status">
      <bits access="r" name="power_status_reserved_0" pos="31:12" rst="0">
      </bits>
      <bits access="r" name="bb_pm3_state" pos="11" rst="0">
      </bits>
      <bits access="r" name="bb_pm2_state" pos="10" rst="0">
      </bits>
      <bits access="r" name="bb_pm1_state" pos="9" rst="0">
      </bits>
      <bits access="r" name="mcu_pm3_state" pos="8" rst="0">
      </bits>
      <bits access="r" name="mcu_pm2_state" pos="7" rst="0">
      </bits>
      <bits access="r" name="mcu_pm1_state" pos="6" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_done" pos="5" rst="1">
      </bits>
      <bits access="r" name="pmu_pu_ready" pos="4" rst="0">
      </bits>
      <bits access="r" name="bb_pu_done" pos="3" rst="1">
      </bits>
      <bits access="r" name="bb_pu_ready" pos="2" rst="0">
      </bits>
      <bits access="r" name="mcu_pu_done" pos="1" rst="1">
      </bits>
      <bits access="r" name="mcu_pu_ready" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="pm_mode_status">
      <bits access="r" name="pm_mode_status_reserved_0" pos="31:27" rst="0">
      </bits>
      <bits access="r" name="pu_vmmc" pos="26" rst="0">
      </bits>
      <bits access="r" name="pd_lptop" pos="25" rst="0">
      </bits>
      <bits access="r" name="pu_vio" pos="24" rst="0">
      </bits>
      <bits access="r" name="pu_vmem" pos="23" rst="0">
      </bits>
      <bits access="r" name="pu_buck2_ldo" pos="22" rst="0">
      </bits>
      <bits access="r" name="pu_buck2" pos="21" rst="0">
      </bits>
      <bits access="r" name="pu_buck1_ldo" pos="20" rst="0">
      </bits>
      <bits access="r" name="pu_buck1" pos="19" rst="0">
      </bits>
      <bits access="r" name="pin7_wakeup_level" pos="18" rst="0">
      </bits>
      <bits access="r" name="pin6_wakeup_level" pos="17" rst="0">
      </bits>
      <bits access="r" name="pin5_wakeup_level" pos="16" rst="0">
      </bits>
      <bits access="r" name="pin4_wakeup_level" pos="15" rst="0">
      </bits>
      <bits access="r" name="pin3_wakeup_level" pos="14" rst="0">
      </bits>
      <bits access="r" name="pin2_wakeup_level" pos="13" rst="0">
      </bits>
      <bits access="r" name="pin1_wakeup_level" pos="12" rst="0">
      </bits>
      <bits access="r" name="pin0_wakeup_level" pos="11" rst="0">
      </bits>
      <bits access="r" name="resetb_hw_lptop" pos="10" rst="1">
      </bits>
      <bits access="r" name="resetb_hw_bb" pos="9" rst="1">
      </bits>
      <bits access="r" name="resetb_hw_cm4" pos="8" rst="1">
      </bits>
      <bits access="r" name="iso_aon" pos="7" rst="1">
      </bits>
      <bits access="r" name="lp_mode_b" pos="6" rst="0">
      </bits>
      <bits access="r" name="lp_mode_bg" pos="5" rst="0">
      </bits>
      <bits access="r" name="lp_26mxtal_fsm" pos="4" rst="0">
      </bits>
      <bits access="r" name="ldo_vrtc_status" pos="3" rst="0">
      </bits>
      <bits access="r" name="pu_26mxtal" pos="2" rst="0">
      </bits>
      <bits access="r" name="pwrswitch_en" pos="1" rst="0">
      </bits>
      <bits access="r" name="pu_bg_fsm" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu2_reserved_reg">
      <bits access="rw" name="pmu2_rsvd_reg" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="clkbuffer_ctrl">
      <bits access="r" name="clkbuffer_ctrl_reserved_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="delay_time_ctrl_1">
      <bits access="r" name="delay_time_ctrl_1_reserved_0" pos="31" rst="0">
      </bits>
      <bits access="rw" name="pm2_pu_pwr_cnt_value_sel" pos="30:29" rst="0">
      </bits>
      <bits access="rw" name="lptop_wait_rst_rls_time_sel" pos="28:27" rst="0">
      </bits>
      <bits access="rw" name="cnt_value_pm3_pd_pwr" pos="26:24" rst="0">
      </bits>
      <bits access="rw" name="cnt_value_pm2_pd_pwr" pos="23:21" rst="0">
        <comment>
          counter value for the delay of pm1 close(lp) ldo
        </comment>
      </bits>
      <bits access="rw" name="pm1_pu_pwr_cnt_value_sel" pos="20:19" rst="0">
        <comment>
          counter value for the delay of pm1 wakeup ldo
        </comment>
      </bits>
      <bits access="rw" name="cnt_value_pm1_pd_pwr" pos="18:16" rst="0">
        <comment>
          counter value for the delay of pm1 close(lp) ldo
        </comment>
      </bits>
      <bits access="rw" name="xtal_enter_lp_time_sel" pos="15:14" rst="0">
        <comment>
          26m xtal rdy time for wake up from pm1 
00:60us, 01:90us, 10:120us, 11:240us
        </comment>
      </bits>
      <bits access="rw" name="pwrswitch_open_time_sel" pos="13:12" rst="2">
        <comment>
          00:200us,01:0.5ms:10:3ms,11:8ms
        </comment>
      </bits>
      <bits access="rw" name="dbb_rst_rls_time_sel" pos="11:10" rst="2">
        <comment>
          Wait time after DBB reset release
00:32us, 01:1.5ms, 10:2ms, 11:8ms
        </comment>
      </bits>
      <bits access="rw" name="open_xtal_time_sel" pos="9:8" rst="0">
        <comment>
          26m xtal rdy time for wake up from pm1 
00:60us, 01:90us, 10:120us, 11:250us
        </comment>
      </bits>
      <bits access="rw" name="pwron_xtal_wait_ready_time" pos="7:6" rst="2">
        <comment>
          26m xtal rdy time for power on
00:120us, 01:1.5ms, 10:2.5ms, 11:8ms
        </comment>
      </bits>
      <bits access="rw" name="open_ldo_time_sel" pos="5:4" rst="2">
        <comment>
          The interval of open powr source
00:120us, 01:325us, 10:600us, 11:2ms
        </comment>
      </bits>
      <bits access="rw" name="pwrswitch_delay_time_sel" pos="3:2" rst="2">
        <comment>
          pwrswitch_en_delay timer control:
00: 250us
01: 500us
10: 750us
11: 1ms

        </comment>
      </bits>
      <bits access="rw" name="pu_ldo_delay_time_sel" pos="1:0" rst="2">
        <comment>
          pu_ldo and pu_ldo_delay delay time select:  
00:200us 01:250us, 10:300us,11:350us
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sub_sys_delay_time_ctrl">
      <bits access="r" name="sub_sys_delay_time_ctrl_reserved_0" pos="31:15" rst="0">
      </bits>
      <bits access="rw" name="pm2_sw32k_time" pos="14:12" rst="1">
      </bits>
      <bits access="rw" name="pin_rst_debounce_time_sel" pos="11:10" rst="3">
      </bits>
      <bits access="rw" name="pwrkey_debounce_time_sel" pos="9:8" rst="2">
        <comment>
          powerkey debounce time sel:
00:100ms, 01:250ms, 10:500ms,11:1s
        </comment>
      </bits>
      <bits access="rw" name="sub_sys_rst_rlease_time_sel" pos="7:6" rst="0">
      </bits>
      <bits access="rw" name="sub_sys_pu_power_timer" pos="5:4" rst="1">
      </bits>
      <bits access="rw" name="sub_sys_sleep_counter_val" pos="3:2" rst="0">
      </bits>
      <bits access="rw" name="switch_clk_time" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mcu_bb_subsys_ctrl">
      <bits access="r" name="mcu_bb_subsys_ctrl_reserved_0" pos="31:17" rst="0">
      </bits>
      <bits access="rw" name="pd_lptop_disable" pos="16" rst="1">
      </bits>
      <bits access="rw" name="pd_bb_mem3_dr" pos="15" rst="0">
      </bits>
      <bits access="rw" name="pd_bb_mem2_dr" pos="14" rst="0">
      </bits>
      <bits access="rw" name="pd_bb_mem1_dr" pos="13" rst="0">
      </bits>
      <bits access="rw" name="pd_bb_mem0_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="bb_pm2_mem3_vce_off" pos="11" rst="0">
      </bits>
      <bits access="rw" name="bb_pm2_mem2_vce_off" pos="10" rst="0">
      </bits>
      <bits access="rw" name="bb_pm2_mem1_vce_off" pos="9" rst="0">
      </bits>
      <bits access="rw" name="bb_pm2_mem0_vce_off" pos="8" rst="0">
      </bits>
      <bits access="rw" name="pd_mcu_mem2_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="pd_mcu_mem1_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="pd_mcu_mem0_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="mcu_pm2_mem2_vce_off" pos="4" rst="0">
      </bits>
      <bits access="rw" name="mcu_pm2_mem1_vce_off" pos="3" rst="0">
      </bits>
      <bits access="rw" name="mcu_pm2_mem0_vce_off" pos="2" rst="0">
      </bits>
      <bits access="rw" name="bb_mem_ret_disable" pos="1" rst="0">
      </bits>
      <bits access="rw" name="mcu_mem_ret_disable" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mcu_bb_power_domain_ctrl">
      <bits access="r" name="mcu_bb_power_domain_ctrl_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="rw" name="iso_lptop_reg" pos="27" rst="1">
      </bits>
      <bits access="rw" name="iso_lptop_dr" pos="26" rst="0">
      </bits>
      <bits access="r" name="mcu_mem_ret1n" pos="25" rst="1">
      </bits>
      <bits access="r" name="pd_mcu_mem0_core" pos="24" rst="0">
      </bits>
      <bits access="r" name="pd_mcu_mem1_core" pos="23" rst="0">
      </bits>
      <bits access="r" name="pd_mcu_mem2_core" pos="22" rst="0">
      </bits>
      <bits access="r" name="pd_mcu_subsys" pos="21" rst="0">
      </bits>
      <bits access="r" name="iso_mcu_subsys" pos="20" rst="1">
      </bits>
      <bits access="r" name="bb_mem_ret1n" pos="19" rst="1">
      </bits>
      <bits access="r" name="pd_bb_mem0_core" pos="18" rst="0">
      </bits>
      <bits access="r" name="pd_bb_mem1_core" pos="17" rst="0">
      </bits>
      <bits access="r" name="pd_bb_mem2_core" pos="16" rst="0">
      </bits>
      <bits access="r" name="pd_bb_mem3_core" pos="15" rst="0">
      </bits>
      <bits access="r" name="pd_bb_subsys" pos="14" rst="0">
      </bits>
      <bits access="r" name="iso_bb_subsys" pos="13" rst="1">
      </bits>
      <bits access="rw" name="resetb_lptop_disable" pos="12" rst="0">
      </bits>
      <bits access="rw" name="resetb_bb_reg" pos="11" rst="1">
      </bits>
      <bits access="rw" name="resetb_bb_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="resetb_mcu_reg" pos="9" rst="1">
      </bits>
      <bits access="rw" name="resetb_mcu_dr" pos="8" rst="0">
      </bits>
      <bits access="rw" name="pd_mcu_subsys_reg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="pd_mcu_subsys_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="pd_bb_subsys_reg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="pd_bb_subsys_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="iso_bb_subsys_reg" pos="3" rst="0">
      </bits>
      <bits access="rw" name="iso_bb_subsys_dr" pos="2" rst="0">
      </bits>
      <bits access="rw" name="iso_mcu_subsys_reg" pos="1" rst="0">
      </bits>
      <bits access="rw" name="iso_mcu_subsys_dr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_pu_ctrl">
      <bits access="r" name="pmu_pu_ctrl_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="sel_aon_pclk_en" pos="29" rst="1">
      </bits>
      <bits access="rw" name="soft_wakeup_mcu" pos="28" rst="0">
      </bits>
      <bits access="rw" name="soft_wakeup_bb" pos="27" rst="0">
      </bits>
      <bits access="rw" name="cap_coarse_bit" pos="26:24" rst="5">
      </bits>
      <bits access="rw" name="cap_fine_bit" pos="23:21" rst="2">
      </bits>
      <bits access="rw" name="vdd_lpo_vbit" pos="20:19" rst="2">
      </bits>
      <bits access="rw" name="sel_rc_clk" pos="18" rst="0">
      </bits>
      <bits access="rw" name="sel_32k_src" pos="17:16" rst="0">
        <comment>
          32k clock source select
0: rc 32k
1: xtal32k
2: xtal26 -&gt; 32K
3:  xtal26 -&gt; 32K
        </comment>
      </bits>
      <bits access="rw" name="pu_lpo_10k" pos="15" rst="1">
      </bits>
      <bits access="rw" name="pu_lpo_32k" pos="14" rst="1">
        <comment>
          lpo_32k enable
        </comment>
      </bits>
      <bits access="rw" name="pu_32k_xtal" pos="13" rst="0">
        <comment>
          32k xtal enable.
        </comment>
      </bits>
      <bits access="rw" name="enable_pm2_off_lptop" pos="12" rst="1">
      </bits>
      <bits access="rw" name="vmux_out_sel_reg" pos="11" rst="1">
      </bits>
      <bits access="rw" name="vmux_out_sel_dr" pos="10" rst="0">
      </bits>
      <bits access="rw" name="pm2_sw_lptop_32k_en" pos="9" rst="1">
      </bits>
      <bits access="rw" name="pm1_sw_lptop_32k_en" pos="8" rst="1">
      </bits>
      <bits access="rw" name="pm2_sw_lptop_26m_en" pos="7" rst="1">
      </bits>
      <bits access="rw" name="pm1_sw_lptop_26m_en" pos="6" rst="1">
      </bits>
      <bits access="rw" name="pm3_en_xtal" pos="5" rst="0">
        <comment>
          0: PM3 will shut off the xtal.
1: PM3, xtal enter LP mode
        </comment>
      </bits>
      <bits access="rw" name="pm2_en_xtal" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pm1_en_xtal" pos="3" rst="1">
        <comment>
          0: PM1 will shut off the xtal.
1: PM1, xtal enter LP mode
        </comment>
      </bits>
      <bits access="rw" name="pu_26mxtal_reg" pos="2" rst="0">
        <comment>
          0: soft can mask the 26m xtal, 1: enable
        </comment>
      </bits>
      <bits access="rw" name="pu_26mxtal_dr" pos="1" rst="0">
        <comment>
          1: soft enable the 26m xtal
        </comment>
      </bits>
      <bits access="rw" name="pwrswitch_en_force" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmuc_sys_ctrl">
      <bits access="rc" name="aon_pin7_wakeup_clr" pos="31" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin6_wakeup_clr" pos="30" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin5_wakeup_clr" pos="29" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin4_wakeup_clr" pos="28" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin3_wakeup_clr" pos="27" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin2_wakeup_clr" pos="26" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin1_wakeup_clr" pos="25" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin0_wakeup_clr" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="sel_pin7_wakeup_src" pos="23:22" rst="0">
      </bits>
      <bits access="rw" name="sel_pin6_wakeup_src" pos="21:20" rst="0">
      </bits>
      <bits access="rw" name="sel_pin5_wakeup_src" pos="19:18" rst="0">
      </bits>
      <bits access="rw" name="sel_pin4_wakeup_src" pos="17:16" rst="0">
      </bits>
      <bits access="rw" name="sel_pin3_wakeup_src" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="sel_pin2_wakeup_src" pos="13:12" rst="0">
      </bits>
      <bits access="rw" name="sel_pin1_wakeup_src" pos="11:10" rst="0">
        <comment>
          0: H level wake up
1: L Level wake up
2: posedge wakeup
3: negedge wakup
        </comment>
      </bits>
      <bits access="rw" name="sel_pin0_wakeup_src" pos="9:8" rst="0">
        <comment>
          0: H level wake up
1: L Level wake up
2: posedge wakeup
3: negedge wakup
        </comment>
      </bits>
      <bits access="rw" name="pmu_pu_done_reg" pos="7" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_done_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_ready_reg" pos="5" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_ready_dr" pos="4" rst="0">
      </bits>
      <bits access="r" name="pmuc_sys_ctrl_reserved_0" pos="3" rst="0">
      </bits>
      <bits access="r" name="pmuc_sys_ctrl_reserved_1" pos="2" rst="0">
      </bits>
      <bits access="rw" name="lp_mode_b_reg" pos="1" rst="1">
      </bits>
      <bits access="rw" name="lp_mode_b_dr" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mcu_wake_up_ctrl">
      <bits access="r" name="mcu_wake_up_ctrl_reserved_0" pos="31:20" rst="0">
      </bits>
      <bits access="rw" name="bypass_bt_wakeup_mcu" pos="19" rst="0">
      </bits>
      <bits access="rw" name="bypass_wdt_int_wakeup_mcu" pos="18" rst="0">
      </bits>
      <bits access="rw" name="bypass_lpuart_wakeup_mcu" pos="17" rst="0">
      </bits>
      <bits access="rw" name="bypass_sys_timer_wakeup_mcu" pos="16" rst="0">
      </bits>
      <bits access="rw" name="bypass_gpio_irq_wakeup_mcu" pos="15" rst="0">
      </bits>
      <bits access="rw" name="bypass_bb_irq_wakeup_mcu" pos="14" rst="1">
      </bits>
      <bits access="rw" name="bypass_cm4_wakeup_mcu" pos="13" rst="0">
      </bits>
      <bits access="rw" name="bypass_dbghst_wakeup_mcu" pos="12" rst="0">
      </bits>
      <bits access="rw" name="bypass_lps_wakeup_mcu" pos="11" rst="0">
      </bits>
      <bits access="rw" name="bypass_rtc_wakeup_mcu" pos="10" rst="0">
      </bits>
      <bits access="rw" name="bypass_pin7wakeup_mcu" pos="9" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin6wakeup_mcu" pos="8" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin5wakeup_mcu" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin4wakeup_mcu" pos="6" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin3wakeup_mcu" pos="5" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin2wakeup_mcu" pos="4" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin1wakeup_mcu" pos="3" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin0wakeup_mcu" pos="2" rst="1">
      </bits>
      <bits access="rw" name="bypass_chg_on_wakeup_mcu" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bypass_pwrkey_wakeup_mcu" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bb_wake_up_ctrl">
      <bits access="r" name="bb_wake_up_ctrl_reserved_0" pos="31:20" rst="0">
      </bits>
      <bits access="rw" name="bypass_bt_wakeup_bb" pos="19" rst="0">
      </bits>
      <bits access="rw" name="bypass_wdt_int_wakeup_bb" pos="18" rst="0">
      </bits>
      <bits access="rw" name="bypass_lpuart_wakeup_bb" pos="17" rst="0">
      </bits>
      <bits access="rw" name="bypass_sys_timer_wakeup_bb" pos="16" rst="0">
      </bits>
      <bits access="rw" name="bypass_gpio_irq_wakeup_bb" pos="15" rst="0">
      </bits>
      <bits access="rw" name="bypass_bb_irq_wakeup_bb" pos="14" rst="0">
      </bits>
      <bits access="rw" name="bypass_cm4_wakeup_bb" pos="13" rst="1">
      </bits>
      <bits access="rw" name="bypass_dbghst_wakeup_bb" pos="12" rst="0">
      </bits>
      <bits access="rw" name="bypass_lps_wakeup_bb" pos="11" rst="0">
      </bits>
      <bits access="rw" name="bypass_rtc_wakeup_bb" pos="10" rst="0">
      </bits>
      <bits access="rw" name="bypass_pin7wakeup_bb" pos="9" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin6wakeup_bb" pos="8" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin5wakeup_bb" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin4wakeup_bb" pos="6" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin3wakeup_bb" pos="5" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin2wakeup_bb" pos="4" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin1wakeup_bb" pos="3" rst="1">
      </bits>
      <bits access="rw" name="bypass_pin0wakeup_bb" pos="2" rst="1">
      </bits>
      <bits access="rw" name="bypass_chg_on_wakeup_bb" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bypass_pwrkey_wakeup_bb" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="mcu_wakeup_clr">
      <bits access="r" name="mcu_wakeup_clr_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rc" name="wdt_rst_st_clr" pos="23" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="bt_wakeup_clr" pos="22" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="lpuart_wakeup_clr" pos="21" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="systimer_wakeup_clr" pos="20" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="gpio_wakeup_clr" pos="19" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="rtc_wakeup_clr" pos="18" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="lps_wakeup_clr" pos="17" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="bb_irq_wakeup_clr" pos="16" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="dbg_hst_wakeup_clr" pos="15" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="software_wakeup_clr" pos="14" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="mcu_irq_wakeup_clr" pos="13" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_7_wakeup_clr" pos="12" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_6_wakeup_clr" pos="11" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_5_wakeup_clr" pos="10" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_4_wakeup_clr" pos="9" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_3_wakeup_clr" pos="8" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_2_wakeup_clr" pos="7" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_1_wakeup_clr" pos="6" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_0_wakeup_clr" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="bor_rst_wakeup_clr" pos="4" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="wdt_int_wakeup_clr" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="pin_rst_wakeup_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="ac_on_wakeup_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="pwrkey_wakeup_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bb_wakeup_clr">
      <bits access="r" name="bb_wakeup_clr_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="r" name="bb_wakeup_clr_reserved_1" pos="23" rst="0">
      </bits>
      <bits access="rc" name="bt_wakeup_clr" pos="22" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="lpuart_wakeup_clr" pos="21" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="systimer_wakeup_clr" pos="20" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="gpio_wakeup_clr" pos="19" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="rtc_wakeup_clr" pos="18" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="lps_wakeup_clr" pos="17" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="bb_irq_wakeup_clr" pos="16" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="dbg_hst_wakeup_clr" pos="15" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="software_wakeup_clr" pos="14" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="mcu_irq_wakeup_clr" pos="13" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_7_wakeup_clr" pos="12" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_6_wakeup_clr" pos="11" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_5_wakeup_clr" pos="10" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_4_wakeup_clr" pos="9" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_3_wakeup_clr" pos="8" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_2_wakeup_clr" pos="7" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_1_wakeup_clr" pos="6" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="aon_pin_0_wakeup_clr" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="r" name="bb_wakeup_clr_reserved_2" pos="4" rst="0">
      </bits>
      <bits access="rc" name="wdt_int_wakeup_clr" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="r" name="bb_wakeup_clr_reserved_3" pos="2" rst="0">
      </bits>
      <bits access="rc" name="ac_on_wakeup_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="pwrkey_wakeup_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="mcu_wakeup_status">
      <bits access="r" name="mcu_wakeup_status_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="r" name="wdt_rst_pwron_staus" pos="23" rst="0">
      </bits>
      <bits access="r" name="bt_wakeup_status" pos="22" rst="0">
      </bits>
      <bits access="r" name="lpuart_wakeup_status" pos="21" rst="0">
      </bits>
      <bits access="r" name="systimer_wakeup_status" pos="20" rst="0">
      </bits>
      <bits access="r" name="gpio_wakeup_status" pos="19" rst="0">
      </bits>
      <bits access="r" name="rtc_wakeup_status" pos="18" rst="0">
      </bits>
      <bits access="r" name="lps_wakeup_status" pos="17" rst="0">
      </bits>
      <bits access="r" name="bb_irq_wakeup_status" pos="16" rst="0">
      </bits>
      <bits access="r" name="dbg_hst_wakeup_status" pos="15" rst="0">
      </bits>
      <bits access="r" name="software_wakeup_status" pos="14" rst="0">
      </bits>
      <bits access="r" name="mcu_irq_wakeup_status" pos="13" rst="0">
      </bits>
      <bits access="r" name="aon_pin7_wakeup_status" pos="12" rst="0">
      </bits>
      <bits access="r" name="aon_pin6_wakeup_status" pos="11" rst="0">
      </bits>
      <bits access="r" name="aon_pin5_wakeup_status" pos="10" rst="0">
      </bits>
      <bits access="r" name="aon_pin4_wakeup_status" pos="9" rst="0">
      </bits>
      <bits access="r" name="aon_pin3_wakeup_status" pos="8" rst="0">
      </bits>
      <bits access="r" name="aon_pin2_wakeup_status" pos="7" rst="0">
      </bits>
      <bits access="r" name="aon_pin1_wakeup_status" pos="6" rst="0">
      </bits>
      <bits access="r" name="aon_pin0_wakeup_status" pos="5" rst="0">
      </bits>
      <bits access="r" name="bor_rst_pwron_status" pos="4" rst="0">
      </bits>
      <bits access="r" name="wdt_irq_wakeup_status" pos="3" rst="0">
      </bits>
      <bits access="r" name="pin_rst_pwron_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="ac_on_wakeup_status" pos="1" rst="0">
      </bits>
      <bits access="r" name="pwrkey_wakeup_status" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="bb_wakeup_status">
      <bits access="r" name="bb_wakeup_status_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="r" name="wdt_rst_pwron_staus" pos="23" rst="0">
      </bits>
      <bits access="r" name="bt_wakeup_status" pos="22" rst="0">
      </bits>
      <bits access="r" name="lpuart_wakeup_status" pos="21" rst="0">
      </bits>
      <bits access="r" name="systimer_wakeup_status" pos="20" rst="0">
      </bits>
      <bits access="r" name="gpio_wakeup_status" pos="19" rst="0">
      </bits>
      <bits access="r" name="rtc_wakeup_status" pos="18" rst="0">
      </bits>
      <bits access="r" name="lps_wakeup_status" pos="17" rst="0">
      </bits>
      <bits access="r" name="bb_irq_wakeup_status" pos="16" rst="0">
      </bits>
      <bits access="r" name="dbg_hst_wakeup_status" pos="15" rst="0">
      </bits>
      <bits access="r" name="software_wakeup_status" pos="14" rst="0">
      </bits>
      <bits access="r" name="mcu_irq_wakeup_status" pos="13" rst="0">
      </bits>
      <bits access="r" name="aon_pin7_wakeup_status" pos="12" rst="0">
      </bits>
      <bits access="r" name="aon_pin6_wakeup_status" pos="11" rst="0">
      </bits>
      <bits access="r" name="aon_pin5_wakeup_status" pos="10" rst="0">
      </bits>
      <bits access="r" name="aon_pin4_wakeup_status" pos="9" rst="0">
      </bits>
      <bits access="r" name="aon_pin3_wakeup_status" pos="8" rst="0">
      </bits>
      <bits access="r" name="aon_pin2_wakeup_status" pos="7" rst="0">
      </bits>
      <bits access="r" name="aon_pin1_wakeup_status" pos="6" rst="0">
      </bits>
      <bits access="r" name="aon_pin0_wakeup_status" pos="5" rst="0">
      </bits>
      <bits access="r" name="bor_rst_pwron_status" pos="4" rst="0">
      </bits>
      <bits access="r" name="wdt_irq_wakeup_status" pos="3" rst="0">
      </bits>
      <bits access="r" name="pin_rst_pwron_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="ac_on_wakeup_status" pos="1" rst="0">
      </bits>
      <bits access="r" name="pwrkey_wakeup_status" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="abnormal_pwroff_src">
      <bits access="r" name="abnormal_pwroff_src_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="r" name="aon_wdt_rst_occur" pos="3" rst="0">
        <comment>
          shut down for aon wdt reset
        </comment>
      </bits>
      <bits access="r" name="brown_out_occur" pos="2" rst="0">
        <comment>
          shut down for brown out detect
        </comment>
      </bits>
      <bits access="r" name="low_bat_occur" pos="1" rst="0">
        <comment>
          shut down for low bat detect
        </comment>
      </bits>
      <bits access="r" name="rst_ext_occur" pos="0" rst="0">
        <comment>
          shut down by resetb_ext 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="abnormal_pwroff_status_clr">
      <bits access="r" name="abnormal_pwroff_status_clr_reserved_0" pos="31:4" rst="0">
      </bits>
      <bits access="rc" name="aon_wdt_rst_occur_clr" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="brown_out_occur_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="low_bat_occur_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="rst_occur_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
    </reg>
    <reg protect="r" name="pmuc_int_cause">
      <bits access="r" name="pmuc_int_cause_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="r" name="over_temp_int_status" pos="8" rst="0">
      </bits>
      <bits access="r" name="pwrkey_int_status" pos="7" rst="0">
      </bits>
      <bits access="r" name="ac_on_int_status" pos="6" rst="0">
        <comment>
          AC connect or disconnect interrupt cause
        </comment>
      </bits>
      <bits access="r" name="bb_pu_ready_int_status" pos="5" rst="0">
      </bits>
      <bits access="r" name="bb_pu_done_int_status" pos="4" rst="0">
      </bits>
      <bits access="r" name="mcu_pu_ready_int_status" pos="3" rst="0">
      </bits>
      <bits access="r" name="mcu_pu_done_int_status" pos="2" rst="0">
      </bits>
      <bits access="r" name="pmu_pu_ready_int_status" pos="1" rst="0">
        <comment>
          The Power-Up Sequence is in state Ready._x000D_            
        </comment>
      </bits>
      <bits access="r" name="pmu_pu_done_int_status" pos="0" rst="0">
        <comment>
          The Power-Up Sequence is done (or idle)._x000D_            
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pmuc_int_mask">
      <bits access="r" name="pmuc_int_mask_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="rw" name="over_temp_int_mask" pos="8" rst="0">
      </bits>
      <bits access="rw" name="pwrkey_int_mask" pos="7" rst="0">
      </bits>
      <bits access="rw" name="ac_on_int_mask" pos="6" rst="0">
        <comment>
          AC connect or disconnect interrupt mask 1:enable the interrupt
        </comment>
      </bits>
      <bits access="rw" name="bb_pu_ready_int_mask" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bb_pu_done_int_mask" pos="4" rst="0">
      </bits>
      <bits access="rw" name="mcu_pu_ready_int_mask" pos="3" rst="0">
      </bits>
      <bits access="rw" name="mcu_pu_done_int_mask" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pmu_pu_ready_int_mask" pos="1" rst="0">
        <comment>
          The Power-Up Sequence is in state Ready mask 1:enable the interrupt
        </comment>
      </bits>
      <bits access="rw" name="pmu_pu_done_int_mask" pos="0" rst="0">
        <comment>
          The Power-Up Sequence is done (or idle) mask 1:enable the interrupt
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pmuc_int_clr">
      <bits access="r" name="pmuc_int_clr_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="rc" name="over_temp_int_clr" pos="8" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="pwrkey_int_clr" pos="7" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="chr_ac_on_int_clr" pos="6" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          Clear the AC connect or disconnect interrupt. Write 1 to clear the interrupt
        </comment>
      </bits>
      <bits access="rc" name="bb_pu_ready_int_clr" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          clear the  Power-Up Sequence is in state Ready Write 1 to clear the interrupt
        </comment>
      </bits>
      <bits access="rc" name="bb_pu_done_int_clr" pos="4" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          clear the Power-Up Sequence is done (or idle) mask Write 1 to clear the interrupt
        </comment>
      </bits>
      <bits access="rc" name="mcu_pu_ready_int_clr" pos="3" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          clear the  Power-Up Sequence is in state Ready Write 1 to clear the interrupt
        </comment>
      </bits>
      <bits access="rc" name="mcu_pu_done_int_clr" pos="2" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          clear the Power-Up Sequence is done (or idle) mask Write 1 to clear the interrupt
        </comment>
      </bits>
      <bits access="rc" name="pmu_pu_ready_int_clr" pos="1" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          clear the  Power-Up Sequence is in state Ready Write 1 to clear the interrupt
        </comment>
      </bits>
      <bits access="rc" name="pmu_pu_done_int_clr" pos="0" rst="0">
        <comment>
        bit type is changed from w1c to rc.

          clear the Power-Up Sequence is done (or idle) mask Write 1 to clear the interrupt
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xtal_ctrl_1">
      <bits access="r" name="xtal_ctrl_1_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="rw" name="xtal_clk2bt_rfpll_en" pos="28" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk2bt_adpll_en" pos="27" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk2bt_adc_en" pos="26" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk2aupll_en" pos="25" rst="1">
      </bits>
      <bits access="rw" name="xtal_vamp_ibit_xosc_lp" pos="24:21" rst="0">
      </bits>
      <bits access="rw" name="xtal_vamp_ibit_xosc_nor" pos="20:17" rst="4">
      </bits>
      <bits access="rw" name="xtal_lvds2nb_bbpll_en" pos="16" rst="0">
      </bits>
      <bits access="rw" name="xtal_lvds2gsm_bbpll_en" pos="15" rst="0">
      </bits>
      <bits access="rw" name="xtal_clk2gsm_bbpll_en" pos="14" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk2nb_bbpll_en" pos="13" rst="1">
      </bits>
      <bits access="rw" name="xtal_clk2dig_en" pos="12" rst="1">
      </bits>
      <bits access="r" name="xtal_ctrl_1_reserved_1" pos="11" rst="0">
      </bits>
      <bits access="rw" name="xtal_clk6m5_en_aux" pos="10" rst="0">
      </bits>
      <bits access="rw" name="xtal_rdac_hlsel_nor" pos="9:8" rst="3">
      </bits>
      <bits access="rw" name="xtal_rdac_hlsel_lp" pos="7:6" rst="3">
      </bits>
      <bits access="rw" name="xtal_reg_bit" pos="5:3" rst="4">
      </bits>
      <bits access="rw" name="xtal_lp_mode_en_reg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="xtal_lp_mode_en_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="xtal_6m5_en_mcu_reg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="xtal_ctrl_2">
      <bits access="r" name="xtal_ctrl_2_reserved_0" pos="31:27" rst="0">
      </bits>
      <bits access="rw" name="xtal_6m5_en_bb_reg" pos="26" rst="0">
      </bits>
      <bits access="rw" name="xtal_fix_ibit_xosc_lp" pos="25:21" rst="3">
      </bits>
      <bits access="rw" name="xtal_fix_ibit_xosc_nor" pos="20:16" rst="24">
      </bits>
      <bits access="r" name="xtal_ctrl_2_reserved_1" pos="15" rst="0">
      </bits>
      <bits access="rw" name="xtal_capbank_bit_lp" pos="14:8" rst="64">
      </bits>
      <bits access="r" name="xtal_ctrl_2_reserved_2" pos="7" rst="0">
      </bits>
      <bits access="rw" name="xtal_capbank_bit_nor" pos="6:0" rst="64">
      </bits>
    </reg>
    <reg protect="rw" name="xtal_ctrl_3">
      <bits access="r" name="xtal_ctrl_3_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="xdrv_clk_en" pos="23:20" rst="15">
      </bits>
      <bits access="rw" name="xdrv_reg_bit" pos="19:17" rst="4">
      </bits>
      <bits access="rw" name="pu_xdrv" pos="16" rst="0">
      </bits>
      <bits access="rw" name="xtal_din_dr" pos="15" rst="1">
      </bits>
      <bits access="r" name="xtal_ctrl_3_reserved_1" pos="14" rst="0">
      </bits>
      <bits access="rw" name="xtal_din_reg" pos="13:0" rst="8192">
      </bits>
    </reg>
    <reg protect="rw" name="xtal26m_to_32k_divider_ctrl">
      <bits access="r" name="div_lp_mode_h" pos="31" rst="0">
        <comment>
          32k divider work mode. 0: normal mode, 1: low poer mode.
        </comment>
      </bits>
      <bits access="r" name="xtal26m_to_32k_divider_ctrl_reserved_0" pos="30:29" rst="0">
      </bits>
      <bits access="rw" name="step_offset_nor" pos="28:16" rst="0">
        <comment>
          32k divider normal mode step
        </comment>
      </bits>
      <bits access="rw" name="step_offset_lp" pos="15:3" rst="0">
        <comment>
          32k divider lp mode step
        </comment>
      </bits>
      <bits access="rw" name="div_lp_mode_h_reg" pos="2" rst="0">
        <comment>
          Lp Mode Derect Control
        </comment>
      </bits>
      <bits access="rw" name="div_lp_mode_h_dr" pos="1" rst="0">
        <comment>
          Lp Mode Value
        </comment>
      </bits>
      <bits access="rw" name="step_offset_update" pos="0" rst="0">
        <comment>
          Update the Step Offset Value for 32k divider
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="charge_cfg_ctrl_1">
      <bits access="r" name="charge_cfg_ctrl_1_reserved_0" pos="31:28" rst="0">
      </bits>
      <bits access="r" name="chr_highac_9v" pos="27" rst="0">
      </bits>
      <bits access="r" name="chr_highac_6v" pos="26" rst="0">
      </bits>
      <bits access="r" name="lowac_4p6" pos="25" rst="0">
      </bits>
      <bits access="r" name="chr_vreg" pos="24" rst="0">
      </bits>
      <bits access="r" name="chr_creg" pos="23" rst="0">
      </bits>
      <bits access="rw" name="chr_ac_on_time_sel" pos="22:21" rst="1">
        <comment>
          Sel the ac on ready time
        </comment>
      </bits>
      <bits access="rw" name="chr_auxadc_sel" pos="20:19" rst="0">
        <comment>
          select the auxout to gpadc.                    00: sel sense voltage of charging current to gpadc;
01: sel TS(Temperature sense) voltage to gpadc; 
10: sel ac_div_in (ac/6) to gpadc;
11:NC
        </comment>
      </bits>
      <bits access="rw" name="chr_cc_i_bit" pos="18:15" rst="8">
        <comment>
          constant current charging tunning bits
        </comment>
      </bits>
      <bits access="rw" name="chr_bypass_chopper" pos="14" rst="0">
      </bits>
      <bits access="r" name="charge_cfg_ctrl_1_reserved_1" pos="13" rst="0">
      </bits>
      <bits access="rw" name="chr_bypass_chopper_isense" pos="12" rst="0">
      </bits>
      <bits access="rw" name="pa_on_bypass" pos="11" rst="0">
        <comment>
          1: disable the pa_on forbid lowbat detect
        </comment>
      </bits>
      <bits access="rw" name="chr_cv_lowgain" pos="10" rst="0">
        <comment>
          constant voltage charging lowgain mode
        </comment>
      </bits>
      <bits access="r" name="chr_ac_on" pos="9" rst="0">
        <comment>
          1: AC connector is on.
        </comment>
      </bits>
      <bits access="r" name="low_bat_detected" pos="8" rst="0">
        <comment>
          1: detect low bat
        </comment>
      </bits>
      <bits access="r" name="bat_on_detected" pos="7" rst="0">
        <comment>
          1: detect bat is on.
        </comment>
      </bits>
      <bits access="r" name="chr_cc_mode" pos="6" rst="0">
        <comment>
          constant current charging mode. 
1::constant_current_mode
0::pre_charge_mode
        </comment>
      </bits>
      <bits access="rw" name="chr_cc_mode_reg" pos="5" rst="1">
      </bits>
      <bits access="rw" name="chr_cc_mode_dr" pos="4" rst="0">
      </bits>
      <bits access="r" name="chr_enable_detected" pos="3" rst="0">
        <comment>
          1: charge enable. 0: charge disable
        </comment>
      </bits>
      <bits access="rw" name="chr_enable_reg" pos="2" rst="1">
        <comment>
          charge enable reg
        </comment>
      </bits>
      <bits access="rw" name="chr_enable_dr" pos="1" rst="0">
        <comment>
          charge enable derect
        </comment>
      </bits>
      <bits access="rw" name="pre_chr_check_bypass" pos="0" rst="0">
        <comment>
          1:disable bad bat check. 0: Enable bad bat check.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="charge_cfg_ctrl_2">
      <bits access="r" name="charge_cfg_ctrl_2_reserved_0" pos="31:12" rst="0">
      </bits>
      <bits access="rw" name="chr_vfb_sel_reg" pos="11:8" rst="8">
        <comment>
          tunning the floating output voltage of charger.
        </comment>
      </bits>
      <bits access="rw" name="chr_vfb_sel_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="chr_uv_sel_reg" pos="6:5" rst="0">
        <comment>
          tunning threshold of under voltage lockout.
00: L-&gt;H(low to high threshold) is 3.21V, H-&gt;L(high to low threshold) is 2.57V;
01:L-&gt;H is 3.21V, H-&gt;L is  2.73V;
10: L-&gt;H is 3.21V; H-&gt;L is 2.88V;
11: L-&gt;H is 3.21V, H-&gt;L is 3.03V.
        </comment>
      </bits>
      <bits access="rw" name="chr_uv_sel_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="chr_pre_i_bit_reg" pos="3:1" rst="4">
        <comment>
          pre-charging current tunning bits
        </comment>
      </bits>
      <bits access="rw" name="chr_pre_i_bit_dr" pos="0" rst="0">
        <comment>
          1: disable the pa_on forbid lowbat detect
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="charge_efuse_out0">
      <bits access="r" name="efuse_out0_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="charge_efuse_out1">
      <bits access="r" name="efuse_out1_31_0" pos="31:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="bg_cfg">
      <bits access="r" name="bg_cfg_reserved_0" pos="31:26" rst="0">
      </bits>
      <bits access="rw" name="pm2_bg_on_en" pos="25" rst="1">
      </bits>
      <bits access="rw" name="pm1_bg_on_en" pos="24" rst="1">
      </bits>
      <bits access="rw" name="count_bg_rdy" pos="23:19" rst="2">
        <comment>
          wait bg ready time
        </comment>
      </bits>
      <bits access="rw" name="bg_res_tc_bit" pos="18:14" rst="23">
        <comment>
          tunning the temperatrue coefficient bandgap voltage.
        </comment>
      </bits>
      <bits access="rw" name="bg_ts_i_ctrl" pos="13:10" rst="8">
        <comment>
          tunning the current for TS. 
        </comment>
      </bits>
      <bits access="rw" name="bg_freq_bit" pos="9:8" rst="2">
        <comment>
          tunning chopping frequency. 
2'b00::400kHz;
2'b01::750kHz; 
2'b10::1.1MHz; 
2'b11::1.5MHz
        </comment>
      </bits>
      <bits access="rw" name="pu_bg_ts" pos="7" rst="0">
        <comment>
          disable temperature sense of battery. 
1::enable temperature sense
0::disable temperature sense
        </comment>
      </bits>
      <bits access="rw" name="bg_ref_sel_reg" pos="6" rst="0">
        <comment>
          select output reference between bandgap out and vref_pre_reg. ref_sel should follow below sequence:
 when power up, rel_sel should first be 1(the output v1200m=vref_pre_reg), after about 50us when chopping is working, change ref_sel to 0(the output v1200m=vref_bg with chopping)
        </comment>
      </bits>
      <bits access="rw" name="bg_ref_sel_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="bg_chopper_enb_reg" pos="4" rst="0">
        <comment>
          disable chopping function.
1::disable
0::enable
        </comment>
      </bits>
      <bits access="rw" name="bg_chopper_enb_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="lp_mode_bg_reg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="lp_mode_bg_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pu_bg_force" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_buck1_vrtc_cfg">
      <bits access="r" name="ldo_buck1_vrtc_cfg_reserved_0" pos="31:21" rst="0">
      </bits>
      <bits access="rw" name="ldo_vref_sel_buck1" pos="20" rst="1">
      </bits>
      <bits access="rw" name="vout_sel_ldo_buck1" pos="19" rst="0">
      </bits>
      <bits access="rw" name="vbuck1_ldo_bit_lp" pos="18:15" rst="9">
      </bits>
      <bits access="rw" name="vbuck1_ldo_bit_pm0" pos="14:11" rst="9">
      </bits>
      <bits access="rw" name="buck1_dcdc_mode_en" pos="10" rst="0">
        <comment>
          0: LDO mode
1: BUCK mode
        </comment>
      </bits>
      <bits access="rw" name="pu_ldo_ready_buck1_reg" pos="9" rst="0">
        <comment>
          enable control of ldo
        </comment>
      </bits>
      <bits access="rw" name="pu_dcdc_ready_buck1_reg" pos="8" rst="0">
        <comment>
          enable control of dcdc
        </comment>
      </bits>
      <bits access="rw" name="pu_ldo_ready_buck1_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="pu_dcdc_ready_buck1_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="pu_buck1_force" pos="5" rst="0">
      </bits>
      <bits access="rw" name="pu_buck1_ldo_pm3" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pu_buck1_ldo_pm2" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_buck1_ldo_pm1" pos="2" rst="1">
      </bits>
      <bits access="rw" name="pu_buck1_ldo_pm0" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pu_buck1_ldo_force" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_buck2_vrtc_cfg">
      <bits access="r" name="ldo_buck2_vrtc_cfg_reserved_0" pos="31:21" rst="0">
      </bits>
      <bits access="rw" name="ldo_vref_sel_buck2" pos="20" rst="1">
      </bits>
      <bits access="rw" name="vout_sel_ldo_buck2" pos="19" rst="0">
      </bits>
      <bits access="rw" name="vbuck2_ldo_bit_lp" pos="18:15" rst="4">
      </bits>
      <bits access="rw" name="vbuck2_ldo_bit_pm0" pos="14:11" rst="4">
      </bits>
      <bits access="rw" name="buck2_dcdc_mode_en" pos="10" rst="0">
        <comment>
          0: LDO mode
1: BUCK mode
        </comment>
      </bits>
      <bits access="rw" name="pu_ldo_ready_buck2_reg" pos="9" rst="0">
        <comment>
          enable control of ldo
        </comment>
      </bits>
      <bits access="rw" name="pu_dcdc_ready_buck2_reg" pos="8" rst="0">
        <comment>
          enable control of dcdc
        </comment>
      </bits>
      <bits access="rw" name="pu_ldo_ready_buck2_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="pu_dcdc_ready_buck2_dr" pos="6" rst="0">
      </bits>
      <bits access="rw" name="pu_buck2_force" pos="5" rst="0">
      </bits>
      <bits access="rw" name="pu_buck2_ldo_pm3" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pu_buck2_ldo_pm2" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_buck2_ldo_pm1" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pu_buck2_ldo_pm0" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pu_buck2_ldo_force" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vmem_cfg">
      <bits access="r" name="ldo_vmem_cfg_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="psram_retention" pos="15" rst="0">
      </bits>
      <bits access="rw" name="pu_lp_vmem_en" pos="14" rst="0">
      </bits>
      <bits access="rw" name="vmem_vbit_lp" pos="13:11" rst="4">
      </bits>
      <bits access="rw" name="vmem_vbit_pm0" pos="10:8" rst="4">
      </bits>
      <bits access="rw" name="vmem_vsel_lp" pos="7" rst="1">
        <comment>
          1:1.8v, 0:2.8v
        </comment>
      </bits>
      <bits access="rw" name="vmem_vsel_pm0" pos="6" rst="1">
        <comment>
          1:1.8v, 0:2.8v
        </comment>
      </bits>
      <bits access="rw" name="vmem_cur_limit_enb" pos="5" rst="0">
      </bits>
      <bits access="rw" name="vmem_cc_disable" pos="4" rst="0">
      </bits>
      <bits access="rw" name="pu_vmem_pm3" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_vmem_pm2" pos="2" rst="1">
      </bits>
      <bits access="rw" name="pu_vmem_pm1" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pu_vmem_pm0" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vio_cfg">
      <bits access="r" name="ldo_vio_cfg_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rw" name="pu_lp_vio_dr" pos="18" rst="0">
      </bits>
      <bits access="rw" name="pu_lp_vio_pm2" pos="17" rst="0">
      </bits>
      <bits access="rw" name="pu_lp_vio_pm1" pos="16" rst="1">
      </bits>
      <bits access="rw" name="vio_vbit_lp" pos="15:13" rst="4">
      </bits>
      <bits access="rw" name="vio_vbit_pm0" pos="12:10" rst="4">
      </bits>
      <bits access="rw" name="vio_vsel_lp" pos="9:8" rst="3">
        <comment>
          00:3.3v, 01:2.8v, 11:1.8v
        </comment>
      </bits>
      <bits access="rw" name="vio_vsel_pm0" pos="7:6" rst="3">
        <comment>
          00:3.3v, 01:2.8v, 11:1.8v
        </comment>
      </bits>
      <bits access="rw" name="vio_cc_disable" pos="5" rst="0">
        <comment>
          current sensing disalbe_x000D_
1:disable_x000D_
0: enable
        </comment>
      </bits>
      <bits access="rw" name="vio_cur_limit_enb" pos="4" rst="0">
        <comment>
          currnt limiting_x000D_
1: disable _x000D_
0: enable
        </comment>
      </bits>
      <bits access="rw" name="pu_vio_pm3" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_vio_pm2" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pu_vio_pm1" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pu_vio_pm0" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="ldo_vmmc_cfg">
      <bits access="r" name="ldo_vmmc_cfg_reserved_0" pos="31:19" rst="0">
      </bits>
      <bits access="rw" name="pu_lp_vmmc_pm2" pos="18" rst="0">
      </bits>
      <bits access="rw" name="pu_lp_vmmc_pm1" pos="17" rst="1">
      </bits>
      <bits access="rw" name="pu_lp_vmmc_dr" pos="16" rst="0">
      </bits>
      <bits access="rw" name="vmmc_vbit_lp" pos="15:13" rst="4">
      </bits>
      <bits access="rw" name="vmmc_vbit_pm0" pos="12:10" rst="4">
      </bits>
      <bits access="rw" name="vmmc_vsel_lp" pos="9:8" rst="3">
      </bits>
      <bits access="rw" name="vmmc_vsel_pm0" pos="7:6" rst="3">
        <comment>
          00:3.3v, 01:2.8v, 11:1.8v
        </comment>
      </bits>
      <bits access="rw" name="vmmc_cc_disable" pos="5" rst="0">
        <comment>
          current sensing disalbe_x000D_
1:disable_x000D_
0: enable
        </comment>
      </bits>
      <bits access="rw" name="vmmc_cur_limit_enb" pos="4" rst="0">
        <comment>
          currnt limiting_x000D_
1: disable _x000D_
0: enable
        </comment>
      </bits>
      <bits access="rw" name="pu_vmmc_pm3" pos="3" rst="0">
      </bits>
      <bits access="rw" name="pu_vmmc_pm2" pos="2" rst="0">
      </bits>
      <bits access="rw" name="pu_vmmc_pm1" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pu_vmmc_pm0" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="vrtc_ulp_cfg">
      <bits access="r" name="vrtc_ulp_cfg_reserved_0" pos="31:12" rst="0">
      </bits>
      <bits access="rw" name="vbat_bakup_vbit" pos="11:8" rst="10">
        <comment>
          usded for vbat_bakup_vbit
        </comment>
      </bits>
      <bits access="rw" name="ldo_ulp_vrtc_vbit_lp" pos="7:4" rst="8">
      </bits>
      <bits access="rw" name="ldo_ulp_vrtc_vbit_pm0" pos="3:0" rst="8">
      </bits>
    </reg>
    <reg protect="rw" name="bor_lowbat_cfg">
      <bits access="r" name="bor_lowbat_cfg_reserved_0" pos="31:11" rst="0">
      </bits>
      <bits access="rw" name="aon_wdt_reset_bypass" pos="10" rst="1">
      </bits>
      <bits access="rw" name="low_bat_det_bypass" pos="9" rst="0">
      </bits>
      <bits access="rw" name="disable_pullup_res" pos="8" rst="0">
        <comment>
          1: Disable the pull up resistory on the pwrkey PAD.
        </comment>
      </bits>
      <bits access="rw" name="bor_vth_bit" pos="7:2" rst="4">
        <comment>
          bor vth sel
     L-&gt;H  H-&gt;L
0000  2.09  2.21
0001  2.28  2.43
001*  2.46  2.64
01**  2.63  2.82
1***  2.80  3.00
        </comment>
      </bits>
      <bits access="rw" name="en_bor" pos="1" rst="0">
        <comment>
          1: Control the ANA to enalb brown out detection
        </comment>
      </bits>
      <bits access="rw" name="bor_det_bypass" pos="0" rst="1">
        <comment>
          1:bypass the brown out detection 
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="lpuart_cfg">
      <bits access="r" name="lpuart_cfg_reserved_0" pos="31:29" rst="0">
      </bits>
      <bits access="rw" name="lpuart_enable" pos="28" rst="0">
      </bits>
      <bits access="rw" name="ip_clk_disable_lpuart" pos="27" rst="0">
      </bits>
      <bits access="rw" name="dbg_disable_acg_clk_lpuart" pos="26" rst="0">
      </bits>
      <bits access="rw" name="sel_clk_lpuart" pos="25" rst="1">
      </bits>
      <bits access="rc" name="lpuart_div_update" pos="24" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="lpuart_div_denom" pos="23:10" rst="8">
      </bits>
      <bits access="rw" name="lpuart_div_num" pos="9:0" rst="7">
      </bits>
    </reg>
    <reg protect="rw" name="aon_soft_reset_ctrl">
      <bits access="r" name="aon_soft_reset_ctrl_reserved_0" pos="31:6" rst="0">
      </bits>
      <bits access="rw" name="aon_wdt_soft_reset" pos="5" rst="0">
      </bits>
      <bits access="rw" name="lpuart_soft_reset" pos="4" rst="1">
      </bits>
      <bits access="rw" name="rtc_soft_reset" pos="3" rst="1">
      </bits>
      <bits access="rw" name="gsmlps_soft_reset" pos="2" rst="1">
      </bits>
      <bits access="rw" name="nblps_soft_reset" pos="1" rst="1">
      </bits>
      <bits access="rw" name="pmu_reg_soft_reset" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="r" name="rtc_calib_div_value">
      <bits access="r" name="rtc_calib_div_value_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="r" name="div_num_value" pos="22:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rtc_calib_ctrl">
      <bits access="r" name="rtc_calib_ctrl_reserved_0" pos="31:9" rst="0">
      </bits>
      <bits access="r" name="rtc_calib_ctrl_reserved_1" pos="8:7" rst="0">
      </bits>
      <bits access="rw" name="calib_need_open_xtal" pos="6" rst="0">
      </bits>
      <bits access="rc" name="calib_soft_start" pos="5" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rc" name="calib_done" pos="4" rst="0">
        <comment>
        bit type is changed from w1c to rc.

        </comment>
      </bits>
      <bits access="rw" name="rc32k_cal_cnt_n" pos="3:0" rst="8">
        <comment>
          calib_time = 64K period * 2^n
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rtc_calib_add">
      <bits access="rw" name="rtc_calib_value_add" pos="31:0" rst="0">
        <comment>
          calib_num_add
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ca_power_ctrl">
      <bits access="r" name="ca_power_ctrl_reserved_0" pos="31:3" rst="0">
      </bits>
      <bits access="rw" name="iso_ca" pos="2" rst="1">
      </bits>
      <bits access="rw" name="pd_ca_dly" pos="1" rst="0">
      </bits>
      <bits access="rw" name="pd_ca" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="pmu_reserved_vrtc_in">
      <bits access="rw" name="pmu1_rsvd_in_vrtc" pos="31:16" rst="61440">
      </bits>
      <bits access="r" name="pmu_reserved_vrtc_in_reserved_0" pos="15:8" rst="0">
      </bits>
      <bits access="rw" name="pmu2_rsvd_in_vrtc" pos="7:0" rst="240">
      </bits>
    </reg>
    <reg protect="r" name="pmu_reserved_vrtc_out">
      <bits access="r" name="pmu_reserved_vrtc_out_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="r" name="pmu2_rsvd_vrtc_out" pos="15:8" rst="0">
      </bits>
      <bits access="r" name="pmu1_rsvd_vrtc_out" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="aon_dig_reserved_reg">
      <bits access="r" name="aon_dig_rsvd_in" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="aon_dig_rsvd_out" pos="15:0" rst="61440">
      </bits>
    </reg>
  </module>
</archive>

<archive relative = "psram8_ctrl.xml">

<module name="psram8_ctrl" category="System">

  <reg name="ctrl_time" protect="rw">
    <bits access="rw" name="rl_type" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="rl" pos="29:24" rst="0x3">
    </bits>
    <bits access="rw" name="wl" pos="21:16" rst="0x0">
    </bits>
    <bits access="rw" name="w_tcph" pos="13:8" rst="0x7">
    </bits>
    <bits access="rw" name="r_tcph" pos="5:0" rst="0x3">
    </bits>
  </reg>

  <reg name="read_ctrl" protect="rw">
    <bits access="rw" name="fifo_rst_time" pos="17:12" rst="0x1">
    </bits>
    <bits access="rw" name="rd_start_mode" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw" name="opt_length" pos="7:4" rst="0x3">
    </bits>
    <bits access="rw" name="rd_start_num" pos="3:0" rst="0x7">
    </bits>
  </reg>

  <reg name="delay_final_add" protect="rw">
    <bits access="rw" name="delay_final_add_clk" pos="20:16" rst="0x1">
    </bits>
    <bits access="rw" name="delay_final_add_dqs_o" pos="12:8" rst="0x1">
    </bits>
    <bits access="rw" name="delay_final_add_dqs_i" pos="4:0" rst="0x1">
    </bits>
  </reg>

  <reg name="dqs_ctrl" protect="rw">
    <bits access="rw" name="o_dqs_u_delay" pos="31:24" rst="0x0">
    </bits>
    <bits access="rw" name="o_dqs_l_delay" pos="23:16" rst="0x0">
    </bits>
    <bits access="rw" name="i_dqs_u_delay" pos="15:8" rst="0x0">
    </bits>
    <bits access="rw" name="i_dqs_l_delay" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_ctrl" protect="rw">
    <bits access="rw" name="o_clk_delay" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="power_up" protect="rw">
    <bits access="rw" name="wake_up_trig" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw" name="wake_up_time" pos="19:12" rst="0xf">
    </bits>
      <bits access="r" name="init_done_state" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw" name="hw_power_pulse" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="sw_init_done" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="sw_power_level" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="power_time" protect="rw">
    <bits access="rw" name="rst_wait_time" pos="25:16" rst="0x3ff">
    </bits>
    <bits access="rw" name="rst_tcph_time" pos="13:8" rst="0x7">
    </bits>
    <bits access="rw" name="rst_acc_time" pos="5:0" rst="0x5">
    </bits>
  </reg>

  <reg name="reg_time" protect="rw">
    <bits access="rw" name="nop_time" pos="21:16" rst="0xf">
    </bits>
    <bits access="rw" name="send_reg_time" pos="13:8" rst="0x3">
    </bits>
    <bits access="rw" name="read_reg_time" pos="5:0" rst="0xf">
    </bits>
  </reg>

  <reg name="irsr" protect="r">
    <bits access="r" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="imr" protect="rw">
    <bits access="rw" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="isr" protect="r">
    <bits access="r" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="icr" protect="rw">
    <bits access="rw" name="wrong_delay" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw" name="delay_updt" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="rd_timeout" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="init_done"  pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_d" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_c" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_b" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="cross_1k_a" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="debug_sel" protect="rw">
    <bits access="rw" name="debug_sel" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="timeout_val" protect="rw">
    <bits access="rw" name="timeout_value" pos="19:0" rst="0x7ff">
    </bits>
  </reg>

  <reg name="psram_free" protect="rw">
    <bits access="r" name="psram_free" pos="31:31" rst="0x1">
    </bits>
    <bits access="r" name="phy_state" pos="4:0" rst="0x0">
    </bits>
  </reg>

  <reg name="psram_version" protect="rw">
    <bits access="rw" name="psram_density" pos="31:30" rst="0x0">
    </bits>
    <bits access="r" name="psram_version" pos="3:0" rst="0x1">
    </bits>
  </reg>
  
  <reg name="delay_train" protect="rw">
    <bits access="rw" name="auto_cfg" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="delay_final_add" pos="30:28" rst="0x1">
    </bits>
    <bits access="rw" name="delay_threshold" pos="27:24" rst="0x4">
    </bits>
    <bits access="rw" name="wait_dll_value" pos="19:16" rst="0xf">
    </bits>
    <bits access="rw" name="init_trim" pos="14:12" rst="0x7">
    </bits>
    <bits access="rw" name="init_delay" pos="11:4" rst="0x0">
    </bits>
    <bits access="rw" name="delay_step" pos="3:2" rst="0x1">
    </bits>
    <bits access="rw" name="training_en" pos="1" rst="0x0">
    </bits>
  </reg>

  <reg name="dll_state" protect="rw">
    <bits access="rw" name="dll_locked" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="real_path_delay" pos="15:8" rst="0x0">
    </bits>
    <bits access="rw" name="train_delay" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="delay_maxmin" protect="rw">
    <bits access="rw" name="train_delay_max" pos="15:8" rst="0x0">
    </bits>
    <bits access="rw" name="train_delay_min" pos="7:0" rst="0x0">
    </bits>
  </reg>

  <reg name="arbi_ctrl" protect="rw">
    <bits access="rw" name="arbi_alg" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw" name="cur_ahb" pos="9:8" rst="0x0">
    </bits>
    <bits access="rw" name="cmd_priority" pos="7:0" rst="0x1e">
    </bits>
  </reg>

  <reg name="cnt_trans_a" protect="r">
    <bits access="r" name="cnt_trans_a" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="cnt_trans_b" protect="r">
    <bits access="r" name="cnt_trans_b" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_trans_c" protect="r">
    <bits access="r" name="cnt_trans_c" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_trans_d" protect="r">
    <bits access="r" name="cnt_trans_d" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="cnt_wait_a" protect="r">
    <bits access="r" name="cnt_wait_a" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="cnt_wait_b" protect="r">
    <bits access="r" name="cnt_wait_b" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_wait_c" protect="r">
    <bits access="r" name="cnt_wait_c" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_wait_d" protect="r">
    <bits access="r" name="cnt_wait_d" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cnt_ctrl" protect="rw">
    <bits access="rw" name="cnt_stop_d" pos="7" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_d" pos="6" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_stop_c" pos="5" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_c" pos="4" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_stop_b" pos="3" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_b" pos="2" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_stop_a" pos="1" rst="0x0">
    </bits>
    <bits access="rw" name="cnt_start_a" pos="0" rst="0x0">
    </bits>
  </reg>

  <reg name="burst_length" protect="rw">
    <bits access="rw" name="qpi_en" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="wrap512_en" pos="3" rst="0x0">
    </bits>
    <bits access="rw" name="wrap64_en" pos="2" rst="0x0">
    </bits>
    <bits access="rw" name="wrap32_en" pos="1" rst="0x0">
    </bits>
    <bits access="rw" name="wrap16_en" pos="0" rst="0x0">
    </bits>
  </reg>

  <reg name="data_pinmux" protect="rw">
    <bits access="rw" name="psram_data7_sel" pos="30:28" rst="0x7">
    </bits>
    <bits access="rw" name="psram_data6_sel" pos="26:24" rst="0x6">
    </bits>
    <bits access="rw" name="psram_data5_sel" pos="22:20" rst="0x5">
    </bits>
    <bits access="rw" name="psram_data4_sel" pos="18:16" rst="0x4">
    </bits>
    <bits access="rw" name="psram_data3_sel" pos="14:12" rst="0x3">
    </bits>
    <bits access="rw" name="psram_data2_sel" pos="10:8" rst="0x2">
    </bits>
    <bits access="rw" name="psram_data1_sel" pos="6:4" rst="0x1">
    </bits>
    <bits access="rw" name="psram_data0_sel" pos="2:0" rst="0x0">
    </bits>
  </reg>

  <hole size="32"/>

  <reg name="mr0" protect="rw">
    <bits access="rw" name="mr0" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mr1" protect="r">
    <bits access="r" name="mr1" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mr2" protect="r">
    <bits access="r" name="mr2" pos="31:0" rst="0x0">
    </bits>
  </reg>
  
  <reg name="mr3" protect="rw">
    <bits access="rw" name="mr3" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mr4" protect="rw">
    <bits access="rw" name="mr4" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <hole size="32"/>

  <reg name="mr6" protect="rw">
    <bits access="rw" name="mr6" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <hole size="32"/>

  <reg name="mr8" protect="rw">
    <bits access="rw" name="mr8" pos="31:0" rst="0x0">
    </bits>
  </reg>

  <hole size="704"/>

  <reg name="cre" protect="rw">
    <bits access="rw" name="cre" pos="0:0" rst="0x0">
    </bits>
  </reg>

</module>
</archive>
<archive relative = "rf_if.xml">
<module name="rf_if" category="Baseband">
  
   
   <reg protect="rw" name="Buffer">
    <bits access="rw" name="Rx_Tx data" pos="31:0" rst="no">
      <comment>In read mode this register contains the sample received on the Rx chain. I component is located on bit[15:0] and Q component is located on bit[31:16].
      <br />This register accesses to the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data sample arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overflow error will also occur.
      <br />The data written[29:0] into this register is the data transmitted. Any attempt to write data when the FIFO is full results in the write data being lost.
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="Ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="Disable" value="0" />
        <option name="Enable" value="1" />
      </options>
      <comment>Turn on/off the rf_if interface</comment>
    </bits>
    
    <bits access="rw" name="DigRF Enable" pos="1" rst="0">
      <options>
        <option name="Disable" value="0"><comment>Analog more selected</comment></option>
        <option name="Enable" value="1"><comment>DigRF mode selected</comment></option>
      </options>
      <comment>Turn on/off the DigRF mode</comment>
    </bits>
    
    <bits access="rw" name="Rx overflow Enable" pos="4" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Rx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Rx fifo overflow interrupt</comment></option>
      </options>
      <comment>Rx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Rx Cal Bypass" pos="5" rst="1">
      <options>
        <option name="Enabled" value="0" />
        <option name="Bypassed" value="1" />
      </options>
      <comment>Calibration bypass</comment>
    </bits>
    
    <bits access="rw" name="Rx Swap I_Q" pos="6" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Rx swap I/Q</comment>
    </bits>
    
    <bits access="rw" name="Rx Force ADC On" pos="7" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Rx_On output controlled by TCO_RX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced ADC on;Rx_On output always high</comment></option>
      </options>
      <comment>Force Rx On. This bit is used only with the analog option.</comment>
    </bits>

    <bits access="rw" name="Rx Force Dec On" pos="8" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, decimator controlled by Rx_dec_on signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; decimator always on</comment></option>
      </options>
      <comment>Force Decimator On</comment>
    </bits>
    
    <bits access="w" name="Rx Force SOC" pos="9" rst="no">
      <comment>Force start of calibation in receive mode
        <br />Writing a 1 to this bit launch the calibration phase. Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
    <bits access="w" name="Rx Fifo Reset" pos="10" rst="no">
      <comment>Writing a 1 to this bit resets and flush the receive Fifo. 
        <br />Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
  
    <bits access="rw" name="Tx overflow Enable" pos="16" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo overflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo overflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits access="rw" name="Tx underflow Enable" pos="17" rst="1">
      <options>
        <option name="Disable" value="0"><comment>Disable (mask) Tx fifo undeflow interrupt</comment></option>
        <option name="Enable" value="1"><comment>Enable Tx fifo underflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Underflow interrupt Enable:</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC On" pos="18" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC on; Tx_On output always high</comment></option>
      </options>
      <comment>Force DAC On. This bit is used only with the analog option.</comment>
    </bits>
    
    <bits access="rw" name="Tx Force DAC Off" pos="19" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced DAC Off; Tx_On output always low</comment></option>
      </options>
      <comment>Force DAC Off. This bit is used only with the analog option.</comment>
    </bits>


    <bits access="rw" name="Tx Force oen" pos="20" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, Tx_Oen controlled by TCO_TX_OEN signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; Tx_Oen always high, Low pass output in HZ</comment></option>
      </options>
      <comment>Force Tx Oen. This bit is used only with the analog option.</comment>
    </bits>
  
    <bits access="rw" name="Tx Force GMSK On" pos="21" rst="0">
      <options>
        <option name="NO" value="0"><comment>No forced, transmit serial interface controlled by TCO_GMSK_ON signal from the TCU</comment></option>
        <option name="YES" value="1"><comment>Forced; serializer always enabled</comment></option>
      </options>
      <comment>Force GMSK On.</comment>
    </bits>
    <bits access="rw" name="Tx Swap I_Q" pos="22" rst="0">
      <options>
        <option name="NO" value="0"><comment>No Swap</comment></option>
        <option name="YES" value="1"><comment>Swap I/Q</comment></option>
      </options>
      <comment>Tx swap I/Q. This bit is used only with the analog option.</comment>
    </bits>
 
    <bits access="w" name="Tx Fifo Reset" pos="23" rst="no">
      <comment>Writing a 1 to this bit resets and flush the transmit Fifo. 
        <br />Write only bit, this bit doesn.t need to be cleared.
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Rate" pos="24" rst="1">
      <options>
        <option name="ONE" value="0"><comment>One sample per symbol</comment></option>
        <option name="TWO" value="1"><comment>Two samples per symbol</comment></option>
      </options>
      <comment>Rx rate for DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Rx Clk Pol" pos="25" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>
    
    <bits access="rw" name="DigRF Tx mode" pos="26" rst="1">
      <options>
        <option name="Stream" value="0"></option>
        <option name="Block" value="1"></option>
      </options>
      <comment>Tx mode for the DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>

    <bits access="rw" name="DigRF Tx Clk Pol" pos="27" rst="1">
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br />0 = No inversion
        <br />1 = Invert clock polarity
      </comment>
    </bits>

    <bits access="rw" name="DigRF Sample Size" pos="30:28" rst="all1" display="hex">
      <comment>Shift input sample in DigRF mode only. 
        <br />The Rx sample are on 16-bit, this field select a variable of bit among 16.
        <br />000 = 16-bit selected
        <br />001 = 15-bit selected 
        <br />010 = 14-bit selected
        <br />011 = 13-bit selected
        <br />100 = 12-bit selected
      </comment>
    </bits>
    <bits access="rw" name="DigRF Alignement Select" pos="31" rst="1" display="hex">
      <comment>Select the sample alignement in DigRF mode only.. 
        <br />0 = MSB aligned sample
        <br />1 = LSB aligned sample 
      </comment>
    </bits>
  </reg>
  

    <reg protect="r" name="Status">
      <bits access="r" name="Rx Fifo level" pos="4:0" rst="0">
        <comment>Those bits indicate the number of data available in the Rx Fifo.</comment>
      </bits>
      <bits access="r" name="Tx Fifo level" pos="6:5" rst="0">
        <comment>Those bits indicate the number of data available in the Tx Fifo. Those data will be sent.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Cause" pos="8" rst="0">
        <comment>Rx overflow cause register
        <br />This bit indicates that an interruption was generated when the Rx fifo is overflow. 
        <br />This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Cause" pos="9" rst="0">
        <comment>Tx overflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is overflow. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Cause" pos="10" rst="0">
        <comment>Tx underflow cause register
        <br />This bit indicates that an interruption was generated when the Tx fifo is underflow. 
        <br />This bit is cleared when the Tx_underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits access="r" name="Rx Overflow Status" pos="16" rst="0">
        <comment>This bit indicates that the receiver received a new sample when the FIFO was already full. 
        <br />The new sample is discarded. This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Overflow Status" pos="17" rst="0">
        <comment>This bit indicates that the user tried to write on the FIFO while it was already full. 
        <br />This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits access="r" name="Tx Underflow Status" pos="18" rst="0">
        <comment>This bit indicates that the modulator tried to read on the FIFO while it was empty. 
        <br />This bit is cleared when the Tx_Underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
    </reg>

    <reg protect="w" name="Interruption_clear">
      <bits access="w" name="Rx Overflow" pos="0" rst="no">
        <comment>Clear Rx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Overflow" pos="1" rst="no">
        <comment>Clear Tx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits access="w" name="Tx Underflow" pos="2" rst="no">
        <comment>Clear Tx Interrupt Underflow interrupt.
        </comment>
      </bits>
    </reg>
    <reg count="4" name="Tx Burst descriptor" protect="rw">
        <bits name="NB symbols" pos="7:0" access="rw" rst="0">
            <comment>Number of symbol to transmit
            </comment>
        </bits>
        <bits name="Modulation" pos="16" access="rw" rst="0">
            <comment>0 for GMSK, 1 for 8PSK 
            </comment>
        </bits>
        <bits name="End Burst" pos="24" access="rw" rst="0">
            <comment>Indicate an end of the transmit for this current burst
            </comment>
        </bits>
    </reg>

    <reg protect="r" name="Rx Offset">
      <bits access="r" name="Rx_Offset_I" pos="15:0" rst="all0" display="hex">
        <comment>Rx offset measured after calibration for I channel
        </comment>
      </bits>
      <bits access="r" name="Rx_Offset_Q" pos="31:16" rst="all0" display="hex">
        <comment>Rx offset measured after calibratio for Q channel
        </comment>
      </bits>
  </reg>

    <reg protect="rw" name="Rx Gain">
      <bits access="rw" name="Rx_Gain_dig" pos="9:0" rst="all0" display="hex">
        <comment>Rx Gain digital
        </comment>
      </bits>
      <bits access="rw" name="Rx_Gain_ana" pos="12:10" rst="all0" display="hex">
        <comment>Rx Gain analog
        </comment>
      </bits>
      <bits access="rw" name="Rx_Gain_en" pos="13" rst="all0" display="hex">
        <comment>Rx Gain  enable
        </comment>
      </bits>
  </reg>

    <hole size="192"/>

   
    
   <reg protect="w" name="rx_control">
     <bits access="w" name="enable_ctrl" pos="0" rst="no">
       <comment>Channel Enable, write one in this bit enable the channel.
       <br />When the channel is enabled, for a peripheral to memory transfer
       the DMA wait request from peripheral to start transfer. </comment>
     </bits>
 
     <bits access="w" name="disable_ctrl" pos="1" rst="no">
       <comment>Channel Disable, write one in this bit disable the channel.
       <br />When writing one in this bit, the current AHB transfer and current
       APB transfer (if one in progress) is completed and the channel is then
       disabled.</comment>
     </bits>

     <bits access="rw" name="burst_size" pos="16" rst="1">
      <comment>Burst size on AHB bus 
        <br />0 = Single access 
        <br />1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits access="rw" name="fifo_mode" pos="17" rst="1">
      <comment>Set FIFO mode . <br />0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br />1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
   </reg>

   <reg protect="r" name="rx_status">
     <bits access="r" name="enable_ctrl" pos="0" rst="0">
       <options>
         <option name="DISABLE" value="0" />
 
         <option name="ENABLE" value="1" />
 
         <default />
       </options>
 
       <comment>In no fifo mode the channel is automatically disabled at the
       end of the transfer. In fifo mode the channel is disabled only when
       disabled write is performed in the control register. </comment>
     </bits>
 
     <bits access="r" name="fifo_empty" pos="1" rst="1">
       <comment>When 1 the fifo is empty </comment>
     </bits>
     
     <bits access="r" name="cause_nb_htc" pos="2" rst="0">
      <comment>Cause interrupt half tc  when fifo mode is enable.</comment>
    </bits>

     <bits access="r" name="nb_htc" pos="3" rst="0">
       <comment> Half of TC interrupt when fifo mode is enable status bit. </comment>
     </bits>

     <bits access="r" name="cause_itc" pos="4" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="cause_ief" pos="5" rst="0">
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits access="r" name="cause_ihtc" pos="6" rst="0">
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>
 
     <bits access="r" name="itc" pos="7" rst="0">
       <comment>End of TC interrupt status bit. </comment>
     </bits>

    <bits access="r" name="ief" pos="8" rst="0">
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ihtc" pos="9" rst="0">
      <comment>Half TC interrupt status bit.</comment>
    </bits>

     <bits access="r" name="cur_tc" pos="31:10" rst="0x3fffff">
       <comment>Current value of transfer counter.</comment>
     </bits>
   </reg>
 
   <reg protect="rw" name="rx_start_addr">
     <bits access="rw" name="start_addr" pos="31:2" rst="0x3FFFFFFF" display="hex">
       <comment>AHB Start Address.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="rx_end_addr">
     <bits access="rw" name="end_addr"   pos="31:2" rst="0x3FFFFFFF" display="hex">
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="rx_tc_reg">
     <bits access="r" name="tc_reg" pos="21:0" rst="0x3FFFFF" display="hex">
     <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 2^18 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
     </bits>
   </reg>

    <reg protect="rw" name="rx_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits access="rw" name="end_fifo" pos="1" rst="0">
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits access="rw" name="half_tc" pos="2" rst="0">
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>

    <bits access="rw" name="nb_half_tc" pos="3" rst="0">
      <comment>NB Half TC Mask interrupt. only fifo mode is enabled, When one this interrupt is
      enabled</comment>
    </bits>


</reg>

  <reg protect="rw" name="rx_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>

    <bits access="c" name="end_fifo" pos="1" rst="0">
      <comment>Write one to clear end of FIFO interrupt.</comment>
    </bits>

    <bits access="c" name="half_fifo" pos="2" rst="0">
      <comment>Write one to clear end of Half TC interrupt.</comment>
    </bits>

    <bits access="c" name="nb_half_fifo" pos="3" rst="0">
      <comment>Write one to clear end of Half TC (the real one) interrupt.</comment>
    </bits>
</reg>

   <reg protect="r" name="rx_cur_ahb_addr">
     <bits access="r" name="cur_ahb_addr" pos="31:0" rst="0x3ffe000">
       <comment>Current AHB address value.
       </comment>
     </bits>
   </reg>

   
   <reg protect="w" name="tx_control">
     <bits access="w" name="enable_ctrl" pos="0" rst="no">
       <comment>Channel Enable, write one in this bit enable the channel.
       <br />When the channel is enabled, for a peripheral to memory transfer
       the DMA wait request from peripheral to start transfer. </comment>
     </bits>
 
     <bits access="w" name="disable_ctrl" pos="1" rst="no">
       <comment>Channel Disable, write one in this bit disable the channel.
       <br />When writing one in this bit, the current AHB transfer and current
       APB transfer (if one in progress) is completed and the channel is then
       disabled.</comment>
     </bits>

     <bits access="rw" name="burst_size" pos="16" rst="1">
      <comment>Burst size on AHB bus 
        <br />0 = Single access 
        <br />1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits access="rw" name="fifo_mode" pos="17" rst="1">
      <comment>Set FIFO mode . <br />0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br />1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
   </reg>

   <reg protect="r" name="tx_status">
     <bits access="r" name="enable_ctrl" pos="0" rst="0">
       <options>
         <option name="DISABLE" value="0" />
 
         <option name="ENABLE" value="1" />
 
         <default />
       </options>
 
       <comment>In no fifo mode the channel is automatically disabled at the
       end of the transfer. In fifo mode the channel is disabled only when
       disabled write is performed in the control register. </comment>
     </bits>
 
     <bits access="r" name="fifo_empty" pos="1" rst="1">
       <comment>When 1 the fifo is empty </comment>
     </bits>
     
     <bits access="r" name="cause_nb_htc" pos="2" rst="0">
      <comment>Cause interrupt half tc  when fifo mode is enable.</comment>
    </bits>

     <bits access="r" name="nb_htc" pos="3" rst="0">
       <comment> Half of TC interrupt when fifo mode is enable status bit. </comment>
     </bits>

     <bits access="r" name="cause_itc" pos="4" rst="0">
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits access="r" name="cause_ief" pos="5" rst="0">
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits access="r" name="cause_ihtc" pos="6" rst="0">
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>
 
     <bits access="r" name="itc" pos="7" rst="0">
       <comment>End of TC interrupt status bit. </comment>
     </bits>

    <bits access="r" name="ief" pos="8" rst="0">
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits access="r" name="ihtc" pos="9" rst="0">
      <comment>Half TC interrupt status bit.</comment>
    </bits>

     <bits access="r" name="cur_tc" pos="31:10" rst="0x3fffff">
       <comment>Current value of transfer counter.</comment>
     </bits>
   </reg>
 
   <reg protect="rw" name="tx_start_addr">
     <bits access="rw" name="start_addr" pos="31:2" rst="0x3FFFFFFF" display="hex">
       <comment>AHB Start Address.</comment>
     </bits>
   </reg>

   <reg protect="rw" name="tx_end_addr">
     <bits access="rw" name="end_addr"   pos="31:2" rst="0x3FFFFFFF" display="hex">
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
  </reg>


   <reg protect="rw" name="tx_tc_reg">
     <bits access="r" name="tc_reg" pos="21:0" rst="0x3FFFFF" display="hex">
     <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 2^18 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
     </bits>
   </reg>

    <reg protect="rw" name="tx_int_mask">
    <bits access="rw" name="end_tc" pos="0" rst="0">
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits access="rw" name="end_fifo" pos="1" rst="0">
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits access="rw" name="half_tc" pos="2" rst="0">
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>

    <bits access="rw" name="nb_half_tc" pos="3" rst="0">
      <comment>NB Half TC Mask interrupt. only fifo mode is enabled, When one this interrupt is
      enabled</comment>
    </bits>


</reg>

  <reg protect="rw" name="tx_int_clear">
    <bits access="c" name="end_tc" pos="0" rst="0">
      <comment>Write one to clear end of TC interrupt.</comment>
    </bits>

    <bits access="c" name="end_fifo" pos="1" rst="0">
      <comment>Write one to clear end of FIFO interrupt.</comment>
    </bits>

    <bits access="c" name="half_fifo" pos="2" rst="0">
      <comment>Write one to clear end of Half TC interrupt.</comment>
    </bits>

    <bits access="c" name="nb_half_fifo" pos="3" rst="0">
      <comment>Write one to clear end of Half TC (the real one) interrupt.</comment>
    </bits>
</reg>

   <reg protect="r" name="tx_cur_ahb_addr">
     <bits access="r" name="cur_ahb_addr" pos="31:0" rst="0x3ffe000">
       <comment>Current AHB address value.
       </comment>
     </bits>
   </reg>

   
   <reg protect="rw" name="rfif_ctrl">
     <bits access="rw" name="dump_en" pos="0" rst="0x0" display="hex">
       <comment> dump the 'data from dfe to nb core' to mem</comment>
     </bits>
     
     <bits access="rw" name="dump_mode" pos="1" rst="0x0" display="hex">
         <comment> when the bit is 1, dump only when nb-core comes an pulse ,capture the set data numbers ,then stop
                   when the bit is 0, dump all bit normal dump mode </comment>
     </bits>

     <bits access="rw" name="dump_downsample" pos="2" rst="0x0" display="hex">
         <comment> when the bit is 1, downsample enable 
                   when the bit is 0, disable </comment>
     </bits>
 
     <bits access="rw" name="feed_dl" pos="4" rst="0x0" display="hex">
       <comment> get data from mem, simu the data format from dfe to nb core</comment>
     </bits>

     <bits access="rw" name="feed_ul" pos="5" rst="0x0" display="hex">
       <comment> get data from mem, simu the data format from nbcore to dfe</comment>
     </bits>

     <bits access="rw" name="feed_speed_div" pos="23:8" rst="0x20" display="hex">
         <comment> feed data rate  1.92MHz=0x20 192KHz=0x140, 96KHz=0x280, 38.4KHz=0x640, 32KHz=0x780  </comment>
     </bits>

     <bits access="r" name="feed_fifo_empty" pos="24" rst="0x1" display="hex">
       <comment> fifo empty siganl </comment>
     </bits>

     <bits access="r" name="dump_fifo_empty" pos="25" rst="0x1" display="hex">
       <comment> fifo empty signal</comment>
    </bits>

      <bits access="rw" name="feed_fifo_clr" pos="26" rst="0x0" display="hex">
        <comment> clr feed fifo point 
                </comment>
     </bits>

     <bits access="rw" name="dump_fifo_clr" pos="27" rst="0x0" display="hex">
         <comment> clr dump fifo point 
                    </comment>
     </bits>

     <bits access="rw" name="nb_debug" pos="31" rst="0x0" display="hex">
         <comment> when the bit is 1, nb use the rf_dma 
                   when the bit is 0, 2g use the rf_dma </comment>
     </bits>
   </reg>

   <hole size="224"/>
  
   <reg protect="rw" name="nb_if_irsr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl irq </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl irq </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl irq </comment>
     </bits>
 
     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working irq </comment>
     </bits>
 </reg>

   <reg protect="rw" name="nb_if_imr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl mask </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl mask </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl mask </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl mask </comment>
     </bits>

     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working  mask </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working  mask </comment>
     </bits>
 </reg>

   <reg protect="rw" name="nb_if_isr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl  before mask irq source </comment>
     </bits>

     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working irq  source </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working irq source </comment>
     </bits>
 </reg>

   <reg protect="rw" name="nb_if_icr">
     <bits access="rw" name="dump_ovfl" pos="0" rst="0x0" display="hex">
       <comment> dump_ovfl clr irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl" pos="1" rst="0x0" display="hex">
       <comment> dump_udfl clr irq </comment>
     </bits>

     <bits access="rw" name="feed_ovfl" pos="2" rst="0x0" display="hex">
       <comment> feed_ovfl clr irq </comment>
     </bits>

     <bits access="rw" name="feed_udfl" pos="3" rst="0x0" display="hex">
       <comment> feed_udfl clr irq </comment>
     </bits>

     <bits access="rw" name="dump_ovfl_real" pos="4" rst="0x0" display="hex">
       <comment> dump_ovfl  when  ifc is still working clr irq </comment>
     </bits>

     <bits access="rw" name="dump_udfl_real" pos="5" rst="0x0" display="hex">
       <comment> dump_udfl  when  ifc is still working clr irq </comment>
     </bits>
 </reg>

</module>
</archive>
<archive relative = "rf_interface.xml">
  <module name="rf_interface" category="rf_dig">
    <reg protect="r" name="reg_000_bit_ro">
      <bits access="r" name="reg_000_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[0]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_002_bit_ro">
      <bits access="r" name="reg_002_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[1]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_004_bit_ro">
      <bits access="r" name="reg_004_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[2]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_006_bit_ro">
      <bits access="r" name="reg_006_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[3]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_008_bit_ro">
      <bits access="r" name="reg_008_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[8]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_00a_bit_ro">
      <bits access="r" name="reg_00a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[9]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_00c_bit_ro">
      <bits access="r" name="reg_00c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[10]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_00e_bit_ro">
      <bits access="r" name="reg_00e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[11]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_010_bit_ro">
      <bits access="r" name="reg_010_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[12]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_012_bit_ro">
      <bits access="r" name="reg_012_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[13]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_014_bit_ro">
      <bits access="r" name="reg_014_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[14]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_016_bit_ro">
      <bits access="r" name="reg_016_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[15]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_018_bit_ro">
      <bits access="r" name="reg_018_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[16]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_01a_bit_ro">
      <bits access="r" name="reg_01a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[17]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_01c_bit_ro">
      <bits access="r" name="reg_01c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[18]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_01e_bit_ro">
      <bits access="r" name="reg_01e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[19]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_020_bit_ro">
      <bits access="r" name="reg_020_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[20]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_022_bit_ro">
      <bits access="r" name="reg_022_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[21]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_024_bit_ro">
      <bits access="r" name="reg_024_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[22]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_026_bit_ro">
      <bits access="r" name="reg_026_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI. write this register will generate irq[23]
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_028_bit_ro">
      <bits access="r" name="reg_028_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_02a_bit_ro">
      <bits access="r" name="reg_02a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_02c_bit_ro">
      <bits access="r" name="reg_02c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_02e_bit_ro">
      <bits access="r" name="reg_02e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <hole size="768"/>
    <reg protect="r" name="reg_sys_ctrl_bit_ro">
      <bits access="r" name="reg_sys_ctrl_bit" pos="15:0" rst="16641">
        <comment>
          reset register. read only by RISCV, write and read by SPI. bit [0] is used to reset SPI register logics, other bits are no use
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_page_bit_ro">
      <bits access="r" name="reg_page_bit" pos="15:0" rst="6">
        <comment>
          page read register. read only by RISCV and SPI. page is wrote by SPI at address 0x7fff
        </comment>
      </bits>
    </reg>
    <hole size="448"/>
    <reg protect="r" name="reg_100_bit_ro">
      <bits access="r" name="reg_100_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_102_bit_ro">
      <bits access="r" name="reg_102_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_104_bit_ro">
      <bits access="r" name="reg_104_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_106_bit_ro">
      <bits access="r" name="reg_106_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_108_bit_ro">
      <bits access="r" name="reg_108_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_10a_bit_ro">
      <bits access="r" name="reg_10a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_10c_bit_ro">
      <bits access="r" name="reg_10c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_10e_bit_ro">
      <bits access="r" name="reg_10e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_110_bit_ro">
      <bits access="r" name="reg_110_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_112_bit_ro">
      <bits access="r" name="reg_112_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_114_bit_ro">
      <bits access="r" name="reg_114_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_116_bit_ro">
      <bits access="r" name="reg_116_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_118_bit_ro">
      <bits access="r" name="reg_118_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_11a_bit_ro">
      <bits access="r" name="reg_11a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_11c_bit_ro">
      <bits access="r" name="reg_11c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_11e_bit_ro">
      <bits access="r" name="reg_11e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_120_bit_ro">
      <bits access="r" name="reg_120_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_122_bit_ro">
      <bits access="r" name="reg_122_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_124_bit_ro">
      <bits access="r" name="reg_124_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_126_bit_ro">
      <bits access="r" name="reg_126_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_128_bit_ro">
      <bits access="r" name="reg_128_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_12a_bit_ro">
      <bits access="r" name="reg_12a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_12c_bit_ro">
      <bits access="r" name="reg_12c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_12e_bit_ro">
      <bits access="r" name="reg_12e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_130_bit_ro">
      <bits access="r" name="reg_130_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_132_bit_ro">
      <bits access="r" name="reg_132_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_134_bit_ro">
      <bits access="r" name="reg_134_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_136_bit_ro">
      <bits access="r" name="reg_136_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_138_bit_ro">
      <bits access="r" name="reg_138_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_13a_bit_ro">
      <bits access="r" name="reg_13a_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_13c_bit_ro">
      <bits access="r" name="reg_13c_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_13e_bit_ro">
      <bits access="r" name="reg_13e_bit" pos="15:0" rst="0">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_140_bit_ro">
      <bits access="r" name="reg_140_bit" pos="15:0" rst="32768">
        <comment>
          data register. read only by RISCV, write and read by SPI.
        </comment>
      </bits>
    </reg>
    <hole size="992"/>
    <reg protect="rw" name="int_clear0">
      <bits access="rw" name="int_ctrl_bit_0" pos="15:0" rst="0">
        <comment>
          irq clear bit [15:0], [7:4] is no use
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="int_clear1">
      <bits access="rw" name="int_ctrl_bit_1" pos="15:0" rst="0">
        <comment>
          irq clear bit [31:16], [31:24] is no use
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="int2mcu0">
      <bits access="r" name="irq0" pos="15:0" rst="0">
        <comment>
          read only irq[15:0].
[0]:   interrupt 0 of spi write, which assert high when spi address is 15'h0000 and page address is 5'b00110
[1]:   interrupt 1 of spi write, which assert high when spi address is 15'h0004 and page address is 5'b00110
[2]:   interrupt 2 of spi write, which assert high when spi address is 15'h0008 and page address is 5'b00110
[3]:   interrupt 3 of spi write, which assert high when spi address is 15'h000c and page address is 5'b00110
[4]:   interrupt of timer 0
[5]:   interrupt of timer 1
[6]:   interrupt of timer 2
[7]:   interrupt of DFE
[8]:   interrupt 4 of spi write, which assert high when spi address is 15'h0010 and page address is 5'b00110
[9]:   interrupt 5 of spi write, which assert high when spi address is 15'h0014 and page address is 5'b00110
[10]: interrupt 6 of spi write, which assert high when spi address is 15'h0018 and page address is 5'b00110
[11]: interrupt 7 of spi write, which assert high when spi address is 15'h001c and page address is 5'b00110
[12]: interrupt 8 of spi write, which assert high when spi address is 15'h0020 and page address is 5'b00110
[13]: interrupt 9 of spi write, which assert high when spi address is 15'h0024 and page address is 5'b00110
[14]: interrupt 10 of spi write, which assert high when spi address is 15'h0028 and page address is 5'b00110
[15]: interrupt 11 of spi write, which assert high when spi address is 15'h002c and page address is 5'b00110
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="int2mcu1">
      <bits access="r" name="irq1" pos="15:0" rst="0">
        <comment>
          read only irq[31:16].
[0]:   interrupt 12 of spi write, which assert high when spi address is 15'h0030 and page address is 5'b00110
[1]:   interrupt 13 of spi write, which assert high when spi address is 15'h0034 and page address is 5'b00110
[2]:   interrupt 14 of spi write, which assert high when spi address is 15'h0038 and page address is 5'b00110
[3]:   interrupt 15 of spi write, which assert high when spi address is 15'h003c and page address is 5'b00110
[4]:   interrupt 16 of spi write, which assert high when spi address is 15'h0040 and page address is 5'b00110
[5]:   interrupt 17 of spi write, which assert high when spi address is 15'h0044 and page address is 5'b00110
[6]:   interrupt 18 of spi write, which assert high when spi address is 15'h0048 and page address is 5'b00110
[7]:   interrupt 19 of spi write, which assert high when spi address is 15'h004c and page address is 5'b00110
[8]:   interrupt of mailbox 0
[9]:   interrupt of mailbox 1
[10]: interrupt of watch dog
[11]: interrupt of uart
[12]: interrupt which assert by signal dfe_rx_enable
[13]: interrupt which assert by signal gsm_digrf_tx_strobe
[14]: interrupt which assert by signal npll_pu_in
[15]: interrupt which assert by signal gpll_pu_in
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reset_ctrl_reg">
      <bits access="r" name="reset_ctrl_reg_reserved_0" pos="15:2" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="resetn_spi_reg" pos="1" rst="1">
        <comment>
          SPI registers reset, active low
        </comment>
      </bits>
      <bits access="rw" name="resetn_int_reg" pos="0" rst="1">
        <comment>
          Interface reset except APB and SPI registers, active low
        </comment>
      </bits>
    </reg>
    <hole size="1408"/>
    <reg protect="rw" name="xcvsdm_reg0">
      <bits access="rw" name="freq_xcvsdm0" pos="15:0" rst="0">
        <comment>
          bit [15:0] of RFPLL SDM frequency for GSM RX and NB RX/TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg1">
      <bits access="rw" name="freq_xcvsdm1" pos="15:0" rst="0">
        <comment>
          bit [31:16] of RFPLL SDM frequency for GSM RX and NB RX/TX
        </comment>
      </bits>
    </reg>
    <hole size="32"/>
    <reg protect="rw" name="xcvsdm_reg2">
      <bits access="r" name="xcvsdm_reg2_reserved_0" pos="15:3" rst="0">
      </bits>
      <bits access="rw" name="freq_xcvsdm2" pos="2:0" rst="0">
        <comment>
          bit [34:32] of RFPLL SDM frequency for GSM RX and NB RX/TX
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_freq_enable">
      <bits access="r" name="reg_freq_enable_reserved_0" pos="15:1" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_enable" pos="0" rst="0">
        <comment>
          load SDM frequency of all PLLs(RFPLL, GPLL, NPLL) to RTL at the same time, write 0 before assert it
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="xcvsdm_reg3">
      <bits access="r" name="xcvsdm_reg3_reserved_0" pos="15:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_bypass_xcvsdm" pos="4" rst="0">
        <comment>
          bypass freq_enable, i.e., SDM frequency of RFPLL takes effect immidiately when it is loaded into regsiter
        </comment>
      </bits>
      <bits access="rw" name="dither_bypass_xcvsdm" pos="3" rst="0">
        <comment>
          sdm rfpll dither_bypass_xcvsdm
        </comment>
      </bits>
      <bits access="rw" name="dll_mode_xcvsdm" pos="2:0" rst="1">
        <comment>
          dividing ratio of RFPLL feedback clock to generate 26MHz clock used by GSM TX logic of DFE:
0b000: 182M divided by 7
0b001: 208M divided by 8
0b010: 234M divided by 9
0b011: 260M divided by 10
0b100: 26M with no division
0b101: 52M divided by 2
others: 208M divided by 8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="xcvsdm_reg4">
      <bits access="r" name="xcvsdm_reg4_reserved_0" pos="15:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="tx_rx_sel_xcvsdm" pos="5" rst="0">
        <comment>
          select for TX using RFPLL SDM:
0b0: GSM RX or NB RX or NB TX without PolarIQ. SDM frequency is from registers that are xcvsdm_reg2/1/0
0b1: GSM TX or NB TX with PolarIQ. SDM frequency is from DFE GSM former and PolarIQ split
        </comment>
      </bits>
      <bits access="rw" name="resetn_xcvsdm" pos="4" rst="0">
        <comment>
          reset of RFPLL SDM, active low
        </comment>
      </bits>
      <bits access="rw" name="int_dec_sel_xcvsdm" pos="3:1" rst="2">
        <comment>
          decimal bit width selection of RFPLL SDM output. It should be fixed to 3'h2 in 8809nez.
0b000: int divide
0b001: 1 bit decimal divide
0b010: 2 bits decimal divide
0b011: 3 bit decimal divide
others: bypass SDM
        </comment>
      </bits>
      <bits access="rw" name="fbc_inv_xcvsdm" pos="0" rst="0">
        <comment>
          feedback clock inverse used by RFPLL SDM
0b0: no inverse
0b1: inverse
        </comment>
      </bits>
    </reg>
    <hole size="192"/>
    <reg protect="rw" name="bbpll1_reg1">
      <bits access="r" name="bbpll1_reg1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_cp_rbit" pos="13:11" rst="4">
        <comment>
          NPLL pll_cpbias_rbit
        </comment>
      </bits>
      <bits access="rw" name="npll_cp_bit" pos="10:7" rst="1">
        <comment>
          NPLL pll_cpbias_ibit
        </comment>
      </bits>
      <bits access="rw" name="npll_cpc2_bit" pos="6:4" rst="4">
        <comment>
          NPLL pll_cpc2_bit
        </comment>
      </bits>
      <bits access="rw" name="npll_digreg_range" pos="3:0" rst="8">
        <comment>
          NPLL digreg_range
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg2">
      <bits access="r" name="bbpll1_reg2_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_band_sel" pos="13:12" rst="0">
        <comment>
          NPLL band_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_testsig_sel" pos="11:10" rst="0">
        <comment>
          NPLL testsig_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_pcon_mode" pos="9" rst="0">
        <comment>
          NPLL pcom_mode
        </comment>
      </bits>
      <bits access="rw" name="npll_refmulti2_en" pos="8" rst="1">
        <comment>
          NPLL refmulti2_en
        </comment>
      </bits>
      <bits access="rw" name="npll_vco_high_test" pos="7" rst="0">
        <comment>
          NPLL vco_high_test
        </comment>
      </bits>
      <bits access="rw" name="npll_vco_low_test" pos="6" rst="0">
        <comment>
          NPLL vco_low_test
        </comment>
      </bits>
      <bits access="rw" name="npll_int_mode" pos="5" rst="0">
        <comment>
          NPLL int_mode
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_clk_test_en" pos="4" rst="0">
        <comment>
          NPLL sdm_clk_test_en
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_dr1" pos="3" rst="0">
        <comment>
          direct conrol of analog pu_npll
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_reg1" pos="2" rst="0">
        <comment>
          value of analog pu_npll. It takes affect when pu_npll_dr1 is 0b1
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_dr" pos="1" rst="0">
        <comment>
          direct conrol of baseband pu_npll
        </comment>
      </bits>
      <bits access="rw" name="pu_npll_reg" pos="0" rst="0">
        <comment>
          value of baseband pu_npll. It takes affect when pu_npll_dr is 0b1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg3">
      <bits access="r" name="bbpll1_reg3_reserved_0" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_cpr2_bit" pos="10:8" rst="4">
        <comment>
          NPLL pll_cpr2_bit
        </comment>
      </bits>
      <bits access="rw" name="npll_reser_reg" pos="7:0" rst="1">
        <comment>
          NPLL pll_reserved_reg
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg5">
      <bits access="rw" name="npll_sdm_freq1" pos="15:0" rst="24576">
        <comment>
          bit [31:16] of NPLL SDM frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg6">
      <bits access="rw" name="npll_sdm_freq0" pos="15:0" rst="0">
        <comment>
          bit [15:0] of NPLL SDM frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_reg7">
      <bits access="r" name="bbpll1_reg7_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_freq_bypass" pos="7" rst="0">
        <comment>
          bypass freq_enable, i.e., SDM frequency of NPLL takes effect immidiately when it is loaded into regsiter
0b0: no bypass
0b1: bypass
        </comment>
      </bits>
      <bits access="rw" name="npll_int_dec_sel" pos="6:4" rst="3">
        <comment>
          decimal bit width selection of NPLL SDM output. It should be fixed to 3'b011 in 8809nez.
0b000: int divide
0b001: 1 bit decimal divide
0b010: 2 bits decimal divide
0b011: 3 bit decimal divide
others: bypass SDM
        </comment>
      </bits>
      <bits access="rw" name="npll_dither_bypass" pos="3" rst="1">
        <comment>
          dither bypass of NPLL SDM
0b0: no bypass
0b1: bypass
        </comment>
      </bits>
      <bits access="rw" name="npll_fbc_inv" pos="2" rst="0">
        <comment>
          feedback clock inverse used by NPLL SDM
0b0: no inverse
0b1: inverse
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_resetn_dr" pos="1" rst="0">
        <comment>
          direct conrol of NPLL SDM reset
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_resetn_reg" pos="0" rst="0">
        <comment>
          reset of NPLL SDM, active low. It takes affect when npll_sdm_resetn_dr is 0b1
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="bbpll1_rega">
      <bits access="rw" name="npll_sdm_reset_time_sel" pos="15:14" rst="1">
        <comment>
          the time to release reset of NPLL SDM after pu_npll assert.
0b00: 10us
0b01: 12us
0b10: 15us
0b11: 40us
        </comment>
      </bits>
      <bits access="rw" name="npll_sdmclk_sel_time_sel" pos="13:12" rst="1">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="r" name="bbpll1_rega_reserved_0" pos="11:5" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_sel_reg" pos="4" rst="1">
        <comment>
          select of 30.72MHz clock of NPLL to ADC
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_en_reg" pos="3" rst="1">
        <comment>
          enable of 30.72MHz clock of NPLL to ADC
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_en_reg" pos="2" rst="1">
        <comment>
          enable of 61.44MHz clock of NPLL to DFE
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_sel_reg" pos="1" rst="1">
        <comment>
          select of 61.44MHz clock of NPLL to DFE
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_gen_en_reg" pos="0" rst="1">
        <comment>
          enable pu_npll from baseband
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="bbpll1_regb">
      <bits access="r" name="npll_pu" pos="15" rst="0">
        <comment>
          NPLL pu status
        </comment>
      </bits>
      <bits access="r" name="npll_lock" pos="14" rst="0">
        <comment>
          NPLL lock status
        </comment>
      </bits>
      <bits access="r" name="npll_sdm_resetn" pos="13" rst="0">
        <comment>
          NPLL SDM reset status
        </comment>
      </bits>
      <bits access="r" name="npll_sdm_clk_sel" pos="12" rst="0">
        <comment>
          NPLL sdm_clk_sel status
        </comment>
      </bits>
      <bits access="r" name="npll_clk_ready" pos="11" rst="0">
        <comment>
          NPLL clock status
        </comment>
      </bits>
      <bits access="r" name="npll_lock_steady" pos="10" rst="0">
        <comment>
          NPLL locked status
        </comment>
      </bits>
      <bits access="r" name="bbpll1_regb_reserved_0" pos="9:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_regd">
      <bits access="r" name="bbpll1_regd_reserved_0" pos="15:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="resetn_npll" pos="5" rst="1">
        <comment>
          software reset of logics to control NPLL pu and pd, active low
        </comment>
      </bits>
      <bits access="rw" name="npll_clkout_en_counter_sel" pos="4:2" rst="2">
        <comment>
          the time to open NPLL clocks after pu_npll assert.
0b000: 10us+50us+1us
0b000: 10us+60us+1us
0b000: 10us+70us+1us
0b000: 10us+80us+1us
0b000: 10us+90us+1us
0b000: 10us+100us+1us
        </comment>
      </bits>
      <bits access="rw" name="npll_lock_counter_sel" pos="1:0" rst="1">
        <comment>
          NPLL locked time.
0b00: 1us
0b01: 2us
0b10: 3us
0b11: 4us
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll1_regf">
      <bits access="r" name="bbpll1_regf_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_en_drreg" pos="11" rst="0">
        <comment>
          direct value of npll_clk2dig_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_en_drreg" pos="10" rst="0">
        <comment>
          direct value of npll_clk_adc_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_sel_drreg" pos="9" rst="0">
        <comment>
          direct value of npll_clk2dig_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_sel_drreg" pos="8" rst="0">
        <comment>
          direct value of npll_clk_adc_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_en_dr" pos="7" rst="0">
        <comment>
          direct control of npll_clk2dig_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_en_dr" pos="6" rst="0">
        <comment>
          direct control of npll_clk_adc_en
        </comment>
      </bits>
      <bits access="rw" name="npll_clk2dig_sel_dr" pos="5" rst="0">
        <comment>
          direct control of npll_clk2dig_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_adc_sel_dr" pos="4" rst="0">
        <comment>
          direct control of npll_clk_adc_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_rstb_reg" pos="3" rst="0">
        <comment>
          direct value of npll_clk_rstb
        </comment>
      </bits>
      <bits access="rw" name="npll_clk_rstb_dr" pos="2" rst="0">
        <comment>
          direct control of npll_clk_rstb
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_clk_sel_reg" pos="1" rst="0">
        <comment>
          direct value of npll_sdm_clk_sel
        </comment>
      </bits>
      <bits access="rw" name="npll_sdm_clk_sel_dr" pos="0" rst="0">
        <comment>
          direct control of npll_sdm_clk_sel
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_reg1">
      <bits access="r" name="bbpll2_reg1_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpll_cp_rbit" pos="13:11" rst="4">
        <comment>
          GPLL pll_cpbias_rbit
        </comment>
      </bits>
      <bits access="rw" name="gpll_cp_ibit" pos="10:7" rst="1">
        <comment>
          GPLL pll_cpbias_ibit
        </comment>
      </bits>
      <bits access="rw" name="gpll_cpc2_bit" pos="6:4" rst="4">
        <comment>
          GPLL pll_cpc2_bit
        </comment>
      </bits>
      <bits access="rw" name="gpll_digreg_range" pos="3:0" rst="8">
        <comment>
          GPLL digreg_range
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_reg2">
      <bits access="r" name="bbpll2_reg2_reserved_0" pos="15:14" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpll_band_sel" pos="13:12" rst="0">
        <comment>
          GPLL band_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_testsig_sel" pos="11:10" rst="0">
        <comment>
          GPLL testsig_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_pcon_mode" pos="9" rst="0">
        <comment>
          GPLL pcom_mode
        </comment>
      </bits>
      <bits access="rw" name="gpll_refmulti2_en" pos="8" rst="1">
        <comment>
          GPLL refmulti2_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_vco_high_test" pos="7" rst="0">
        <comment>
          GPLL vco_high_test
        </comment>
      </bits>
      <bits access="rw" name="gpll_vco_low_test" pos="6" rst="0">
        <comment>
          GPLL vco_low_test
        </comment>
      </bits>
      <bits access="rw" name="gpll_int_mode" pos="5" rst="0">
        <comment>
          GPLL int_mode
        </comment>
      </bits>
      <bits access="rw" name="gpll_sdm_clk_test_en" pos="4" rst="0">
        <comment>
          GPLL sdm_clk_test_en
        </comment>
      </bits>
      <bits access="rw" name="pu_gpll_dr1" pos="3" rst="0">
        <comment>
          direct conrol of analog pu_gpll
        </comment>
      </bits>
      <bits access="rw" name="pu_gpll_reg1" pos="2" rst="0">
        <comment>
          value of analog pu_gpll. It takes affect when pu_gpll_dr1 is 0b1
        </comment>
      </bits>
      <bits access="rw" name="pu_gpll_dr" pos="1" rst="0">
        <comment>
          direct conrol of baseband pu_gpll
        </comment>
      </bits>
      <bits access="rw" name="pu_gpll_reg" pos="0" rst="0">
        <comment>
          value of baseband pu_gpll. It takes affect when pu_gpll_dr is 0b1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_reg3">
      <bits access="r" name="bbpll2_reg3_reserved_0" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpll_cpr2_bit" pos="10:8" rst="4">
        <comment>
          NPLL pll_cpr2_bit
        </comment>
      </bits>
      <bits access="rw" name="gpll_reser_reg" pos="7:0" rst="1">
        <comment>
          NPLL pll_reserved_reg
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_reg5">
      <bits access="rw" name="gpll_sdm_freq1" pos="15:0" rst="6144">
        <comment>
          bit [31:16] of GPLL SDM frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_reg6">
      <bits access="rw" name="gpll_sdm_freq0" pos="15:0" rst="0">
        <comment>
          bit [15:0] of GPLL SDM frequency
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_reg7">
      <bits access="r" name="bbpll2_reg7_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpll_freq_bypass" pos="7" rst="0">
        <comment>
          bypass freq_enable, i.e., SDM frequency of GPLL takes effect immidiately when it is loaded into regsiter
0b0: no bypass
0b1: bypass
        </comment>
      </bits>
      <bits access="rw" name="gpll_int_dec_sel" pos="6:4" rst="3">
        <comment>
          decimal bit width selection of GPLL SDM output. It should be fixed to 3'b011 in 8809nez.
0b000: int divide
0b001: 1 bit decimal divide
0b010: 2 bits decimal divide
0b011: 3 bit decimal divide
others: bypass SDM
        </comment>
      </bits>
      <bits access="rw" name="gpll_dither_bypass" pos="3" rst="1">
        <comment>
          dither bypass of GPLL SDM
0b0: no bypass
0b1: bypass
        </comment>
      </bits>
      <bits access="rw" name="gpll_fbc_inv" pos="2" rst="0">
        <comment>
          feedback clock inverse used by GPLL SDM
0b0: no inverse
0b1: inverse
        </comment>
      </bits>
      <bits access="rw" name="gpll_sdm_resetn_dr" pos="1" rst="0">
        <comment>
          direct conrol of GPLL SDM reset
        </comment>
      </bits>
      <bits access="rw" name="gpll_sdm_resetn_reg" pos="0" rst="0">
        <comment>
          reset of GPLL SDM, active low. It takes affect when gpll_sdm_resetn_dr is 0b1
        </comment>
      </bits>
    </reg>
    <hole size="64"/>
    <reg protect="rw" name="bbpll2_rega">
      <bits access="rw" name="gpll_sdm_reset_time_sel" pos="15:14" rst="1">
        <comment>
          the time to release reset of GPLL SDM after pu_gpll assert.
0b00: 10us
0b01: 12us
0b10: 15us
0b11: 40us
        </comment>
      </bits>
      <bits access="rw" name="gpll_sdmclk_sel_time_sel" pos="13:12" rst="1">
        <comment>
          no use
        </comment>
      </bits>
      <bits access="r" name="bbpll2_rega_reserved_0" pos="11:7" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_624m_en_reg" pos="6" rst="0">
        <comment>
          enable of 624MHz clock of GPLL to baseband
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_624m_sel_reg" pos="5" rst="0">
        <comment>
          select of 624MHz clock of GPLL to baseband
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_adc_sel_reg" pos="4" rst="1">
        <comment>
          select of 26MHz clock of GPLL to ADC
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_adc_en_reg" pos="3" rst="1">
        <comment>
          enable of 26MHz clock of GPLL to ADC
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_26m_en_reg" pos="2" rst="1">
        <comment>
          enable of 26MHz clock of GPLL to DFE
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_26m_sel_reg" pos="1" rst="1">
        <comment>
          select of 26MHz clock of GPLL to DFE
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_gen_en_reg" pos="0" rst="1">
        <comment>
          enable pu_gpll from baseband
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="bbpll2_regb">
      <bits access="r" name="gpll_pu" pos="15" rst="0">
        <comment>
          GPLL pu status
        </comment>
      </bits>
      <bits access="r" name="gpll_lock" pos="14" rst="0">
        <comment>
          GPLL lock status
        </comment>
      </bits>
      <bits access="r" name="gpll_sdm_resetn" pos="13" rst="0">
        <comment>
          GPLL SDM reset status
        </comment>
      </bits>
      <bits access="r" name="gpll_sdm_clk_sel" pos="12" rst="0">
        <comment>
          GPLL sdm_clk_sel status
        </comment>
      </bits>
      <bits access="r" name="gpll_clk_ready" pos="11" rst="0">
        <comment>
          GPLL clock status
        </comment>
      </bits>
      <bits access="r" name="gpll_lock_steady" pos="10" rst="0">
        <comment>
          GPLL locked status
        </comment>
      </bits>
      <bits access="r" name="bbpll2_regb_reserved_0" pos="9:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_regd">
      <bits access="r" name="bbpll2_regd_reserved_0" pos="15:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="resetn_gpll" pos="5" rst="1">
        <comment>
          software reset of logics to control GPLL pu and pd, active low
        </comment>
      </bits>
      <bits access="rw" name="gpll_clkout_en_counter_sel" pos="4:2" rst="2">
        <comment>
          the time to open GPLL clocks after pu_gpll assert.
0b000: 10us+50us+1us
0b000: 10us+60us+1us
0b000: 10us+70us+1us
0b000: 10us+80us+1us
0b000: 10us+90us+1us
0b000: 10us+100us+1us
        </comment>
      </bits>
      <bits access="rw" name="gpll_lock_counter_sel" pos="1:0" rst="1">
        <comment>
          GPLL locked time.
0b00: 1us
0b01: 2us
0b10: 3us
0b11: 4us
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bbpll2_regf">
      <bits access="rw" name="gpll_clk2dig_624m_en_drreg" pos="15" rst="0">
        <comment>
          direct value of gpll_clk2dig_624m_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_624m_sel_drreg" pos="14" rst="0">
        <comment>
          direct value of gpll_clk2dig_624m_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_624m_en_dr" pos="13" rst="0">
        <comment>
          direct control of gpll_clk2dig_624m_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_624m_sel_dr" pos="12" rst="0">
        <comment>
          direct control of gpll_clk2dig_624m_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_26m_en_drreg" pos="11" rst="0">
        <comment>
          direct value of gpll_clk2dig_26m_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_adc_en_drreg" pos="10" rst="0">
        <comment>
          direct value of gpll_clk_adc_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_26m_sel_drreg" pos="9" rst="0">
        <comment>
          direct value of gpll_clk2dig_26m_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_adc_sel_drreg" pos="8" rst="0">
        <comment>
          direct value of gpll_clk_adc_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_26m_en_dr" pos="7" rst="0">
        <comment>
          direct control of gpll_clk2dig_26m_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_adc_en_dr" pos="6" rst="0">
        <comment>
          direct control of gpll_clk_adc_en
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk2dig_26m_sel_dr" pos="5" rst="0">
        <comment>
          direct control of gpll_clk2dig_26m_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_adc_sel_dr" pos="4" rst="0">
        <comment>
          direct control of gpll_clk_adc_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_rstb_reg" pos="3" rst="0">
        <comment>
          direct value of gpll_clk_rstb
        </comment>
      </bits>
      <bits access="rw" name="gpll_clk_rstb_dr" pos="2" rst="0">
        <comment>
          direct control of gpll_clk_rstb
        </comment>
      </bits>
      <bits access="rw" name="gpll_sdm_clk_sel_dr" pos="1" rst="0">
        <comment>
          direct control of gpll_sdm_clk_sel
        </comment>
      </bits>
      <bits access="rw" name="gpll_sdm_clk_sel_reg" pos="0" rst="0">
        <comment>
          direct value of gpll_sdm_clk_sel
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_reg1">
      <bits access="rw" name="reg_90_bit1" pos="15:8" rst="0">
        <comment>
          rfpll_cal: target freq[15:8]
        </comment>
      </bits>
      <bits access="rw" name="reg_90_bit0" pos="7:0" rst="0">
        <comment>
          rfpll_cal: target freq[7:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_reg2">
      <bits access="rw" name="reg_91_bit15to8" pos="15:8" rst="0">
        <comment>
          rfpll_cal:
[12:8]: xcvpll_vco_bits[12:8] in software
[13]: reserved
[14]: xcvpll_cnt_enable in software
[15]: xcvpll_cal_enable in software
        </comment>
      </bits>
      <bits access="rw" name="reg_91_bit70" pos="7" rst="0">
        <comment>
          rfpll_cal: reset, active low
        </comment>
      </bits>
      <bits access="rw" name="reg_91_bit6to0" pos="6:0" rst="0">
        <comment>
          rfpll_cal:
[0]: pll_cal_hd, select haredare(1) or software(0)
[1]: xcvpll_cal_opt  
[3:2]: xcvpll_cnt_delay_sel 
[6:4]: xcvpll_init_delay
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_reg3">
      <bits access="rw" name="reg_92_bit1" pos="15:8" rst="0">
        <comment>
          rfpll_cal: reserved
        </comment>
      </bits>
      <bits access="rw" name="reg_92_bit0" pos="7:0" rst="0">
        <comment>
          rfpll_cal: xcvpll_vco_bits[7:0] in software
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="rfpll_cal_reg4">
      <bits access="r" name="xcvpll_cal_enable" pos="15" rst="0">
        <comment>
          rfpll_cal xcv_pll_cal_en
        </comment>
      </bits>
      <bits access="r" name="xcvpll_cnt_enable" pos="14" rst="0">
        <comment>
          rfpll_cal xcv_pll_cnt_en
        </comment>
      </bits>
      <bits access="r" name="xcvpll_cal_ready" pos="13" rst="0">
        <comment>
          rfpll_cal xcvpll_cal_ready
        </comment>
      </bits>
      <bits access="r" name="xcvpll_vco_bits" pos="12:0" rst="0">
        <comment>
          rfpll_cal xcvpll_vco_bits
        </comment>
      </bits>
    </reg>
    <hole size="128"/>
    <reg protect="rw" name="gpio_reg">
      <bits access="rw" name="gpio_reg_out" pos="15:0" rst="0">
        <comment>
          no use
        </comment>
      </bits>
    </reg>
    <hole size="480"/>
    <reg protect="rw" name="pa_strobe">
      <bits access="r" name="pa_strobe_reserved_0" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="strobe_dr" pos="14" rst="0">
        <comment>
          direct control of strobe.
0b0: strobe from baseband
0b1: strobe from register srobe_reg
        </comment>
      </bits>
      <bits access="rw" name="multi_slot_sel" pos="13:12" rst="0">
        <comment>
          multiple slots control.
0b00: 1 slot
0b01: 2 slots
0b10: 3 slots
0b11: 4 slots
        </comment>
      </bits>
      <bits access="rw" name="strobe_reg" pos="11" rst="0">
        <comment>
          direct value of strobe
        </comment>
      </bits>
      <bits access="rw" name="slot_number_dr" pos="10" rst="0">
        <comment>
          direct control of slot number
        </comment>
      </bits>
      <bits access="rw" name="slot_number_reg" pos="9:8" rst="0">
        <comment>
          direct value of slot number
        </comment>
      </bits>
      <bits access="rw" name="time_sel_after_rampd" pos="7:0" rst="0">
        <comment>
          counter after rampdown
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ctrl_reg1">
      <bits access="rw" name="ramp_curve_sel_3" pos="15:12" rst="0">
        <comment>
          seletction of PA ramp curve for the 4th slot
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_sel_2" pos="11:8" rst="0">
        <comment>
          seletction of PA ramp curve for the 3rd slot
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_sel_1" pos="7:4" rst="0">
        <comment>
          seletction of PA ramp curve for the 2nd slot
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_sel_0" pos="3:0" rst="0">
        <comment>
          seletction of PA ramp curve for the 1st slot
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ctrl_reg2">
      <bits access="rw" name="ramp_mult_factor_1" pos="15:8" rst="0">
        <comment>
          multiply factor of PA ramp curve for the 2nd slot
        </comment>
      </bits>
      <bits access="rw" name="ramp_mult_factor_0" pos="7:0" rst="0">
        <comment>
          multiply factor of PA ramp curve for the 1st slot
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ctrl_reg3">
      <bits access="rw" name="ramp_mult_factor_3" pos="15:8" rst="0">
        <comment>
          multiply factor of PA ramp curve for the 4th slot
        </comment>
      </bits>
      <bits access="rw" name="ramp_mult_factor_2" pos="7:0" rst="0">
        <comment>
          multiply factor of PA ramp curve for the 3rd slot
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ctrl_reg4">
      <bits access="r" name="pa_ctrl_reg4_reserved_0" pos="15:11" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="ramp_dac_din_reg" pos="10:1" rst="0">
        <comment>
          direct value of ramp_dac
        </comment>
      </bits>
      <bits access="rw" name="ramp_dac_din_dr" pos="0" rst="0">
        <comment>
          direct control of ramp_dac
        </comment>
      </bits>
    </reg>
    <hole size="352"/>
    <reg protect="rw" name="reg_100_bit">
      <bits access="rw" name="pu_lna" pos="15" rst="0">
        <comment>
          pu_lna
        </comment>
      </bits>
      <bits access="rw" name="pu_powdet_hb" pos="14" rst="0">
        <comment>
          pu_powdet_hb
        </comment>
      </bits>
      <bits access="rw" name="pu_powdet_lb" pos="13" rst="0">
        <comment>
          pu_powdet_lb
        </comment>
      </bits>
      <bits access="rw" name="pu_rmx" pos="12" rst="0">
        <comment>
          pu_rmx
        </comment>
      </bits>
      <bits access="rw" name="pu_pga" pos="11" rst="0">
        <comment>
          pu_pga
        </comment>
      </bits>
      <bits access="rw" name="pu_rxflt" pos="10" rst="0">
        <comment>
          pu_rxflt
        </comment>
      </bits>
      <bits access="rw" name="pu_adc" pos="9" rst="0">
        <comment>
          pu_adc
        </comment>
      </bits>
      <bits access="rw" name="pu_dac" pos="8" rst="0">
        <comment>
          pu_dac
        </comment>
      </bits>
      <bits access="rw" name="pu_txflt" pos="7" rst="0">
        <comment>
          pu_txflt
        </comment>
      </bits>
      <bits access="rw" name="pu_tmx" pos="6" rst="0">
        <comment>
          pu_tmx
        </comment>
      </bits>
      <bits access="rw" name="pu_ramp_dac" pos="5" rst="0">
        <comment>
          pu_ramp_dac
        </comment>
      </bits>
      <bits access="rw" name="pu_padrv" pos="4" rst="0">
        <comment>
          pu_padrv
        </comment>
      </bits>
      <bits access="rw" name="tx_powdet_en" pos="3" rst="0">
        <comment>
          tx_powdet_en
        </comment>
      </bits>
      <bits access="rw" name="pu_gsm_padrv" pos="2" rst="0">
        <comment>
          pu_gsm_padrv
        </comment>
      </bits>
      <bits access="rw" name="pu_vco" pos="1" rst="0">
        <comment>
          pu_vco
        </comment>
      </bits>
      <bits access="rw" name="pu_pll_presc" pos="0" rst="0">
        <comment>
          pu_pll_presc
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_101_bit">
      <bits access="rw" name="pu_pll_peri" pos="15" rst="0">
        <comment>
          pu_pll_peri
        </comment>
      </bits>
      <bits access="rw" name="pu_mdll" pos="14" rst="0">
        <comment>
          pu_mdll
        </comment>
      </bits>
      <bits access="rw" name="pu_ts" pos="13" rst="0">
        <comment>
          pu_ts
        </comment>
      </bits>
      <bits access="rw" name="pu_bg" pos="12" rst="0">
        <comment>
          pu_bg
        </comment>
      </bits>
      <bits access="rw" name="vco_rxcap_short" pos="11" rst="1">
        <comment>
          vco_rxcap_short
        </comment>
      </bits>
      <bits access="rw" name="vco_txcap_short" pos="10" rst="1">
        <comment>
          vco_txcap_short
        </comment>
      </bits>
      <bits access="rw" name="vco_sel_nb" pos="9" rst="0">
        <comment>
          vco_sel_nb
        </comment>
      </bits>
      <bits access="rw" name="vco_sel_trx" pos="8" rst="0">
        <comment>
          vco_sel_trx
        </comment>
      </bits>
      <bits access="rw" name="sel_bg" pos="7" rst="1">
        <comment>
          sel_bg
        </comment>
      </bits>
      <bits access="rw" name="ivref_bit" pos="6" rst="1">
        <comment>
          ivref_bit
        </comment>
      </bits>
      <bits access="rw" name="lna_band_sel" pos="5" rst="0">
        <comment>
          lna_band_sel
        </comment>
      </bits>
      <bits access="rw" name="gsm_tx_band_sel" pos="4" rst="0">
        <comment>
          gsm_tx_band_sel
        </comment>
      </bits>
      <bits access="rw" name="tx_band_sel" pos="3:2" rst="0">
        <comment>
          tx_band_sel[1:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_101_bit_reserved_0" pos="1" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
      <bits access="rw" name="pu_lvshifter" pos="0" rst="0">
        <comment>
          pu_lvshifter
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_102_bit">
      <bits access="rw" name="rxflt_rstn" pos="15" rst="0">
        <comment>
          rxflt_rstn
        </comment>
      </bits>
      <bits access="rw" name="adc_rstn" pos="14" rst="0">
        <comment>
          adc_rstn
        </comment>
      </bits>
      <bits access="rw" name="dac_rstn" pos="13" rst="0">
        <comment>
          dac_rstn
        </comment>
      </bits>
      <bits access="rw" name="txflt_rstn" pos="12" rst="0">
        <comment>
          txflt_rstn
        </comment>
      </bits>
      <bits access="rw" name="ts_rstn" pos="11" rst="0">
        <comment>
          ts_rstn
        </comment>
      </bits>
      <bits access="rw" name="mdll_startup" pos="10" rst="0">
        <comment>
          mdll_startup
        </comment>
      </bits>
      <bits access="rw" name="xtal_clk2xcv_rfpll_en" pos="9" rst="0">
        <comment>
          xtal_clk2xcv_rfpll_en
        </comment>
      </bits>
      <bits access="rw" name="xtal_clk2xcv_adc_en" pos="8" rst="0">
        <comment>
          xtal_clk2xcv_adc_en
        </comment>
      </bits>
      <bits access="rw" name="xtal_clk2ts_en" pos="7" rst="0">
        <comment>
          xtal_clk2ts_en
        </comment>
      </bits>
      <bits access="rw" name="reg_102_bit_reserved_0" pos="6:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_103_bit">
      <bits access="rw" name="mdll_startup_v" pos="15:13" rst="4">
        <comment>
          mdll_startup_v[2:0]
        </comment>
      </bits>
      <bits access="rw" name="mdll_clk2xcv_rfpll_enb" pos="12" rst="0">
        <comment>
          mdll_clk2xcv_rfpll_enb
        </comment>
      </bits>
      <bits access="rw" name="mdll_clk2bt_rfpll_enb" pos="11" rst="0">
        <comment>
          mdll_clk2bt_rfpll_enb
        </comment>
      </bits>
      <bits access="rw" name="mdll_div_num" pos="10:7" rst="0">
        <comment>
          mdll_div_num[3:0]
        </comment>
      </bits>
      <bits access="rw" name="mdll_dither_bit" pos="6:4" rst="4">
        <comment>
          mdll_dither_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="mdll_cp_ibit" pos="3:1" rst="2">
        <comment>
          mdll_cp_ibit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_103_bit_reserved_0" pos="0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_104_bit">
      <bits access="rw" name="mdll_band" pos="15:13" rst="0">
        <comment>
          mdll_band[2:0]
        </comment>
      </bits>
      <bits access="rw" name="mdll_band_sel" pos="12" rst="0">
        <comment>
          mdll_band_sel
        </comment>
      </bits>
      <bits access="rw" name="mdll_vctrl_test_en" pos="11" rst="0">
        <comment>
          mdll_vctrl_test_en
        </comment>
      </bits>
      <bits access="rw" name="mdll_dither_mode" pos="10" rst="1">
        <comment>
          mdll_dither_mode
        </comment>
      </bits>
      <bits access="rw" name="mdll_dither_en" pos="9" rst="1">
        <comment>
          mdll_dither_en
        </comment>
      </bits>
      <bits access="rw" name="reg_104_bit_reserved_0" pos="8:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_105_bit">
      <bits access="rw" name="pll_reg_presc_bit" pos="15:12" rst="0">
        <comment>
          pll_reg_presc_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_reg_flt_bit" pos="11:8" rst="0">
        <comment>
          pll_reg_flt_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_reg_dig_bit" pos="7:4" rst="0">
        <comment>
          pll_reg_dig_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_reg_div2_bit" pos="3:1" rst="4">
        <comment>
          pll_reg_div2_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_lp_mode" pos="0" rst="0">
        <comment>
          pll_lp_mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_106_bit">
      <bits access="rw" name="pll_open_en" pos="15" rst="0">
        <comment>
          pll_open_en
        </comment>
      </bits>
      <bits access="rw" name="pll_ref_sel" pos="14" rst="0">
        <comment>
          pll_ref_sel
        </comment>
      </bits>
      <bits access="rw" name="pll_sdm_clk_sel" pos="13" rst="0">
        <comment>
          pll_sdm_clk_sel
        </comment>
      </bits>
      <bits access="rw" name="pll_cal_clk_sel" pos="12" rst="0">
        <comment>
          pll_cal_clk_sel
        </comment>
      </bits>
      <bits access="rw" name="pll_fdiv_sel" pos="11" rst="0">
        <comment>
          pll_fdiv_sel
        </comment>
      </bits>
      <bits access="rw" name="pll_bypass_notch" pos="10" rst="0">
        <comment>
          pll_bypass_notch
        </comment>
      </bits>
      <bits access="rw" name="pll_xfer_aux_en" pos="9" rst="0">
        <comment>
          pll_xfer_aux_en
        </comment>
      </bits>
      <bits access="rw" name="pll_vco_gain_bit" pos="8:5" rst="9">
        <comment>
          pll_vco_gain_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_sinc_mode" pos="4:2" rst="1">
        <comment>
          pll_sinc_mode[2:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_refmulti2_en" pos="1" rst="0">
        <comment>
          pll_refmulti2_en
        </comment>
      </bits>
      <bits access="rw" name="reg_106_bit_reserved_0" pos="0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_107_bit">
      <bits access="rw" name="pll_r_bit" pos="15:14" rst="2">
        <comment>
          pll_r_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_pfd_res_bit" pos="13:8" rst="30">
        <comment>
          pll_pfd_res_bit[5:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_lpf_gain" pos="7:4" rst="0">
        <comment>
          pll_lpf_gain[3:0]
        </comment>
      </bits>
      <bits access="rw" name="pll_cp_bit" pos="3:0" rst="0">
        <comment>
          pll_cp_bit[3:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_108_bit">
      <bits access="rw" name="pll_cal_bit" pos="15:14" rst="1">
        <comment>
          pll_cal_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="vco_aux_capbit" pos="13:10" rst="7">
        <comment>
          vco_aux_capbit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_108_bit_reserved_0" pos="9:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_109_bit">
      <bits access="rw" name="vco_core_ibit" pos="15:11" rst="8">
        <comment>
          vco_core_ibit[4:0]
        </comment>
      </bits>
      <bits access="rw" name="vco_lp_en" pos="10" rst="0">
        <comment>
          vco_lp_en
        </comment>
      </bits>
      <bits access="rw" name="vco_v_mode" pos="9" rst="1">
        <comment>
          vco_v_mode
        </comment>
      </bits>
      <bits access="rw" name="vco_reg_buf_bit" pos="8:4" rst="0">
        <comment>
          vco_reg_buf_bit[4:0]
        </comment>
      </bits>
      <bits access="rw" name="vco_reg_buf_lp_bit" pos="3:1" rst="3">
        <comment>
          vco_reg_buf_lp_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="vco_reg_buf_lp_mode" pos="0" rst="0">
        <comment>
          vco_reg_buf_lp_mode
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_10a_bit">
      <bits access="rw" name="lna_s2d_en" pos="15" rst="1">
        <comment>
          lna_s2d_en
        </comment>
      </bits>
      <bits access="rw" name="lna_diff_en" pos="14" rst="0">
        <comment>
          lna_diff_en
        </comment>
      </bits>
      <bits access="rw" name="lna_avdd_sel" pos="13" rst="1">
        <comment>
          lna_avdd_sel
        </comment>
      </bits>
      <bits access="rw" name="lna_nwell_sel" pos="12" rst="1">
        <comment>
          lna_nwell_sel
        </comment>
      </bits>
      <bits access="rw" name="lna_res_short" pos="11" rst="0">
        <comment>
          lna_res_short
        </comment>
      </bits>
      <bits access="rw" name="powdet_ref_bit" pos="10:8" rst="4">
        <comment>
          powdet_ref_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="powdet_mode" pos="7" rst="0">
        <comment>
          powdet_mode
        </comment>
      </bits>
      <bits access="rw" name="pga_bw_rbit" pos="6:5" rst="0">
        <comment>
          pga_bw_rbit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="pga_bw_cbit" pos="4:3" rst="3">
        <comment>
          pga_bw_cbit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="pga_cal_resolv" pos="2:1" rst="0">
        <comment>
          pga_cal_resolv[1:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_10a_bit_reserved_0" pos="0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_10b_bit">
      <bits access="rw" name="pga_cal_i" pos="15:8" rst="128">
        <comment>
          pga_cal_i[7:0]
        </comment>
      </bits>
      <bits access="rw" name="pga_cal_q" pos="7:0" rst="128">
        <comment>
          pga_cal_q[7:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_10c_bit">
      <bits access="rw" name="rxflt_iq_swap" pos="15" rst="0">
        <comment>
          rxflt_iq_swap
        </comment>
      </bits>
      <bits access="rw" name="rxflt_if_bit" pos="14:13" rst="1">
        <comment>
          rxflt_if_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="rxflt_cap_bit" pos="12:9" rst="7">
        <comment>
          rxflt_cap_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="rxflt_cal_mode" pos="8" rst="1">
        <comment>
          rxflt_cal_mode
        </comment>
      </bits>
      <bits access="rw" name="rxflt_cal_en" pos="7" rst="0">
        <comment>
          rxflt_cal_en
        </comment>
      </bits>
      <bits access="rw" name="rxflt_cal_clk_edge" pos="6" rst="0">
        <comment>
          rxflt_cal_clk_edge
        </comment>
      </bits>
      <bits access="rw" name="rxflt_auxin_en" pos="5" rst="0">
        <comment>
          rxflt_auxin_en
        </comment>
      </bits>
      <bits access="rw" name="reg_10c_bit_reserved_0" pos="4:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_10d_bit">
      <bits access="rw" name="adc_open" pos="15" rst="0">
        <comment>
          adc_open
        </comment>
      </bits>
      <bits access="rw" name="adc_iq_swap" pos="14" rst="0">
        <comment>
          adc_iq_swap
        </comment>
      </bits>
      <bits access="rw" name="adc_nrz_mode" pos="13" rst="0">
        <comment>
          adc_nrz_mode
        </comment>
      </bits>
      <bits access="rw" name="adc_lpass_mode" pos="12" rst="0">
        <comment>
          adc_lpass_mode
        </comment>
      </bits>
      <bits access="rw" name="adc_if200k_en" pos="11" rst="0">
        <comment>
          adc_if200k_en
        </comment>
      </bits>
      <bits access="rw" name="adc_cal_refi_en" pos="10" rst="0">
        <comment>
          adc_cal_refi_en
        </comment>
      </bits>
      <bits access="rw" name="adc_cal_refi_bit" pos="9:7" rst="4">
        <comment>
          adc_cal_refi_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="adc_clk_xtal26m_en" pos="6" rst="1">
        <comment>
          adc_clk_xtal26m_en
        </comment>
      </bits>
      <bits access="rw" name="adc_clk_gsm26m_en" pos="5" rst="0">
        <comment>
          adc_clk_gsm26m_en
        </comment>
      </bits>
      <bits access="rw" name="adc_clk_nb30m_en" pos="4" rst="0">
        <comment>
          adc_clk_nb30m_en
        </comment>
      </bits>
      <bits access="rw" name="reg_10d_bit_reserved_0" pos="3:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_10e_bit">
      <bits access="rw" name="padrv_bias_ibit" pos="15:10" rst="7">
        <comment>
          padrv_bias_ibit[5:0]
        </comment>
      </bits>
      <bits access="rw" name="padrv_vbias_bit" pos="9:6" rst="7">
        <comment>
          padrv_vbias_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="padrv_cap_bit" pos="5:2" rst="7">
        <comment>
          padrv_cap_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_10e_bit_reserved_0" pos="1:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_10f_bit">
      <bits access="rw" name="tmx_vcom_sel" pos="15" rst="1">
        <comment>
          tmx_vcom_sel
        </comment>
      </bits>
      <bits access="rw" name="tmx_reg_bypass" pos="14" rst="0">
        <comment>
          tmx_reg_bypass
        </comment>
      </bits>
      <bits access="rw" name="tmx_lobias_bit" pos="13:11" rst="4">
        <comment>
          tmx_lobias_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="tmx_lobuff_drv_bit" pos="10:9" rst="2">
        <comment>
          tmx_lobuff_drv_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="tmx_vcom_nbit" pos="8:3" rst="16">
        <comment>
          tmx_vcom_nbit[5:0]
        </comment>
      </bits>
      <bits access="rw" name="tmx_reg_div_bit" pos="2:0" rst="4">
        <comment>
          tmx_reg_div_bit[2:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_110_bit">
      <bits access="rw" name="tmx_vcom_pbit" pos="15:10" rst="16">
        <comment>
          tmx_vcom_pbit[5:0]
        </comment>
      </bits>
      <bits access="rw" name="gsm_tx_div2_bias_bit" pos="9:7" rst="1">
        <comment>
          gsm_tx_div2_bias_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_110_bit_reserved_0" pos="6:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_111_bit">
      <bits access="rw" name="txflt_lp_mode" pos="15" rst="1">
        <comment>
          txflt_lp_mode
        </comment>
      </bits>
      <bits access="rw" name="txflt_op_ibit" pos="14:13" rst="2">
        <comment>
          txflt_op_ibit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="txflt_mode_bit" pos="12:11" rst="2">
        <comment>
          txflt_mode_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="txflt_cap_bit" pos="10:7" rst="7">
        <comment>
          txflt_cap_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="txflt_cal1_en" pos="6" rst="0">
        <comment>
          txflt_cal1_en
        </comment>
      </bits>
      <bits access="rw" name="txflt_cal2_en" pos="5" rst="0">
        <comment>
          txflt_cal2_en
        </comment>
      </bits>
      <bits access="rw" name="txflt_cal_clk_edge" pos="4" rst="1">
        <comment>
          txflt_cal_clk_edge
        </comment>
      </bits>
      <bits access="rw" name="dac_vtr_sel" pos="3" rst="1">
        <comment>
          dac_vtr_sel
        </comment>
      </bits>
      <bits access="rw" name="dac_vlow_ctrl_bit" pos="2:0" rst="4">
        <comment>
          dac_vlow_ctrl_bit[2:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_112_bit">
      <bits access="rw" name="dac_isel_bit" pos="15:12" rst="1">
        <comment>
          dac_isel_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="dac_core_bit" pos="11:9" rst="4">
        <comment>
          dac_core_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="dac_cm_bit" pos="8:7" rst="2">
        <comment>
          dac_cm_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="dac_mux_en_bit" pos="6:5" rst="2">
        <comment>
          dac_mux_en_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="dac_iout_en" pos="4" rst="0">
        <comment>
          dac_iout_en
        </comment>
      </bits>
      <bits access="rw" name="dac_clk_edge" pos="3" rst="1">
        <comment>
          dac_clk_edge
        </comment>
      </bits>
      <bits access="rw" name="bt_mon_sel" pos="2" rst="0">
        <comment>
          bt_mon_sel
        </comment>
      </bits>
      <bits access="rw" name="auxflt_out_en" pos="1:0" rst="0">
        <comment>
          auxflt_out_en[1:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_113_bit">
      <bits access="rw" name="lna_gain_bit" pos="15:14" rst="2">
        <comment>
          lna_gain_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="lna_fb_rbit" pos="13:11" rst="2">
        <comment>
          lna_fb_rbit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="lna_blk_en" pos="10:8" rst="0">
        <comment>
          lna_blk_en[2:0]
        </comment>
      </bits>
      <bits access="rw" name="lna_ibit" pos="7:4" rst="8">
        <comment>
          lna_ibit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="lna_vbit" pos="3:0" rst="7">
        <comment>
          lna_vbit[3:0]
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_114_bit">
      <bits access="rw" name="lna_vbcg_bit" pos="15:13" rst="6">
        <comment>
          lna_vbcg_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="rmx_lp_mode" pos="12" rst="0">
        <comment>
          rmx_lp_mode
        </comment>
      </bits>
      <bits access="rw" name="rmx_lobias_bit" pos="11:9" rst="4">
        <comment>
          rmx_lobias_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="rmx_gain_bit" pos="8:6" rst="5">
        <comment>
          rmx_gain_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="rmx_div_sel" pos="5:4" rst="0">
        <comment>
          rmx_div_sel[1:0]
        </comment>
      </bits>
      <bits access="rw" name="rmx_div2_bias_bit" pos="3:1" rst="1">
        <comment>
          rmx_div2_bias_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_114_bit_reserved_0" pos="0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_115_bit">
      <bits access="rw" name="pga_gain_bit" pos="15:14" rst="3">
        <comment>
          pga_gain_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="pga_drv_ibit" pos="13" rst="0">
        <comment>
          pga_drv_ibit
        </comment>
      </bits>
      <bits access="rw" name="pga_op_ibit" pos="12:11" rst="3">
        <comment>
          pga_op_ibit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="pga_bypass" pos="10" rst="0">
        <comment>
          pga_bypass
        </comment>
      </bits>
      <bits access="rw" name="rxflt_gain1_bit" pos="9:8" rst="3">
        <comment>
          rxflt_gain1_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="rxflt_gain2_bit" pos="7:6" rst="3">
        <comment>
          rxflt_gain2_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="rxflt_lp_mode" pos="5:3" rst="7">
        <comment>
          rxflt_lp_mode[2:0]
        </comment>
      </bits>
      <bits access="rw" name="rxflt_op_ibit" pos="2:1" rst="2">
        <comment>
          rxflt_op_ibit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_115_bit_reserved_0" pos="0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_116_bit">
      <bits access="rw" name="adc_gain_bit" pos="15:14" rst="2">
        <comment>
          adc_gain_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="adc_isel_bit" pos="13:12" rst="1">
        <comment>
          adc_isel_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="adc_lp_mode" pos="11" rst="0">
        <comment>
          adc_lp_mode
        </comment>
      </bits>
      <bits access="rw" name="reg_116_bit_reserved_0" pos="10:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_117_bit">
      <bits access="rw" name="padrv_balun_swap" pos="15" rst="1">
        <comment>
          padrv_balun_swap
        </comment>
      </bits>
      <bits access="rw" name="padrv_gain_bit" pos="14:11" rst="13">
        <comment>
          padrv_gain_bit[3:0]
        </comment>
      </bits>
      <bits access="rw" name="tmx_gain_bit" pos="10:8" rst="7">
        <comment>
          tmx_gain_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="txflt_gain_bit" pos="7:5" rst="7">
        <comment>
          txflt_gain_bit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="dac_range_bit" pos="4:3" rst="2">
        <comment>
          dac_range_bit[1:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_117_bit_reserved_0" pos="2:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_118_bit">
      <bits access="rw" name="ramp_dac_gain_bit" pos="15:11" rst="0">
        <comment>
          ramp_dac_gain_bit[4:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_118_bit_reserved_0" pos="10:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_119_bit">
      <bits access="rw" name="ts_adc_ibit" pos="15:13" rst="3">
        <comment>
          ts_adc_ibit[2:0]
        </comment>
      </bits>
      <bits access="rw" name="ts_vref_bg_sel" pos="12" rst="1">
        <comment>
          ts_vref_bg_sel
        </comment>
      </bits>
      <bits access="rw" name="ts_vbe_bias_sdm" pos="11" rst="0">
        <comment>
          ts_vbe_bias_sdm
        </comment>
      </bits>
      <bits access="rw" name="ts_vbe_bias_bit" pos="10:3" rst="0">
        <comment>
          ts_vbe_bias_bit[7:0]
        </comment>
      </bits>
      <bits access="rw" name="ts_clk_sel" pos="2:1" rst="1">
        <comment>
          ts_clk_sel[1:0]
        </comment>
      </bits>
      <bits access="rw" name="ts_clk_reverse" pos="0" rst="0">
        <comment>
          ts_clk_reverse
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_11a_bit">
      <bits access="rw" name="ts_div_num" pos="15:12" rst="0">
        <comment>
          ts_div_num[3:0]
        </comment>
      </bits>
      <bits access="rw" name="ts_chopper_en" pos="11" rst="1">
        <comment>
          ts_chopper_en
        </comment>
      </bits>
      <bits access="rw" name="ts_beta_indep_en" pos="10" rst="0">
        <comment>
          ts_beta_indep_en
        </comment>
      </bits>
      <bits access="rw" name="ts_test_xtal_en" pos="9" rst="0">
        <comment>
          ts_test_xtal_en
        </comment>
      </bits>
      <bits access="rw" name="ts_vref_ctrl" pos="8:6" rst="4">
        <comment>
          ts_vref_ctrl[2:0]
        </comment>
      </bits>
      <bits access="rw" name="reg_11a_bit_reserved_0" pos="5:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="reg_11b_bit">
      <bits access="r" name="powdet_latch_out_hb" pos="15" rst="0">
        <comment>
          powdet_latch_out_hb
        </comment>
      </bits>
      <bits access="r" name="powdet_latch_out_lb" pos="14" rst="0">
        <comment>
          powdet_latch_out_lb
        </comment>
      </bits>
      <bits access="r" name="rxflt_cal_out_i" pos="13" rst="0">
        <comment>
          rxflt_cal_out_i
        </comment>
      </bits>
      <bits access="r" name="rxflt_cal_out_q" pos="12" rst="0">
        <comment>
          rxflt_cal_out_q
        </comment>
      </bits>
      <bits access="r" name="txflt_cal_out_i" pos="11" rst="0">
        <comment>
          txflt_cal_out_i
        </comment>
      </bits>
      <bits access="r" name="txflt_cal_out_q" pos="10" rst="0">
        <comment>
          txflt_cal_out_q
        </comment>
      </bits>
      <bits access="r" name="pll_lock" pos="9" rst="0">
        <comment>
          pll_lock
        </comment>
      </bits>
      <bits access="r" name="adc_cal_c_out" pos="8" rst="0">
        <comment>
          adc_cal_c_out
        </comment>
      </bits>
      <bits access="r" name="avss" pos="7:0" rst="0">
        <comment>
          avss
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_11c_bit">
      <bits access="rw" name="reg_11c_bit_reserved_0" pos="15:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="reg_11d_bit">
      <bits access="rw" name="reg_11d_bit_reserved_0" pos="15:0" rst="0">
        <comment>
          Reserved
        </comment>
      </bits>
    </reg>
    <hole size="3264"/>
    <reg protect="rw" name="control_rf_reg6">
      <bits access="r" name="control_rf_reg6_reserved_0" pos="15:1" rst="0">
      </bits>
      <bits access="rw" name="chip_tx_mode_reg" pos="0" rst="0">
        <comment>
          reset of PA ramp logics, active low
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gen_reg0">
      <bits access="r" name="clk_gen_reg0_reserved_0" pos="15" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_4" pos="14:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_3" pos="11:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_2" pos="8:6" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_1" pos="5:3" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_0" pos="2:0" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gen_reg1">
      <bits access="r" name="clk_gen_reg1_reserved_0" pos="15:9" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_7" pos="8:6" rst="0">
        <comment>
          clock selection of xcv_cal_clk[2]
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_6" pos="5:3" rst="0">
        <comment>
          clock selection of xcv_cal_clk[1]
        </comment>
      </bits>
      <bits access="rw" name="freq_clk_div_5" pos="2:0" rst="0">
        <comment>
          clock selection of xcv_cal_clk[0].
0b000: 26MHz/1024
0b001: 26MHz/512
0b010: 26MHz/256
0b011: 26MHz/128
0b100: 26MHz/64
0b101: 26MHz/32
0b110: 26MHz/16
0b111: 26MHz/8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="clk_gen_reg2">
      <bits access="rw" name="inv_clk_div" pos="15:8" rst="0">
        <comment>
          clock inverse of xcv_cal_clk and inernal clocks
        </comment>
      </bits>
      <bits access="rw" name="enable_clk_div" pos="7:0" rst="0">
        <comment>
          clock enable of xcv_cal_clk and inernal clocks
        </comment>
      </bits>
    </reg>
    <hole size="3840"/>
    <reg protect="r" name="chip_id_reg0">
      <bits access="r" name="chip_id0" pos="15:0" rst="35081">
        <comment>
          chip id0
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="chip_id_reg1">
      <bits access="r" name="chip_id_reg1_reserved_0" pos="15:8" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="r" name="chip_id1" pos="7:0" rst="0">
        <comment>
          chip id1
        </comment>
      </bits>
    </reg>
    <reg protect="r" name="chip_id_reg2">
      <bits access="r" name="revision_id" pos="15:0" rst="35081">
        <comment>
          revision_id
        </comment>
      </bits>
    </reg>
    <hole size="96"/>
    <reg protect="r" name="revid_reg">
      <bits access="r" name="revid_reg_reserved_0" pos="15:8" rst="0">
        <comment>
          reseved
        </comment>
      </bits>
      <bits access="r" name="revid_tx" pos="7:4" rst="0">
        <comment>
          GPLL
        </comment>
      </bits>
      <bits access="r" name="revid_rx" pos="3:0" rst="0">
        <comment>
          NPLL
        </comment>
      </bits>
    </reg>
    <hole size="7968"/>
    <reg protect="rw" name="pa_ramp_reg0">
      <bits access="rw" name="ramp_curv0_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg1">
      <bits access="rw" name="ramp_curv0_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg2">
      <bits access="rw" name="ramp_curv0_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg3">
      <bits access="rw" name="ramp_curv0_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg4">
      <bits access="rw" name="ramp_curv0_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg5">
      <bits access="rw" name="ramp_curv0_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg6">
      <bits access="rw" name="ramp_curv0_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg7">
      <bits access="rw" name="ramp_curv0_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv0_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg10">
      <bits access="rw" name="ramp_curv1_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg11">
      <bits access="rw" name="ramp_curv1_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg12">
      <bits access="rw" name="ramp_curv1_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg13">
      <bits access="rw" name="ramp_curv1_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg14">
      <bits access="rw" name="ramp_curv1_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg15">
      <bits access="rw" name="ramp_curv1_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg16">
      <bits access="rw" name="ramp_curv1_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg17">
      <bits access="rw" name="ramp_curv1_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv1_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg20">
      <bits access="rw" name="ramp_curv2_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg21">
      <bits access="rw" name="ramp_curv2_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg22">
      <bits access="rw" name="ramp_curv2_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg23">
      <bits access="rw" name="ramp_curv2_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg24">
      <bits access="rw" name="ramp_curv2_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg25">
      <bits access="rw" name="ramp_curv2_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg26">
      <bits access="rw" name="ramp_curv2_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg27">
      <bits access="rw" name="ramp_curv2_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv2_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg30">
      <bits access="rw" name="ramp_curv3_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg31">
      <bits access="rw" name="ramp_curv3_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg32">
      <bits access="rw" name="ramp_curv3_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg33">
      <bits access="rw" name="ramp_curv3_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg34">
      <bits access="rw" name="ramp_curv3_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg35">
      <bits access="rw" name="ramp_curv3_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg36">
      <bits access="rw" name="ramp_curv3_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg37">
      <bits access="rw" name="ramp_curv3_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv3_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg40">
      <bits access="rw" name="ramp_curv4_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg41">
      <bits access="rw" name="ramp_curv4_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg42">
      <bits access="rw" name="ramp_curv4_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg43">
      <bits access="rw" name="ramp_curv4_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg44">
      <bits access="rw" name="ramp_curv4_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg45">
      <bits access="rw" name="ramp_curv4_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg46">
      <bits access="rw" name="ramp_curv4_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg47">
      <bits access="rw" name="ramp_curv4_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv4_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg50">
      <bits access="rw" name="ramp_curv5_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg51">
      <bits access="rw" name="ramp_curv5_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg52">
      <bits access="rw" name="ramp_curv5_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg53">
      <bits access="rw" name="ramp_curv5_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg54">
      <bits access="rw" name="ramp_curv5_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg55">
      <bits access="rw" name="ramp_curv5_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg56">
      <bits access="rw" name="ramp_curv5_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg57">
      <bits access="rw" name="ramp_curv5_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv5_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg60">
      <bits access="rw" name="ramp_curv6_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg61">
      <bits access="rw" name="ramp_curv6_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg62">
      <bits access="rw" name="ramp_curv6_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg63">
      <bits access="rw" name="ramp_curv6_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg64">
      <bits access="rw" name="ramp_curv6_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg65">
      <bits access="rw" name="ramp_curv6_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg66">
      <bits access="rw" name="ramp_curv6_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg67">
      <bits access="rw" name="ramp_curv6_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv6_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg70">
      <bits access="rw" name="ramp_curv7_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg71">
      <bits access="rw" name="ramp_curv7_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg72">
      <bits access="rw" name="ramp_curv7_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg73">
      <bits access="rw" name="ramp_curv7_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg74">
      <bits access="rw" name="ramp_curv7_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg75">
      <bits access="rw" name="ramp_curv7_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg76">
      <bits access="rw" name="ramp_curv7_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg77">
      <bits access="rw" name="ramp_curv7_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv7_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg80">
      <bits access="rw" name="ramp_curv8_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg81">
      <bits access="rw" name="ramp_curv8_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg82">
      <bits access="rw" name="ramp_curv8_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg83">
      <bits access="rw" name="ramp_curv8_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg84">
      <bits access="rw" name="ramp_curv8_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg85">
      <bits access="rw" name="ramp_curv8_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg86">
      <bits access="rw" name="ramp_curv8_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg87">
      <bits access="rw" name="ramp_curv8_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv8_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg90">
      <bits access="rw" name="ramp_curv9_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg91">
      <bits access="rw" name="ramp_curv9_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg92">
      <bits access="rw" name="ramp_curv9_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg93">
      <bits access="rw" name="ramp_curv9_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg94">
      <bits access="rw" name="ramp_curv9_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg95">
      <bits access="rw" name="ramp_curv9_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg96">
      <bits access="rw" name="ramp_curv9_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg97">
      <bits access="rw" name="ramp_curv9_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv9_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega0">
      <bits access="rw" name="ramp_curva_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega1">
      <bits access="rw" name="ramp_curva_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega2">
      <bits access="rw" name="ramp_curva_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega3">
      <bits access="rw" name="ramp_curva_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega4">
      <bits access="rw" name="ramp_curva_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega5">
      <bits access="rw" name="ramp_curva_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega6">
      <bits access="rw" name="ramp_curva_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rega7">
      <bits access="rw" name="ramp_curva_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curva_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb0">
      <bits access="rw" name="ramp_curvb_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb1">
      <bits access="rw" name="ramp_curvb_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb2">
      <bits access="rw" name="ramp_curvb_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb3">
      <bits access="rw" name="ramp_curvb_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb4">
      <bits access="rw" name="ramp_curvb_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb5">
      <bits access="rw" name="ramp_curvb_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb6">
      <bits access="rw" name="ramp_curvb_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regb7">
      <bits access="rw" name="ramp_curvb_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp up curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvb_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp up curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc0">
      <bits access="rw" name="ramp_curvc_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc1">
      <bits access="rw" name="ramp_curvc_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc2">
      <bits access="rw" name="ramp_curvc_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc3">
      <bits access="rw" name="ramp_curvc_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc4">
      <bits access="rw" name="ramp_curvc_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc5">
      <bits access="rw" name="ramp_curvc_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc6">
      <bits access="rw" name="ramp_curvc_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regc7">
      <bits access="rw" name="ramp_curvc_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve0
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvc_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve0
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd0">
      <bits access="rw" name="ramp_curvd_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd1">
      <bits access="rw" name="ramp_curvd_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd2">
      <bits access="rw" name="ramp_curvd_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd3">
      <bits access="rw" name="ramp_curvd_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd4">
      <bits access="rw" name="ramp_curvd_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd5">
      <bits access="rw" name="ramp_curvd_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd6">
      <bits access="rw" name="ramp_curvd_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regd7">
      <bits access="rw" name="ramp_curvd_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve1
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvd_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege0">
      <bits access="rw" name="ramp_curve_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege1">
      <bits access="rw" name="ramp_curve_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege2">
      <bits access="rw" name="ramp_curve_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege3">
      <bits access="rw" name="ramp_curve_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege4">
      <bits access="rw" name="ramp_curve_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege5">
      <bits access="rw" name="ramp_curve_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege6">
      <bits access="rw" name="ramp_curve_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_rege7">
      <bits access="rw" name="ramp_curve_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve2
        </comment>
      </bits>
      <bits access="rw" name="ramp_curve_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve2
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf0">
      <bits access="rw" name="ramp_curvf_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf1">
      <bits access="rw" name="ramp_curvf_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf2">
      <bits access="rw" name="ramp_curvf_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf3">
      <bits access="rw" name="ramp_curvf_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf4">
      <bits access="rw" name="ramp_curvf_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf5">
      <bits access="rw" name="ramp_curvf_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf6">
      <bits access="rw" name="ramp_curvf_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_regf7">
      <bits access="rw" name="ramp_curvf_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve3
        </comment>
      </bits>
      <bits access="rw" name="ramp_curvf_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg100">
      <bits access="rw" name="ramp_curv10_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg101">
      <bits access="rw" name="ramp_curv10_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg102">
      <bits access="rw" name="ramp_curv10_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg103">
      <bits access="rw" name="ramp_curv10_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg104">
      <bits access="rw" name="ramp_curv10_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg105">
      <bits access="rw" name="ramp_curv10_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg106">
      <bits access="rw" name="ramp_curv10_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg107">
      <bits access="rw" name="ramp_curv10_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve4
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv10_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve4
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg110">
      <bits access="rw" name="ramp_curv11_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg111">
      <bits access="rw" name="ramp_curv11_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg112">
      <bits access="rw" name="ramp_curv11_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg113">
      <bits access="rw" name="ramp_curv11_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg114">
      <bits access="rw" name="ramp_curv11_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg115">
      <bits access="rw" name="ramp_curv11_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg116">
      <bits access="rw" name="ramp_curv11_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg117">
      <bits access="rw" name="ramp_curv11_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve5
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv11_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg120">
      <bits access="rw" name="ramp_curv12_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg121">
      <bits access="rw" name="ramp_curv12_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg122">
      <bits access="rw" name="ramp_curv12_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg123">
      <bits access="rw" name="ramp_curv12_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg124">
      <bits access="rw" name="ramp_curv12_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg125">
      <bits access="rw" name="ramp_curv12_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg126">
      <bits access="rw" name="ramp_curv12_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg127">
      <bits access="rw" name="ramp_curv12_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve6
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv12_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve6
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg130">
      <bits access="rw" name="ramp_curv13_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg131">
      <bits access="rw" name="ramp_curv13_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg132">
      <bits access="rw" name="ramp_curv13_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg133">
      <bits access="rw" name="ramp_curv13_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg134">
      <bits access="rw" name="ramp_curv13_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg135">
      <bits access="rw" name="ramp_curv13_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg136">
      <bits access="rw" name="ramp_curv13_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg137">
      <bits access="rw" name="ramp_curv13_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve7
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv13_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg140">
      <bits access="rw" name="ramp_curv14_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg141">
      <bits access="rw" name="ramp_curv14_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg142">
      <bits access="rw" name="ramp_curv14_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg143">
      <bits access="rw" name="ramp_curv14_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg144">
      <bits access="rw" name="ramp_curv14_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg145">
      <bits access="rw" name="ramp_curv14_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg146">
      <bits access="rw" name="ramp_curv14_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg147">
      <bits access="rw" name="ramp_curv14_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve8
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv14_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve8
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg150">
      <bits access="rw" name="ramp_curv15_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg151">
      <bits access="rw" name="ramp_curv15_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg152">
      <bits access="rw" name="ramp_curv15_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg153">
      <bits access="rw" name="ramp_curv15_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg154">
      <bits access="rw" name="ramp_curv15_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg155">
      <bits access="rw" name="ramp_curv15_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg156">
      <bits access="rw" name="ramp_curv15_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg157">
      <bits access="rw" name="ramp_curv15_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve9
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv15_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg160">
      <bits access="rw" name="ramp_curv16_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg161">
      <bits access="rw" name="ramp_curv16_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg162">
      <bits access="rw" name="ramp_curv16_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg163">
      <bits access="rw" name="ramp_curv16_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg164">
      <bits access="rw" name="ramp_curv16_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg165">
      <bits access="rw" name="ramp_curv16_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg166">
      <bits access="rw" name="ramp_curv16_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg167">
      <bits access="rw" name="ramp_curv16_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve10
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv16_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve10
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg170">
      <bits access="rw" name="ramp_curv17_p1" pos="15:8" rst="24">
        <comment>
          point 1 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_p0" pos="7:0" rst="0">
        <comment>
          point 0 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg171">
      <bits access="rw" name="ramp_curv17_p3" pos="15:8" rst="76">
        <comment>
          point 3 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_p2" pos="7:0" rst="52">
        <comment>
          point 2 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg172">
      <bits access="rw" name="ramp_curv17_p5" pos="15:8" rst="124">
        <comment>
          point 5 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_p4" pos="7:0" rst="104">
        <comment>
          point 4 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg173">
      <bits access="rw" name="ramp_curv17_p7" pos="15:8" rst="168">
        <comment>
          point 7 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_p6" pos="7:0" rst="148">
        <comment>
          point 6 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg174">
      <bits access="rw" name="ramp_curv17_p9" pos="15:8" rst="204">
        <comment>
          point 9 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_p8" pos="7:0" rst="188">
        <comment>
          point 8 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg175">
      <bits access="rw" name="ramp_curv17_pb" pos="15:8" rst="232">
        <comment>
          point 11 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_pa" pos="7:0" rst="220">
        <comment>
          point 10 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg176">
      <bits access="rw" name="ramp_curv17_pd" pos="15:8" rst="248">
        <comment>
          point 13 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_pc" pos="7:0" rst="240">
        <comment>
          point 12 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_ramp_reg177">
      <bits access="rw" name="ramp_curv17_pf" pos="15:8" rst="255">
        <comment>
          point 15 of PA ramp down curve11
        </comment>
      </bits>
      <bits access="rw" name="ramp_curv17_pe" pos="7:0" rst="252">
        <comment>
          point 14 of PA ramp down curve11
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="pa_on_h_reg">
      <bits access="r" name="pa_on_h_reg_reserved_0" pos="15:12" rst="0">
        <comment>
          reserved
        </comment>
      </bits>
      <bits access="rw" name="pa_on_h_dr_reg" pos="11" rst="0">
        <comment>
          pa_on_h direct value
        </comment>
      </bits>
      <bits access="rw" name="pa_on_h_dr_ctrl" pos="10" rst="0">
        <comment>
          pa_on_h direct control, active high
        </comment>
      </bits>
      <bits access="rw" name="ramp_dac_th" pos="9:0" rst="1023">
        <comment>
          ramp_dac threashold to assert pa_on_h
        </comment>
      </bits>
    </reg>
    <hole size="2016"/>
    <reg protect="rw" name="sys_ctrl_reg_20">
      <bits access="rw" name="sys_ctrl2_0" pos="15:0" rst="65535">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_22">
      <bits access="rw" name="sys_ctrl2_2" pos="15:0" rst="65535">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_24">
      <bits access="rw" name="sys_ctrl2_4" pos="15:0" rst="0">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_ctrl_reg_26">
      <bits access="rw" name="sys_ctrl2_6" pos="15:0" rst="0">
        <comment>
          for eco
        </comment>
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "rf_spi.xml">

    <var    name="CMD_FIFO_LEN_BITS" value="5"/>
    <var    name="CMD_FIFO_LEN" value="20"/> 
    <var    name="CMD_SIZE_BITS" value="8"/>
    
    <var    name="CMD_DATA_FIFO_LEN_BITS" value="4"/>
    <var    name="CMD_DATA_FIFO_LEN" value="exp2(CMD_DATA_FIFO_LEN_BITS)"/>
    
    <var    name="GAIN_TABLE_LEN_BITS" value="4"/>
    <var    name="GAIN_TABLE_LEN" value="15"/>  
    <var    name="GAIN_SIZE_BITS" value="4"/>

    <var    name="RX_DATA_FIFO_LEN_BITS" value="2"/>
    <var    name="RX_DATA_FIFO_LEN" value="exp2(RX_DATA_FIFO_LEN_BITS)"/>
    

<module name="rf_spi" category="Modem">

    <reg name="Ctrl" protect="rw">
        <bits name="Enable"         pos="0"     access="rw" rst="0">
            <comment>Enable the rf spi
                <br/>1 = Enable
                <br/>0 = Disable (will finish current command anyway)
            </comment>
        </bits>
        <bits name="CS_Polarity"    pos="1"     access="rw" rst="1">
            <comment>Chip select polarity
                <br/>1 = the chip select is active low
                <br/>0 = the chip select is active high
            </comment>
        </bits>
        <bits name="DigRF_Read"     pos="2"     access="rw" rst="1">
            <comment>DigRF Read style mode
                <br/>1 = DigRF Read style mode (read after CS disabled)
                <br/>0 = SPI Read mode (read during write)
            </comment>
        </bits>
        <bits name="Clocked_Back2Back"  pos="3" access="rw" rst="1">
            <comment>DigRF style clocked back to back mode
                <br/>1 = clocked back to back transfers using turnarround timing only when more data are present in the FIFO.
                <br/>0 = stop the clock between each access according to CS_End_Hold and CS_Pulse_Min timings
            </comment>
        </bits>
        <bits name="Input_Mode"     pos="4"     access="rw" rst="1">
            <comment>Input mode
                <br/>1 = Record input data to input FIFO
                <br/>0 = No input data
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5"     access="rw" rst="0">
            <comment>SPI Clock polarity
                <br/>1 = the clock disabled level is high, and the first edge is a falling edge.
                <br/>0 = the clock disabled level is low, and the first edge is a rising edge.
            </comment>
        </bits>
        <bits name="Clock_Delay"    pos="7:6"   access="rw" rst="3">
            <comment>Transfer start to first edge delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay"       pos="9:8"   access="rw" rst="3">
            <comment>Transfer start to first data out delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first data out.
            </comment>
        </bits>
        <bits name="DI_Delay"       pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sampled delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the first data sampled in.
                <br/> The DI_Delay only specify the sampling time, for frame size, the counter is based on the DO_Delay even in DigRF read mode.
            </comment>
        </bits>
        <bits name="CS_Delay"       pos="13:12" access="rw" rst="3">
            <comment>Transfer start to CS activation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the CS activation edge.
            </comment>
        </bits>
        <bits name="CS_End_Hold"    pos="15:14" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the end of transfer (DO) and the CS deactivation edge.
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Frame_Size"     pos="20:16" access="rw" rst="31">
            <comment>Number of data in the frame, or number of out data in DigRF read mode.
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>The frame size is given for the number of data, the actual number of clock pulses might be greater. First if Clock_Delay &lt; DO_Delay an extra clock pulse is generated, second in case of DigRF read or back2back, some more clock pulses will be generated.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="CS_End_Pulse"   pos="23:22" access="rw" rst="3">
            <comment>Chip select deactivation to new start of transfer minimum delay
                <br/>value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new transfer start (transfer will start only if more data are available in the transmit FIFO)
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name="Input_Frame_Size"   pos="28:24" access="rw" rst="31">
            <comment>When DigRF input mode: The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>When Normal SPI input mode: When 0: regular mode, SPI_DO pin as output only; Other: Value from 1 to 31 is the number of data out to transfert before the SPI_DO pin switch to input;
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name="TurnAround_Time"    pos="31:30" access="rw" rst="3">
            <comment>TurnAround time: end of write frame to start of read frame delay (in cycles)
                <br/>value from 0 to 3 is the number of spi clock period between the end of the output frame (without the DO_Delay) and the Input Frame start.
                <br/>Also used for Clocked_Back2Back mode, when Clocked_Back2Back=1 and there is more data available in the transmit FIFO:
                <br/>value from 0 to 3 is the number of spi clock period between the end of the frame (without the DO_Delay) and the start of the new frame.
                (It can also be seen as the number of spi clock period between the end of the last data bit and the start of the new data bit.)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="rw">
        <bits name="Active_Status"      pos="0"     access="r" rst="0">
            <comment>The SPI activity status
                <br/>1 = A transfer is in progress
                <br/>0 = The transfer is done
            </comment>
        </bits>
        <bits name="Error_Cmd"          pos="1"     access="rc" rst="0">
            <comment>Error status
                <br/>1 = a new command (or gain) has been requested while a command was in progress.
                <br/>0 = No error
                <br/>Write 1 to clear.
            </comment>
        </bits>
        <bits name="Table_Ovf"          pos="6"     access="rc" rst="0">
            <comment>The Gain Table overflow status.
                <br/>1 = Too many data has been written in the table
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Table_Udf"          pos="7"     access="rc" rst="0">
            <comment>The Gain Table underflow status.
                <br/> 1 = a next gain request has been received while the read pointer was already at the top of the table.
                <br/> Writing a '1' clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Level"          pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Ovf"            pos="14"    access="rc" rst="0">
            <comment>The command FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Udf"            pos="15"    access="rc" rst="0">
            <comment>The command FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Level"     pos="CMD_DATA_FIFO_LEN_BITS+16:16"  access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Data_Ovf"       pos="22"    access="rc" rst="0">
            <comment>The command data FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Cmd_Data_Udf"       pos="23"    access="rc" rst="0">
            <comment>The command data FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name="Rx_Level"           pos="RX_DATA_FIFO_LEN_BITS+24:24"   access="r" rst="0">
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Receive FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name="Rx_Ovf"             pos="30"    access="rc" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name="Rx_Udf"             pos="31"    access="rc" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
    </reg>
    <reg name="Rx_Data" protect="">
        <bits name="Rx_Data"    pos="7:0"   access="rw"  rst="no">
            <comment>Read in the receive FIFO
                <br/>Writing this register will write to Cmd_Data fifo (same as Cmd_Data register). This is because this address is used by the IFC channels to access the fifos.
            </comment>
        </bits>
    </reg>
    <reg name="Command" protect="w">
        <bits name="Send_Cmd"           pos="0"     access="w" rst="0">
            <comment> Writing 1 send the next command in the Cmd FIFO (This replace the TCU next cmd signal)
            </comment>
        </bits>
        <bits name="Flush_Cmd_FIFO"     pos="8"     access="w" rst="0">
            <comment>Writing 1 flush both Cmd, and cmd_data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Flush_Rx_FIFO"      pos="16"    access="w" rst="0">
            <comment>Writing 1 flush the receive data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Restart_Gain"       pos="24"    access="w" rst="0">
            <comment>Writing 1 place the read pointer at the beginning of the gain table. <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name="Reload_Gain"        pos="28"    access="w" rst="0">
            <comment>Writing 1 place the write pointer at the beginning of the gain table allowing to fill the table.
            </comment>
        </bits>
        <bits name="Drive_Zero"         pos="31"    access="rw" rst="0">
            <comment>Writing 1 change all the ouputs of the SPI interface to drive a logical '0'. This mode stops when a new command is requested to be send (by TCU) or when writting 0 to this register. This mode is useful when powering off the tranciever chip connected to the RF_SPI.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Size" protect="w">
        <bits name="Cmd_Size"    pos="CMD_SIZE_BITS-1:0"   access="w"  rst="no">
            <comment>Write the size in bytes of the next command in the FIFO
            </comment>
        </bits>
        <bits name="Cmd_Mark"   pos="31"    access="w"  rst="no">
            <comment>Write 1 to mark the command.
                <br/>Marked commands are discarded if Enable_Rf_Spi_Marked_Cmd is low in the tcu register.
            </comment>
        </bits>
    </reg>
    <reg name="Cmd_Data" protect="w">
        <bits name="Cmd_Data"    pos="7:0"   access="w"  rst="no">
            <comment>Write in the Command data FIFO
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Size" protect="rw">
        <bits name="Gain_Size"   pos="GAIN_SIZE_BITS-1:0"   access="rw"  rst="0">
            <comment>Size of a Gain command in bytes.
            </comment>
        </bits>
    </reg>
    <reg name="Gain_Data" protect="w">
        <bits name="Gain_Data"   pos="7:0"   access="w"  rst="no">
            <comment>Write in the Gain Table (the pointer auto increments)
            </comment>
        </bits>
    </reg>
    <reg name="IRQ" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Cause"    pos="0" access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Cause bit
                <br/> 1 = the IRQ was triggered by the end of the DMA transfer to the cmd FIFO.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Status bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Cause"       pos="2" access="r" rst="0">
            <comment>Cmd_FIFO_empty IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO is empty.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Cause"        pos="3" access="r" rst="0">
            <comment>Cmd_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO level is below the Cmd_Threshold.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Cause"         pos="4" access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO is full.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Cause"         pos="5" access="r" rst="0">
            <comment>Rx_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO level is over the Rx_Threshold.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name="Error_Cause"                pos="6" access="r" rst="0">
            <comment>Error IRQ Cause bit
                <br/> 1 = the IRQ was triggered because an error occured. Read the Status register to check the kind of error.
                <br/> To clear it, clear it in the Status register.
            </comment>
        </bits>
        <bitgroup name="All_Cause">
            <entry ref="Cmd_Data_DMA_Done_Cause"/>
            <entry ref="Cmd_FIFO_empty_Cause"/>
            <entry ref="Cmd_Threshold_Cause"/>
            <entry ref="Rx_FIFO_full_Cause"/>
            <entry ref="Rx_Threshold_Cause"/>
            <entry ref="Error_Cause"/>
        </bitgroup>
        <bits name="Cmd_Data_DMA_Done_Status"   pos="16"    access="rc" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Status bit
                <br/> 1 = the end of the DMA transfer to the cmd FIFO occured.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Cause bit.
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Status"      pos="18"    access="r" rst="1">
            <comment>Cmd_FIFO_empty IRQ Status bit
                <br/> 1 = the Cmd_FIFO is empty.
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Status"       pos="19"    access="r" rst="1">
            <comment>Cmd_Threshold IRQ Status bit
                <br/> 1 = the Cmd_FIFO level is bellow the Cmd_Threshold.
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Status"        pos="20"    access="r" rst="0">
            <comment>Rx_FIFO_full IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO is full.
            </comment>
        </bits>
        <bits name="Rx_Threshold_Status"        pos="21"    access="r" rst="0">
            <comment>Rx_Threshold IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO level is over the Rx_Threshold.
            </comment>
        </bits>
        <bits name="Error_Status"               pos="22"    access="r" rst="0">
            <comment>Error IRQ Status bit
                <br/> 1 = an error occured. Read the Status register to check the kind of error.
            </comment>
        </bits>
        <bitgroup name="All_Status">
            <entry ref="Cmd_Data_DMA_Done_Status"/>
            <entry ref="Cmd_FIFO_empty_Status"/>
            <entry ref="Cmd_Threshold_Status"/>
            <entry ref="Rx_FIFO_full_Status"/>
            <entry ref="Rx_Threshold_Status"/>
            <entry ref="Error_Status"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Mask" protect="rw">
        <bits name="Cmd_Data_DMA_Done_Mask"     pos="0" access="rw" rst="0">
            <comment>Cmd_Data_DMA_Done IRQ Mask bit
                <br/> 1 = the Cmd_Data_DMA_Done IRQ is enabled
                <br/> 0 = the Cmd_Data_DMA_Done IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_FIFO_empty_Mask"        pos="2" access="rw" rst="0">
            <comment>Cmd_FIFO_empty IRQ Mask bit
                <br/> 1 = the Cmd_FIFO_empty IRQ is enabled
                <br/> 0 = the Cmd_FIFO_empty IRQ is disabled
            </comment>
        </bits>
        <bits name="Cmd_Threshold_Mask"         pos="3" access="rw" rst="0">
            <comment>Cmd_Threshold IRQ Mask bit
                <br/> 1 = the Cmd_Threshold IRQ is enabled
                <br/> 0 = the Cmd_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_FIFO_full_Mask"          pos="4" access="rw" rst="0">
            <comment>Rx_FIFO_full IRQ Mask bit
                <br/> 1 = the Rx_FIFO_full IRQ is enabled
                <br/> 0 = the Rx_FIFO_full IRQ is disabled
            </comment>
        </bits>
        <bits name="Rx_Threshold_Mask"          pos="5" access="rw" rst="0">
            <comment>Rx_Threshold IRQ Mask bit
                <br/> 1 = the Rx_Threshold IRQ is enabled
                <br/> 0 = the Rx_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name="Error_Mask"                 pos="6" access="rw" rst="0">
            <comment>Error IRQ Mask bit
                <br/> 1 = the Error IRQ is enabled
                <br/> 0 = the Error IRQ is disabled
            </comment>
        </bits>
        <bitgroup name="All_Mask">
            <entry ref="Cmd_Data_DMA_Done_Mask"/>
            <entry ref="Cmd_FIFO_empty_Mask"/>
            <entry ref="Cmd_Threshold_Mask"/>
            <entry ref="Rx_FIFO_full_Mask"/>
            <entry ref="Rx_Threshold_Mask"/>
            <entry ref="Error_Mask"/>
        </bitgroup>
    </reg>
    <reg name="IRQ_Threshold" protect="rw">
        <bits name="Cmd_Threshold"      pos="CMD_FIFO_LEN_BITS+7:8" access="r" rst="all1">
            <comment>Command FIFO Threshold, number of command in the FIFO bellow which the Cmd_Threshold_IRQ is triggered.
            </comment>
        </bits>
        <bits name="Rx_Threshold"       pos="RX_DATA_FIFO_LEN_BITS+23:24"   access="r" rst="all1">
            <comment>Receive FIFO Threshold, number of bytes in the FIFO above which the Rx_Threshold_IRQ is triggered.
            </comment>
        </bits>
    </reg>
    <reg name="Divider" protect="rw">
        <bits name="Divider"    pos="6:1"   access="rw" rst="0">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1. So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="0">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "rffe.xml">

<module name="rf_dig_rffe" category="rf_dig">

    <reg name="CMD_MIPI" protect="rw">
        <bits name="cmd_mipi" pos="31:0" access="rw" rst="0">
            <comment>cmd_mipi_sr[31:0]
            </comment>
        </bits>
    </reg>

    <reg name="DATA_MIPI" protect="rw">
        <bits name="data_mipi" pos="31:0" access="rw" rst="0">
            <comment>data_mipi_sr[31:0]
            </comment>
        </bits>
    </reg>
 
    <reg name="DATA_OUT" protect="rw">
        <bits name="data_out" pos="31:0" access="rw" rst="0">
            <comment>data_out[31:0]
            </comment>
        </bits>
    </reg>
 
    <reg name="DATA_VALID" protect="rw">
        <bits name="data_out_high" pos="3:0" access="rw" rst="0">
            <comment>data_valid byte[3:0]
            </comment>
        </bits>
    </reg>
 
</module>

</archive>
<archive relative = "sci.xml">
<module name="sci" category="Modem">
    <reg name="Config" protect="rw">
        <bits name="Enable" pos="0" access="rw" rst="0">
            <comment>Enables the SIM Card IF module
            </comment>
        </bits>
        <bits name="Parity" pos="1" access="rw" rst="0">
            <comment>Selects the parity generation/detection
            </comment>
            <options>
                <option value="0" name="Even_parity"/>
                <option value="1" name="Odd_parity"/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="PERF" pos="2" access="rw" rst="0">
            <comment>Parity Error Receive Feed-through
                <br/>0 = Don't store bytes with detected parity errors
                <br/>1 = Feed-through bytes with detected parity errors
            </comment>
        </bits>
        <bits name="Filter_Disable" pos="3" access="rw" rst="0">
            <comment>Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
                <br/>0 = Enable NULL character filtering, NULL characters are not reported if not data.
                <br/>1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
            </comment>
        </bits>
        <bits name="ClockStop" pos="4" access="rw" rst="1">
            <comment>Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
                <br/>0 = Enable the SCI clock
                <br/>1 = Disable SCI clock
            </comment>
        </bits>
        <bits name="AutoStop_En_H" pos="5" access="rw" rst="0">
            <comment>Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
                <br/>0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
                <br/>1 = Auto clock control enabled.
            </comment>
        </bits>
        <bits name="MSBH_LSBL" pos="6" access="rw" rst="1">
            <comment>Sets the transmission and reception bit order:
                <br/>0 = LSB is sent/recieved first (Direct convention)
                <br/>1 = MSB is sent/received first (Inverse convention)
            </comment>
        </bits>
        <bits name="LLI" pos="7" access="rw" rst="1">
            <comment>Logic Level Invert:
                <br/>0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
                <br/>1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
            </comment>
        </bits>
        <bits name="PEGen_Len" pos="8" access="rw" rst="0">
            <comment>Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
                <br/>0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
                <br/>1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
            </comment>
        </bits>
        <bits name="Parity_En" pos="9" access="rw" rst="0">
            <comment>Enable or disable parity error checking on the receive data
                <br/>0 = Disable parity error checking
                <br/>1 = Enable parity error checking
            </comment>
        </bits>
        <bits name="Stop_Level" pos="10" access="rw" rst="1">
            <comment>Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
                <br/>0 = Stop clock at low level
                <br/>1 = Stop clock at high level
            </comment>
        </bits>
        <bits name="Rx_Clk_Cnt_Sample " pos="15:11" access="rw" rst="1">
            <comment> tunning the sample local.
            </comment>
        </bits>
        <bits name="ARG_H" pos="16" access="rw" rst="0">
            <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.
            </comment>
        </bits>
        <bits name="AFD_En_H" pos="17" access="rw" rst="0">
            <comment>Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
                <br/>1 = Enable TS detection and automatic convention settings programming
                <br/>0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
            </comment>
        </bits>
        <bits name="Tx_Resend_En_H" pos="18" access="rw" rst="1">
            <comment>1 = Enable automatic resend of characters when Tx parity error is detected
                <br/>0 = Disable automatic resend
            </comment>
        </bits>
        <bits name="IO_data_l" pos="19" access="rw" rst="0">
            <comment>1 = pulldown
                <br/>0 = pullup
            </comment>
        </bits>
        <bits name="Reset" pos="20" access="rw" rst="0">
            <comment>Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
                <br/>0 = SCI_Reset low voltage
                <br/>1 = SCI Reset high voltage
            </comment>
        </bits>
        <bits name="Dly_Sel" pos="21" access="rw" rst="0">
            <comment>This selects between two delay times for the automatic clock stop startup and shutdown:
                <br/>0 = short delay
                <br/>Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
                <br/>1 = long delay
                <br/>Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
            </comment>
        </bits>
        <bits name="In_avg_en" pos="22" access="rw" rst="1">
            <comment>Input data average enable.
                <br/>0 = Disable
                <br/>1 = Enable
            </comment>
        </bits>
        <bits name="Par_Chk_Offset" pos="29:24" access="rw" rst="0xe">
            <comment>Allows fine control of the parity check position during the parity error time period.
            </comment>
        </bits>
        <bits name="Sci_Mode" pos="31:30" access="rw" rst="0">
            <comment>These bits are reserved and must be written as '00' for the SCI module to work properly:
                <br/>"11" = Ser In &lt;- Ser Out loopback
                <br/>"10" = Ser In &lt;- Ser In (unmasked)
                <br/>others = Ser In &lt;- Ser In masked with Txing_H (normal mode)
            </comment>
        </bits>
    </reg>
    <reg name="Status" protect="r">
        <bits name="RxData_Rdy" pos="0" access="r" rst="0">
            <comment>Returns the status of the Rx FIFO:
                <br/>0 = Rx FIFO empty
                <br/>1 = There is at least 1 character in the Rx FIFO
            </comment>
        </bits>
        <bits name="Tx_FIFO_Rdy" pos="1" access="r" rst="1">
            <comment>Returns the status of the Tx FIFO:
                <br/>0 = Tx FIFO is full
                <br/>1 = There is at least 1 free spot in the Tx FIFO
            </comment>
        </bits>
        <bits name="Format_Det" pos="2" access="r" rst="0">
            <comment>Returns the status of the automatic format detection after reset:
                <br/>0 = TS character has not been detected in the ATR
                <br/>1 = TS character has been detected and SCI module is using the automatic convention settings
                <br/>
                <br/>This bit is cleared when the AFD_En bit is cleared
            </comment>
        </bits>
        <bits name="ARG_Det" pos="3" access="r" rst="0">
            <comment>Returns the status of the automatic reset procedure:
                <br/>0 = ARG detection has failed
                <br/>1 = ARG detection has detected that the SIM has responded to the reset
                <br/>
                <br/>This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
            </comment>
        </bits>
        <bits name="Reset_Det" pos="4" access="r" rst="0">
            <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')
            </comment>
        </bits>
        <bits name="Clk_Rdy_H" pos="5" access="r" rst="0">
            <comment>Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
                <br/>0 = SCI clock may be on or off but is not ready for use
                <br/>1 = SCI clock is on and ready for use
            </comment>
        </bits>
        <bits name="Clk_Off" pos="6" access="r" rst="1">
            <comment>Status bit of the Sci clock. 
                <br/>0 = Sci clock is ON
                <br/>1 = Sci clock is OFF
            </comment>
        </bits>
        <bits name="Rx_Err" pos="8" access="r" rst="0">
            <comment>A receive parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="Tx_Err" pos="9" access="r" rst="0">
            <comment>A transmit parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="RxOverflow" pos="10" access="r" rst="0">
            <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits> 
        <bits name="TxOverflow" pos="11" access="r" rst="0">
            <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name="AutoStop_State" pos="31:30" access="r" rst="0">
            <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.
            </comment>
            <options>
                <option value="0" name="Startup_phase"><comment>Clock is on, but not ready to be used.</comment></option>
                <option value="1" name="Auto_on"><comment>Clock is on and ready to be used</comment></option>
                <option value="2" name="Shutdown_phase"><comment>Clock is still on, but should not be used.</comment></option>
                <option value="3" name="Clock_off"><comment>Clock is off.</comment></option>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name="Data" protect="--">
        <bits name="Data_IN" pos="7:0" access="w" rst="0">
            <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent. 
            </comment>
        </bits>
        <bits name="Data_OUT" pos="7:0" access="r" rst="0">
            <comment>Reading this register will read from the receive data FIFO.
            </comment>
        </bits>
    </reg>
    <reg name="ClkDiv" protect="rw">
        <bits name="ClkDiv" pos="8:0" access="rw" rst="0x174">
            <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.
            </comment>
        </bits>
        <bits name="Baud_x8_En" pos="9" access="rw" rst="0">
            <comment>Speed mode enable.
                <br/>0 = Low speed mode
                <br/>1 = High speed mode(372/32, 372/64, 512/64)
            </comment>
        </bits>
        <bits name="Rx_Clk_Cnt_Limit" pos="14:10" access="rw" rst="0x10">
            <comment>Rx_clk_cnt wrap value.
            </comment>
         </bits>
        <bits name="Clk_Tst" pos="15" access="rw" rst="0">
          </bits>
        <bits name="ClkDiv_16" pos="23:16" access="rw" rst="0x18">
            <comment>Secondary clock divider for generating 16x baud clock.
            </comment>
        </bits>
        <bits name="MainDiv" pos="29:24" access="rw" rst="0x4">
            <comment>Main clock divider to generate the SCI clock.  This value should be calculated as follows:
                <br/>MainDiv = Clk_Sys/(2xSCI_Clk) - 1
                <br/>where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
            </comment>
            <options><mask/><default/></options>
        </bits>
        <bits name="Clk_Out_Inv" pos="30" access="rw" rst="0">
            <comment>Inverts the polarity of the SCI clock to the SIM card only.
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
        <bits name="Clk_Inv" pos="31" access="rw" rst="0">
            <comment>Inverts  SCI clock to the SIM card .
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
    </reg>
    <reg name="RxCnt" protect="rw">
        <bits name="RxCnt" pos="9:0" access="rw" rst="0">
            <comment>This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is <strong>actually</strong> received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
            </comment>
        </bits>
        <bits name="Clk_Persist" pos="31" access="rw" rst="0">
            <comment>When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
                <br/>1 = Keep clock on
                <br/>0 = Allow clock shutdown when transfer is complete
            </comment>
        </bits>
    </reg>
    <reg name="Times" protect="rw">
        <bits name="ChGuard" pos="7:0" access="rw" rst="1">
            <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="TurnaroundGuard" pos="11:8" access="rw" rst="0x6">
            <comment>Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
                <br/>Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="WI" pos="23:16" access="rw" rst="0x0A">
            <comment>Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
                <br/>       WWT = 960 x WI x (F/Fi)
                <br/>where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
                <br/>The SCI_WI value must be calculated as follows:
                <br/>       SCI_WI = WI * D
                <br/>Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
            
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Tx_PERT" pos="31:24" access="rw" rst="0xFF">
            <comment>Number of times to try resending character when the SIM indicates a parity error.
            </comment>
        </bits>
    </reg>  
    <reg name="Ch_Filt" protect="rw">
        <bits name="Ch_Filt" pos="7:0" access="rw" rst="0x60">
            <comment>Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the <strong>first</strong> 0x60 character that is received by the SIM during a transfer will <strong>not</strong> be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
            </comment>
        </bits>
    </reg>  
    
    <reg name="dbg" protect="w">
        <bits name="FIFO_RX_Clr" pos="0" access="w" rst="0">
            <comment>Clear RX FIFO.
            </comment>
        </bits>     
        <bits name="FIFO_TX_Clr" pos="1" access="w" rst="0">
            <comment>Clear TX FIFO.
            </comment>
        </bits>     
        <comment>UNDOCUMENTED FEATURE</comment>
    </reg>  
    <reg name="Int_Cause" protect="r">
        <bits name="Rx_Done" pos="0" access="r" rst="0">
            <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="r" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="r" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="r" rst="0">
            <comment>An extra character has been received after the number of characters in RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="r" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="r" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Tx_Done" pos="6" access="r" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="r" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This register is a <b>READ ONLY</b> register that returns the logical <b>and</b> of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the <u>status</u> of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
    </reg>  
    <reg name="Int_Clr" protect="rw">
        <bits name="Rx_Done" pos="0" access="c" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="c" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="c" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="c" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="c" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="c" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Tx_Done" pos="6" access="c">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="c">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.
        </comment>
    </reg>  
    <reg name="Int_Mask" protect="rw">
        <bits name="Rx_Done" pos="0" access="rw" rst="0">
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name="Rx_Half" pos="1" access="rw" rst="0">
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name="WWT_Timeout" pos="2" access="rw" rst="0">
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name="Extra_Rx" pos="3" access="rw" rst="0">
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name="Resend_Ovfl" pos="4" access="rw" rst="0">
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name="ARG_End" pos="5" access="rw" rst="0">
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>  
        <bits name="Sci_DMA_Tx_Done" pos="6" access="rw" rst="0">
            <comment>DMA tx done.
            </comment>
        </bits>     
        <bits name="Sci_DMA_Rx_Done" pos="7" access="rw" rst="0">
            <comment>DMA rx done.
            </comment>
        </bits>     
        <comment>
            This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.
        </comment>
    </reg>  
    <reg name="PA_CLK_STOP_EN" protect="rw">
        <bits name="PA_CLK_STOP_EN" pos="0" access="rw" rst="0">
            <comment>Set this bit to 1'b0, then when pa_en = 1,sci stops work.
            </comment>
        </bits>
    </reg>
    <reg name="PA_STATUS" protect="r">
        <bits name="PA_STATUS" pos="0" access="r" rst="0">
            <comment>Status of pa_en.
            </comment>
        </bits>
    </reg>
    <reg name="WR_REG_ONGOING" protect="r">
        <bits name="CFG_REG_WR_ONGOING" pos="0" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="CLKDIV_REG_WR_ONGOING" pos="1" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="RXCNT_REG_WR_ONGOING" pos="2" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="TIMES_REG_WR_ONGOING" pos="3" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
        <bits name="CH_FILT_REG_WR_ONGOING" pos="4" access="r" rst="0">
            <comment>Status of write operation.
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative = "sdmmc.xml">

<module name="sdmmc" category="Periph">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="2:0" access="rw" rst="000">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"000": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"001": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"010": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"010": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
              <br/>"100": reversed on bit.
                <br/>Byte3="0A",Byte2="0X,Byte1="0D",Byte0="0C".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="3" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w" rst="0">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r" rst="0">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
    <bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
        <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
        </options>
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
    <bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
        <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
        </options>
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
        <options>
            <default/>
            <option name="SIMPLE"   value="0"/>
            <option name="MULTIPLE" value="1"/>
        </options>
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	<bits access="rw" name="AUTO_FLAG_EN" pos="16" rst="1">
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>

	<bits access="r" name="DAT3_VAL" pos="24" rst="-">
		<comment>SDMMC DATA 3 value.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		       <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_INT" pos="5" rst="0">
		<comment>'1' means tx dma done.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_INT" pos="6" rst="0">
		<comment>'1' means rx dma done.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_SC" pos="8" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="9" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="12" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_SC" pos="13" rst="0">
		<comment>'1' means tx dma done is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_SC" pos="14" rst="0">
		<comment>'1' means rx dma done is the source of interrupt.
		</comment>
	</bits>    
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="TXDMA_DONE_MK" pos="5" rst="0">
		<comment>when tx dma done, '1' means INT is disabled.
		</comment>
	</bits>

	<bits access="rw" name="RXDMA_DONE_MK" pos="6" rst="0">
		<comment>'1' means rx dma done, '1' means INT is disabled.
		</comment>
	</bits>    
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>

 	<bits access="w" name="TXDMA_DONE_CL" pos="5" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.
		</comment>
	</bits>

	<bits access="w" name="RXDMA_DONE_CL" pos="6" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.
		</comment>
	</bits>   
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>
<archive relative = "sdmmc2.xml">

<module name="sdmmc2" category="Periph">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="2:0" access="rw" rst="000">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"000": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"001": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"010": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"010": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
              <br/>"100": reversed on bit.
                <br/>Byte3="0A",Byte2="0X,Byte1="0D",Byte0="0C".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="3" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w" rst="0">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r" rst="0">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
    <bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
        <options>
            <default/>
            <option name="R2" value="0b10"/>
            <option name="R3" value="0b01"/>
            <option name="OTHER" value="0b00"/>
        </options>
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
    <bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
        <options>
            <default/>
            <option name="READ" value="0"/>
            <option name="WRITE" value="1"/>
        </options>
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
        <options>
            <default/>
            <option name="SIMPLE"   value="0"/>
            <option name="MULTIPLE" value="1"/>
        </options>
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	<bits access="rw" name="AUTO_FLAG_EN" pos="16" rst="1">
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>

	<bits access="r" name="DAT3_VAL" pos="24" rst="-">
		<comment>SDMMC DATA 3 value.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		       <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_INT" pos="5" rst="0">
		<comment>'1' means tx dma done.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_INT" pos="6" rst="0">
		<comment>'1' means rx dma done.
		</comment>
	</bits>
	
	<bits access="r" name="DAT1_IN_INT" pos="7" rst="0">
		<comment>'1' means DAT1_IN is low when not DL_busy.
		</comment>
	</bits>

	<bits access="r" name="DAT0_IN_INT" pos="8" rst="0">
		<comment>'1' means DAT0_IN is low when not DL_busy.
		</comment>
	</bits>

	<bits access="r" name="NO_RSP_SC" pos="9" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="12" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="13" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="TXDMA_DONE_SC" pos="14" rst="0">
		<comment>'1' means tx dma done is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RXDMA_DONE_SC" pos="15" rst="0">
		<comment>'1' means rx dma done is the source of interrupt.
		</comment>
	</bits>    
	
	<bits access="r" name="DAT1_IN_SC" pos="16" rst="0">
		<comment>'1' means DAT1_IN is the source of interrupt.
		</comment>
	</bits>    
	
	<bits access="r" name="DAT0_IN_SC" pos="17" rst="0">
		<comment>'1' means DAT0_IN is the source of interrupt.
		</comment>
	</bits>    
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="TXDMA_DONE_MK" pos="5" rst="0">
		<comment>when tx dma done, '1' means INT is disabled.
		</comment>
	</bits>

	<bits access="rw" name="RXDMA_DONE_MK" pos="6" rst="0">
		<comment>'1' means rx dma done, '1' means INT is disabled.
		</comment>
	</bits>    

	<bits access="rw" name="DAT1_IN_MK" pos="7" rst="0">
		<comment>'1' means DAT1 is low when not DL_busy, '1' means INT is disabled.
		</comment>
	</bits>    

	<bits access="rw" name="DAT0_IN_MK" pos="8" rst="0">
		<comment>'1' means DAT0 is low when not DL_busy, '1' means INT is disabled.
		</comment>
	</bits>    
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>

 	<bits access="w" name="TXDMA_DONE_CL" pos="5" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in TXDMA_DONE_SC.
		</comment>
	</bits>

	<bits access="w" name="RXDMA_DONE_CL" pos="6" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RXDMA_DONE_SC.
		</comment>
	</bits>   
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>
<archive relative = "seg_lcd.xml">

<module name="seg_lcd" category="Periph">

    <reg name="code_num_reg" protect="rw">
        <bits name="code_num"   pos="4:0"   access="rw" rst="5'h7">
            <comment> configure  the range (1-18) of code number  registers
            </comment>
        </bits>
    </reg>

    <reg name="refresh_cycle_reg" protect="rw"  >
        <bits name="refresh_cycle"   pos="31:0" access="rw" rst="32'hffff">
            <comment>configure the refreshed cycle in pclk domain when change output data from another code number register.
            </comment>
        </bits>
    </reg>

    <reg name="ctrl" protect="rw">
        <bits name="start"    pos="0"     access="rw" rst="0">
            <comment>this is a pulse signal
            </comment>
        </bits>
        <bits name="stop"    pos="1"     access="rw" rst="0">
            <comment>this is a pulse signal
            </comment>
        </bits>
        <bits name="load_en"   pos="2"     access="rw" rst="0">
            <comment>hardware enable and software clear.
            </comment>
        </bits>
    </reg>

    <reg name="code0_reg" protect="rw"  >
        <bits name="code0" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 0 output.
            </comment>
        </bits>
    </reg>

    <reg name="code1_reg" protect="rw"  >
        <bits name="code1" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 1 output.
            </comment>
        </bits>
    </reg>

    <reg name="code2_reg" protect="rw"  >
        <bits name="code2" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 2 output.
            </comment>
        </bits>
    </reg>

    <reg name="code3_reg" protect="rw"  >
        <bits name="code3" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 3 output.
            </comment>
        </bits>
    </reg>

    <reg name="code4_reg" protect="rw"  >
        <bits name="code4" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 4 output.
            </comment>
        </bits>
    </reg>

    <reg name="code5_reg" protect="rw"  >
        <bits name="code5" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 5 output.
            </comment>
        </bits>
    </reg>

    <reg name="code6_reg" protect="rw"  >
        <bits name="code6" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 6 output.
            </comment>
        </bits>
    </reg>

    <reg name="code7_reg" protect="rw"  >
        <bits name="code7" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 7 output.
            </comment>
        </bits>
    </reg>

    <reg name="code8_reg" protect="rw"  >
        <bits name="code8" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 8 output.
            </comment>
        </bits>
    </reg>

    <reg name="code9_reg" protect="rw"  >
        <bits name="code9" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 9 output.
            </comment>
        </bits>
    </reg>

    <reg name="code10_reg" protect="rw"  >
        <bits name="code10" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 10 output.
            </comment>
        </bits>
    </reg>

    <reg name="code11_reg" protect="rw"  >
        <bits name="code11" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 11 output.
            </comment>
        </bits>
    </reg>

    <reg name="code12_reg" protect="rw"  >
        <bits name="code12" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 12 output.
            </comment>
        </bits>
    </reg>

    <reg name="code13_reg" protect="rw"  >
        <bits name="code13" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 13 output.
            </comment>
        </bits>
    </reg>

    <reg name="code14_reg" protect="rw"  >
        <bits name="code14" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 14 output.
            </comment>
        </bits>
    </reg>

    <reg name="code15_reg" protect="rw"  >
        <bits name="code15" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 15 output.
            </comment>
        </bits>
    </reg>

    <reg name="code16_reg" protect="rw"  >
        <bits name="code16" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 16 output.
            </comment>
        </bits>
    </reg>

    <reg name="code17_reg" protect="rw"  >
        <bits name="code17" pos="17:0"   access="rw" rst="18'h0">
            <comment> pattern 17 output.
            </comment>
        </bits>
    </reg>


    <reg name="pin_oen0_reg" protect="rw" > 
        <bits name="pin_oen0" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 0 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen1_reg" protect="rw"  >
        <bits name="pin_oen1" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 1 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen2_reg" protect="rw"  >
        <bits name="pin_oen2" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 2 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen3_reg" protect="rw"  >
        <bits name="pin_oen3" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 3 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen4_reg" protect="rw"  >
        <bits name="pin_oen4" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 4 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen5_reg" protect="rw"  >
        <bits name="pin_oen5" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 5 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen6_reg" protect="rw"  >
        <bits name="pin_oen6" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 6 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen7_reg" protect="rw"  >
        <bits name="pin_oen7" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 7 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen8_reg" protect="rw"  >
        <bits name="pin_oen8" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 8 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen9_reg" protect="rw"  >
        <bits name="pin_oen9" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 9 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen10_reg" protect="rw"  >
        <bits name="pin_oen10" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 10 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen11_reg" protect="rw"  >
        <bits name="pin_oen11" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 11 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen12_reg" protect="rw"  >
        <bits name="pin_oen12" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 12 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen13_reg" protect="rw"  >
        <bits name="pin_oen13" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 13 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen14_reg" protect="rw"  >
        <bits name="pin_oen14" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 14 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen15_reg" protect="rw"  >
        <bits name="pin_oen15" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 15 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen16_reg" protect="rw"  >
        <bits name="pin_oen16" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 16 of pin_oen.
            </comment>
        </bits>
    </reg>

    <reg name="pin_oen17_reg" protect="rw"  >
        <bits name="pin_oen17" pos="17:0"   access="rw" rst="18'h3ffff">
            <comment> pattern 17 of pin_oen.
            </comment>
        </bits>
    </reg>


</module>
</archive>
<archive relative = "spi.xml">
<var name = "SPI_TX_FIFO_SIZE" value="16"/>
<var name = "SPI_RX_FIFO_SIZE" value="16"/>

<module name="spi" category="Periph">
    <reg name="ctrl" protect="rw">
        <bits name="Enable"  pos="0" access="rw" rst="0">
            <comment>Enable the module and activate the chip select selected by CS_sel field.
            </comment>
        </bits>
        <bits name="CS_sel" pos="2:1" access="rw" rst="0">
            <comment>Selects the active CS.
            </comment>
            <options>
                <option name="CS0" value="0"/>
                <option name="CS1" value="1"/>
                <option name="CS2" value="2"/>
                <option name="CS3" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Input_mode" pos="4" access="rw"  rst="1">
            <comment>When set to 1 the inputs are activated, else only the output is driven and no data are stored in the receive FIFO.
                <br/>Notes: The Input_mode bit status is also readable onto the bit rxtx_buffer[31].
            </comment>
        </bits>
        <bits name="Clock_Polarity" pos="5" access="rw" rst="1">
            <comment>The spi clock polarity
                <br/>when '0' the clock disabled level is low, and the first edge is a rising edge.
                <br/>When '1' the clock disabled level is high, and the first edge is a falling edge.
            </comment>
        </bits>
        <bits name="Clock_Delay" pos="7:6" access="rw" rst="3">
            <comment>Transfer start to first edge delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first clock edge.
            </comment>
        </bits>
        <bits name="DO_Delay" pos="9:8" access="rw" rst="3">
            <comment>Transfer start to first data out delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first data out
            </comment>
        </bits>
        <bits name="DI_Delay" pos="11:10" access="rw" rst="3">
            <comment>Transfer start to first data in sample delay value from 0 to 3 is the number of spi clock half period between the CS activation and the first data in sampled.
                <br/>NOTE: DI_Delay must be less or equal to DO_Delay + CS_Delay + 2.
                <br/>In other words DI_Delay can be 3 only if DO_Delay and CS_Delay are not both equal to 0.
            </comment>
        </bits>
        <bits name="CS_Delay" pos="13:12" access="rw" rst="3">
            <comment>Transfer end to chip select deactivation delay value from 0 to 3 is the number of spi clock half period between the end of transfer and CS deactivation
            </comment>
        </bits>
        <bits name="CS_Pulse" pos="15:14" access="rw" rst="3">
            <comment>Chip select deactivation to reactivation minimum delay value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new CS activation (CS will activate only if more data are available in the transmit FIFO)
            </comment>
        </bits>
        <bits name="Frame_Size" pos="21:16" access="rw" rst="63">
            <comment>Frame Size
                <br/>The frame size is the binary value of this register + 1 valid value are 3 to 63 (frame size 4 to 64bits)
            </comment>
        </bits>
        <bits name="OE_delay" pos="28:23" access="rw" rst="63">
            <comment>OE delay
                <br/>When 0: regular mode, SPI_DO pin as output only.
                <br/>Value from 1 to 63 is the number of data out to transfert before the SPI_DO pin switch to input.
            </comment>
        </bits>
        <bits name="ctrl_data_mux_sel" pos="29" access="rw" rst="0">
            <comment>Selects the active CS and Input_reg either from the ctrl or rxtx_buffer register.
                <br/>If SPI FIFO 8b or 32b, when set to "0": CS from CS_sel and INPUT from Input_mode in the register ctrl.
                <br/>Only if SPI FIFO 32b, when set to "1": CS and INPUT from SPI DATA.(Do not work for FIFO8b)
            </comment>
            <options>
                <option name="Ctrl_reg_sel"  value="0"/>
                <option name="Data_reg_sel"  value="1"/>
                <default/><shift/><mask/>
            </options>            
        </bits>
        
        <bits name="Input_sel" pos="31:30" access="rw" rst="0">
            <comment>Selects the input line to be used as SPI data in.(Not used for SPI3)
                <br/>when "00" the SPI_DI_0 is used.
                <br/>When "01" the SPI_DI_1 is used.
                <br/>When "10" the SPI_DI_2 is used. 
                <br/>When "11" reserved.
            </comment>
        </bits>
        
    </reg>
        
    <reg name="status" protect="rw">

        <bits name="Active_Status" pos="0" access="r" rst="0">
            <comment>'1' when a transfer is in progress.
            </comment>
        </bits>
        <bits name="Cause_Rx_Ovf_Irq" pos="3" access="rw" rst="0">
            <comment>The receive FIFO overflow irq cause.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Th_Irq" pos="4" access="r" rst="0">
            <comment>The transmit FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Tx_Dma_Irq" pos="5" access="rw" rst="0">
            <comment>The transmit Dma Done irq cause.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Th_Irq" pos="6" access="r" rst="0">
            <comment>The receive FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name="Cause_Rx_Dma_Irq" pos="7" access="rw" rst="0">
            <comment>The receive Dma Done irq cause.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits>
        <bitgroup name="Irq_Cause">
            <entry ref="Cause_Rx_Ovf_Irq"/>
            <entry ref="Cause_Tx_Th_Irq"/>
            <entry ref="Cause_Tx_Dma_Irq"/>
            <entry ref="Cause_Rx_Th_Irq"/>
            <entry ref="Cause_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Ovf" pos="9" access="rw" rst="0">
            <comment>The transmit FIFO overflow status.
                <br/>Writing a '1' clear the transmit overflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Udf" pos="10" access="rw" rst="0">
            <comment>The receive FIFO underflow status.
                <br/>Writing a '1' clear the receive underflow status and cause.
            </comment>
        </bits>
        <bits name="Rx_Ovf" pos="11" access="rw" rst="0">
            <comment>The receive FIFO overflow status.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Th" pos="12" access="r" rst="0">
            <comment>The transmit FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Tx_Dma_Done" pos="13" access="rw" rst="0">
            <comment>The transmit Dma Done status.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Rx_Th" pos="14" access="r" rst="0">
            <comment>The receive FIFO threshold status.
            </comment>
        </bits> 
        <bits name="Rx_Dma_Done" pos="15" access="rw" rst="0">
            <comment>The receive Dma Done status.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits> 
        <bits name="Tx_Space" pos="20:16" access="r" rst="16" >
            <comment>Transmit FIFO Space
                <br/>Number of empty spot in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="Rx_Level" pos="28:24" access="r" rst="0">
            <comment>Receive FIFO level
                <br/>Number of DATA in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name="FIFO_Flush" pos="30" access="w" rst="0">
            <comment>Writing '1' flush both FIFO, don't do it when SPI is active (transfer in progress)
            </comment>
        </bits>
    </reg>
    <reg name="rxtx_buffer" protect="--">
        <comment>Spi1 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi2 fifo size (rxtx_buffer): 8bits.<br/>
                 Spi3 fifo size (rxtx_buffer): 32bits.<br/>

        </comment>
        <bits name="DATA_IN_OUT" pos="28:0" access="rw" rst="0">
            <comment>Write to the transmit FIFO
	    Read in the receive FIFO.
            </comment>
        </bits>
        
        <bits name="CS" pos="30:29" access="rw" rst="0">
            <comment>
                Chip Select on which write the data written in the
                Fifo. 
		Data in bit [30:29]
		Data out bit [30:29]
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

        <bits name="READ_ENA" pos="31" access="rw" rst="0">
            <comment>
                Set this bit to one when the data received while sending
                this peculiar data are expected to be kept in the FIFO,
                otherwise no data is recorded in the FIFO.
		Data in bit [31]
		Data out bit [31]
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>
    <reg name="cfg" protect="rw">
        <bits name="CS_Polarity" pos="2:0" access="rw" rst="all1" cut="1" cutprefix="CS_Polarity">
            <comment>Chip select polarity
            </comment>
            <options>
                <option name="active high" value="0"><comment>chip select is active high</comment></option>
                <option name="active low" value="1"><comment>chip select is active low</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name="Clock_Divider" pos="25:16" access="rw" rst="0x3ff">
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1.
                <br/>So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Clock_Limiter" pos="28" access="rw" rst="1">
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>

    <reg name="pattern" protect="rw">
        <bits name="pattern" pos="7:0" access="rw" rst="0">
            <comment>MMC Pattern value for RX pattern match mode.
            </comment>
        </bits>
        <bits name="pattern_mode" pos="8" access="rw" rst="0">
            <comment> Enable the pattern mode.
            </comment>
            <options>
                <option name="disabled" value="0"><comment>Spi Behaviour.</comment></option>
                <option name="enabled" value="1"><comment>Pattern matching.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="pattern_selector" pos="9" access="rw" rst="0">
            <comment> Select the RX pattern matching mode when the pattern_mode is enabled( set 1). Used for SD/MMC SPI mode.</comment>
            <options>
                <option name="UNTIL" value="0"><comment>No datas are written into the RX FIFO UNTIL the received data is equal to the pattern.</comment></option>
                <option name="WHILE" value="1"><comment>No datas are written into the RX FIFO WHILE the received data is equal to the pattern.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    
    <reg name="stream" protect="rw">
        <bits name="tx_stream_bit" pos="0" access="rw" rst="0">
            <comment>When TX stream mode is enabled, once the TX fifo is empty, all new bits send have the value of this bit.
            </comment>
            <options>
                <option name="zero" value="0"/>
                <option name="one" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_mode" pos="8" access="rw" rst="0">
            <comment>Enable the TX stream mode. Used for SD/MMC SPI mode.
                <br/>When enabled, this mode provide infinite bit stream for sending, after fifo is empty the extra bits generated all have the same value. The value is in tx_stream_bit.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="tx_stream_stop_with_rx_dma_done" pos="16" access="rw" rst="0">
            <comment>Allow to automatically clear the tx_stream_mode when Rx_Dma_Done is set.
            </comment>    
            <options>
                <option name="disabled" value="0"/>
                <option name="enabled" value="1"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name="pin_control" protect="rw">
        <bits name="clk_ctrl" pos="1:0" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_Clk pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_Clk pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_Clk pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_Clk pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="do_ctrl" pos="3:2" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_DO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_DO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_DO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_DO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>            
        </bits>
        <bits name="cs0_ctrl" pos="5:4" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CSO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CSO pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CSO pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CSO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>               
        </bits>        
        <bits name="cs1_ctrl" pos="7:6" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS1 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS1 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS1 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS1 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits>
        <bits name="cs2_ctrl" pos="9:8" access="rw" rst="0">
            <options>
                <option name="Spi Ctrl" value="0"><comment>The Spi_CS2 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name="Input Ctrl" value="1"><comment>The Spi_CS2 pin is set INPUT (High Impedance).</comment></option>
                <option name="Force 0 Ctrl" value="2"><comment>The Spi_CS2 pin is set OUTPUT and forced to 0.</comment></option>
                <option name="Force 1 Ctrl" value="3"><comment>The Spi_CS2 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
         
    </reg>
    <reg name="irq" protect="rw">
        <bits name="Mask_Rx_ovf_Irq" pos="0" access="rw" rst="0">
            <comment>Mask the receive FIFO overflow irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Th_Irq" pos="1" access="rw" rst="0">
            <comment>Mask the transmit FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Tx_Dma_Irq" pos="2" access="rw" rst="0">
            <comment>Mask the transmit Dma Done irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Th_Irq" pos="3" access="rw" rst="0">
            <comment>Mask the receive FIFO threshold irq
            </comment>
        </bits>
        <bits name="Mask_Rx_Dma_Irq" pos="4" access="rw" rst="0">
            <comment>Mask the receive DMA Done irq
            </comment>
        </bits>
        <bitgroup name="Irq_Mask">
            <entry ref="Mask_Rx_ovf_Irq"/>
            <entry ref="Mask_Tx_Th_Irq"/>
            <entry ref="Mask_Tx_Dma_Irq"/>
            <entry ref="Mask_Rx_Th_Irq"/>
            <entry ref="Mask_Rx_Dma_Irq"/>
        </bitgroup>
        <bits name="Tx_Threshold" pos="6:5" access="rw" rst="3">
            <comment>Transmit FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Empty Slot" value="0"/>
                <option name="4 Empty Slots" value="1"/>
                <option name="8 Empty Slots" value="2"/>
                <option name="12 Empty Slots" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name="Rx_Threshold" pos="8:7" access="rw" rst="3">
            <comment>Receive FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name="1 Valid Data" value="0"/>
                <option name="4 Valid Data" value="1"/>
                <option name="8 Valid Data" value="2"/>
                <option name="12 Valid Data" value="3"/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>

</module>
</archive>
<archive relative = "spi_flash.xml">
<module name="spi_flash" category="System">

    <reg name="spi_cmd_addr" protect="rw">
		<bits access="rw" name="spi_tx_cmd" pos="7:0" rst="all0">           
			<comment> spi flash command to send. 
			</comment>
		</bits>
		<bits access="rw" name="spi_address" pos="31:8" rst="all0">           
			<comment> spi flash address to send. 
			</comment>
		</bits>
     </reg>
	 <reg name="spi_block_size" protect="rw">
		<bits access="rw" name="spi_modebit" pos="7:0" rst="all0">           
			<comment> spi flash modebit,set 0xA0 to enable continuous read. 
			</comment>
		</bits>
		<bits access="rw" name="spi_rw_blk_size" pos="16:8" rst="0x1">           
			<comment> spi flash spi read/write block size. 
			</comment>
        </bits>
		<bits access="rw" name="continuous enable" pos="24" rst="0x0">           
        </bits>
     </reg>
     <reg name="spi_data_fifo" protect="w">
		<bits access="w" name="spi_tx_data" pos="7:0" rst="all0">           
			<comment> spi flash data to send. 
			</comment>
		</bits>
		<bits access="w" name="spi_send_type" pos="8" rst="0x0">           
			<comment> spi send byte, 1: quad send 0: spi send. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_fifo_status" protect="r">
		<bits access="r" name="spi_flash_busy" pos="0" rst="0x0">           
			<comment> spi flash busy. 
			</comment>
		</bits>
		<bits access="r" name="tx_fifo_empty" pos="1" rst="0x1">           
			<comment> tx fifo empty. 
			</comment>
		</bits>
		<bits access="r" name="tx_fifo_full" pos="2" rst="0x0">           
			<comment> tx fifo full. 
			</comment>
		</bits>
		<bits access="r" name="rx_fifo_empty" pos="3" rst="0x1">           
			<comment> rx fifo empty. 
			</comment>
		</bits>
		<bits access="r" name="rx_fifo_count" pos="8:4" rst="all0">           
			<comment> rx fifo data count. 
			</comment>
		</bits>
		<bits access="r" name="read_state_busy" pos="9" rst="0">           
		</bits>
		<bits access="r" name="main_fsm_idle" pos="10" rst="0">           
		</bits>
     </reg>

     <reg name="spi_read_back" protect="r">
		<bits access="r" name="spi_read_back_reg" pos="31:0" rst="all0">           
			<comment> spi flash read back data. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_config" protect="rw">
		<bits access="rw" name="quad_mode" pos="0" rst="0x0">           
			<comment> spi flash read mode from AHB. 
			</comment>
			<options>
            <option name="spi_read"  value ="0"></option>
            <option name="quad_read" value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_wprotect_pin" pos="1" rst="0x0">           
			<comment> spi flash wprotect pin. 
			</comment>
		</bits>
		<bits access="rw" name="spi_hold_pin" pos="2" rst="0x0">           
			<comment> spi flash hold pin. 
			</comment>
		</bits>
		<bits access="rw" name="winbond_xm_chip" pos="3" rst="0x0">           
			<comment> device is winbond or xm chip. 
			</comment>
		</bits>
		<bits access="rw" name="sample_delay" pos="6:4" rst="0x2">           
			<comment> spi flash read sample delay cycles. 
			</comment>
		</bits>
		<bits access="rw" name="bypass_start_read" pos="7" rst="0x0">           
		</bits>
		<bits access="rw" name="clk_divider" pos="15:8" rst="0x8">           
			<comment> spi flash clock divider. 
			</comment>
		</bits>
		<bits access="rw" name="cmd_quad" pos="16" rst="0x0">           
			<comment> spi flash send command using quad lines. 
			</comment>
        </bits>
		<bits access="rw" name="tx_rx_size" pos="18:17" rst="0x0">           
        </bits>
     </reg>

     <reg name="spi_fifo_control" protect="w">
		<bits access="w" name="rx_fifo_clr" pos="0" rst="0x0">           
			<comment> rx fifo_clr,self clear. 
			</comment>
		</bits>
		<bits access="w" name="tx_fifo_clr" pos="1" rst="0x0">           
			<comment> tx fifo_clr,self clear. 
			</comment>
		</bits>
     </reg>

     <reg name="spi_cs_size" protect="rw">
		<bits access="rw" name="spi_cs_num" pos="0" rst="0x0">           
			<comment> spi flash cs num. 
			</comment>
			<options>
            <option name="1 spiflash"  value ="0"></option>
            <option name="2 spiflash"  value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi size" pos="2:1" rst="all0">           
			<comment> single chip spi flash size. 
			</comment>
			<options>
            <option name="32m"  value ="0"></option>
            <option name="64m"  value ="1"></option>
            <option name="16m"  value ="2"></option>
            <option name="8m"   value ="3"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_128m" pos="3" rst="0x0">           
			<comment> spi flash is 128m flash. 
			</comment>
			<options>
            <option name="other spiflash"  value ="0"></option>
            <option name="128m  spiflash"  value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="SEL_FLASH_1_SEL" pos="5" rst="0x0">           
		<options>
            <option name="flash 0"  value ="0"></option>
            <option name="flash 1" value ="1"></option>
        	</options>
		</bits>
		<bits access="rw" name="spi_cs1_sel1" pos="6" rst="0x0">           
		</bits>
		<bits access="rw" name="diff_128m_diff_cmd_en" pos="7" rst="0x0">           
		</bits>
    </reg>

    <reg name="spi_read_cmd" protect="rw">
		<bits access="rw" name="qread_cmd" pos="7:0" rst="8'heb">           
			<comment> quad read command. 
			</comment>
		</bits>
		<bits access="rw" name="fread_cmd" pos="15:8" rst="8'h0b">           
			<comment> fast read command. 
			</comment>
		</bits>
		<bits access="rw" name="read_cmd" pos="23:16" rst="8'h03">           
			<comment> read command. 
			</comment>
		</bits>
		<bits access="w" name="protect_byte" pos="31:24" rst="all0">           
			<comment> protect_byte, must be 0x55 when program this register. 
			</comment>
		</bits>
    </reg>
    
    <reg name="spi_flash_24" protect="rw">
		<bits access="rw" name="nand_sel" pos="0" rst="all0">           
		</bits>
		<bits access="rw" name="nand_addr" pos="2:1" rst="all0">           
		</bits>
		<bits access="rw" name="page_read_cmd" pos="15:8" rst="8'h13">           
        </bits>
		<bits access="rw" name="get_sts_cmd" pos="23:16" rst="8'h0f">           
        </bits>
		<bits access="rw" name="ram_read_cmd" pos="31:24" rst="8'h03">           
        </bits>
    </reg>

    <reg name="spi_flash_28" protect="rw">
		<bits access="rw" name="get_sts_addr" pos="7:0" rst="8'hc0">           
		</bits>
		<bits access="rw" name="program_exe_cmd" pos="15:8" rst="8'h10">           
        </bits>
		<bits access="rw" name="sts_qip" pos="23:16" rst="8'h01">           
        </bits>
    </reg>

    <reg name="spi_flash_2c" protect="rw">
		<bits access="rw" name="four_byte_addr" pos="0" rst="all0">           
		</bits>
		<bits access="rw" name="dummy_cycle_en" pos="1" rst="all0">           
		</bits>
		<bits access="rw" name="dummy_cycle" pos="11:8" rst="8'h08">           
        </bits>
    </reg>

    <reg name="spi_flash_30" protect="rw">
		<bits access="rw" name="first_128m_cmd" pos="7:0" rst="0x8c">           
		</bits>
		<bits access="rw" name="second_128m_cmd" pos="15:8" rst="0x8d">           
        </bits>
		<bits access="rw" name="third_128m_cmd" pos="23:16" rst="8'h0">           
        </bits>
		<bits access="rw" name="fourth_128m_cmd" pos="31:24" rst="8'h0">           
        </bits>
    </reg>
     
    <reg name="timeout_value" protect="rw">
		<bits access="rw" name="timeout_value" pos="31:0" rst="32'h4000">           
		</bits>
    </reg>

    <reg name="ahb_flash_ctrl" protect="rw">
        <bits access="rw" name="ahb_read" pos="0" rst="0x0">           
			<comment> disable read from ahb. 
			</comment>
			<options>
            <option name="enable"  value ="0"></option>
            <option name="disable" value ="1"></option>
        	</options>
        </bits>
    </reg>

    <reg name="sus_time_ctrl" protect="rw">
        <bits access="rw" name="tsus_value" pos="15:0" rst="1000">
        </bits>
        <bits access="rw" name="tres_value" pos="31:16" rst="10">
        </bits>
    </reg>

    <reg name="flash_irq" protect="rw">
        <bits access="rc" name="pr_er_done_cause" pos="0" rst="0">
        </bits>
        <bits access="rc" name="pr_er_done_status" pos="16" rst="0">
        </bits>
    </reg>

    <reg name="flash_irq_mask" protect="rw">
        <bits access="rw" name="pr_er_done_mask" pos="0" rst="0">
        </bits>
    </reg>

     
</module>


</archive>
<archive relative = "sys_ctrl.xml">

<module name="sys_ctrl" category="System">

  <reg name="chip_id" protect="r">
    <bits access="r" name="major_id" pos="31:18" rst="0x22CD">
    </bits>
    <bits access="r" name="minor_id" pos="17:13" rst="0x1">
    </bits>
    <bits access="r" name="bond_id" pos="12:12" rst="0x0">
    </bits>
    <bits access="r" name="metal_id" pos="11:0" rst="0x0">
    </bits>
  </reg>

  <reg name="reg_dbg" protect="rw">
    <bits access="rw" name="scratch" pos="15:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_rst_set0" protect="rw">
    <bits access="w1s" name="set_rst_global" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_iomux" pos="28:28" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gpt2" pos="27:27" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gpt1" pos="26:26" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gpio" pos="25:25" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2c3" pos="24:24" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2c2" pos="23:23" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2c1" pos="22:22" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_spi2" pos="20:20" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_spi1" pos="19:19" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_uart3" pos="17:17" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_uart2" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_uart1" pos="15:15" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_i2s" pos="14:14" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_flash" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_mailbox" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_wdt" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_timer" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_ifc" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sys_dma" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_mcu" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="sys_rst_clr0" protect="rw">
    <bits access="rw1c" name="clr_rst_iomux" pos="28:28" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gpt2" pos="27:27" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gpt1" pos="26:26" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gpio" pos="25:25" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2c3" pos="24:24" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2c2" pos="23:23" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2c1" pos="22:22" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_spi2" pos="20:20" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_spi1" pos="19:19" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_uart3" pos="17:17" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_uart2" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_uart1" pos="15:15" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_i2s" pos="14:14" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_flash" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_mailbox" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_wdt" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_timer" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_ifc" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sys_dma" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_mcu" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="sys_rst_set1" protect="rw">
    <bits access="rw1s" name="set_rst_aes" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_lzma" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_page_spy" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_cau_dig" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_wcn_rfif" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bt_core" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sdmmc2" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_seg_lcd" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_keypad" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="sys_rst_clr1" protect="rw">
    <bits access="rw1c" name="clr_rst_aes" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_lzma" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_page_spy" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_cau_dig" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_wcn_rfif" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bt_core" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sdmmc2" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_seg_lcd" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_keypad" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="bb_rst_set0" protect="rw">
    <bits access="rw1s" name="set_rst_bb" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_nbiot" pos="28:28" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_a53" pos="27:27" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_cipher" pos="26:26" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_cholk" pos="25:25" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_excor" pos="24:24" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_vitac" pos="23:23" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_itlv" pos="22:22" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_cordic" pos="21:21" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_xcor" pos="20:20" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gea3" pos="17:17" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_f8" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_rf_if" pos="15:15" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_nb_rfspi" pos="14:14" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gsm_rfspi" pos="13:13" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_nb_tcu" pos="12:12" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_gsm_tcu" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sci2" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_sci1" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bb_ifc" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bb_wdt" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bb_timer" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bb_irq" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bb_dma" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_cp2" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_bcpu" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="bb_rst_clr0" protect="rw">
    <bits access="rw1c" name="clr_rst_bb" pos="31:31" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_nbiot" pos="28:28" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_a53" pos="27:27" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_cipher" pos="26:26" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_cholk" pos="25:25" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_excor" pos="24:24" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_vitac" pos="23:23" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_itlv" pos="22:22" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_cordic" pos="21:21" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_xcor" pos="20:20" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gea3" pos="17:17" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_f8" pos="16:16" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_rf_if" pos="15:15" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_nb_rfspi" pos="14:14" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gsm_rfspi" pos="13:13" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_nb_tcu" pos="12:12" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_gsm_tcu" pos="11:11" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sci2" pos="10:10" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_sci1" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bb_ifc" pos="7:7" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bb_wdt" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bb_timer" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bb_irq" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bb_dma" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_cp2" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_bcpu" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="bb_rst_set1" protect="rw">
    <bits access="rw1s" name="set_rst_bb_pagespy" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_ca_if" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_rffe" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_dfe" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_ca" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_rf_interface" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1s" name="set_rst_dbg" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="bb_rst_clr1" protect="rw">
    <bits access="rw1c" name="clr_rst_bb_pagespy" pos="6:6" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_ca_if" pos="5:5" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_rffe" pos="4:4" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_dfe" pos="3:3" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_ca" pos="2:2" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_rf_interface" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw1c" name="clr_rst_dbg" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="clk_sys_enable0" protect="rw">
    <bits access="rw1s" name="enable_iomux" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gpt2" pos="27:27" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gpt1" pos="26:26" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gpio" pos="25:25" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2c3" pos="24:24" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2c2" pos="23:23" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2c1" pos="22:22" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_spi2" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_spi1" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_uart3" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_uart2" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_uart1" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_i2s" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_flash" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_mailbox" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_wdt" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_timer" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_ifc" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sys_dma" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_mcu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_sys_disable0" protect="rw">
    <bits access="rw1c" name="disable_iomux" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gpt2" pos="27:27" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gpt1" pos="26:26" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gpio" pos="25:25" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2c3" pos="24:24" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2c2" pos="23:23" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2c1" pos="22:22" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_spi2" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_spi1" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_uart3" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_uart2" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_uart1" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_i2s" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_flash" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_mailbox" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_wdt" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_timer" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_ifc" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sys_dma" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_mcu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_sys_enable1" protect="rw">
    <bits access="rw1s" name="enable_aes" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_lzma" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_page_spy" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_cau_dig" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_wcn_rfif" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bt_core" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sdmmc2" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_seg_lcd" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_keypad" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_sys_disable1" protect="rw">
    <bits access="rw1c" name="disable_aes" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_lzma" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_page_spy" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_cau_dig" pos="8:8" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_wcn_rfif" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bt_core" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sdmmc2" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_seg_lcd" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_keypad" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_bb_enable0" protect="rw">
    <bits access="rw1s" name="enable_nbiot" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_a53" pos="27:27" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_cipher" pos="26:26" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_cholk" pos="25:25" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_excor" pos="24:24" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_vitac" pos="23:23" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_itlv" pos="22:22" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_cordic" pos="21:21" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_xcor" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gea3" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_f8" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_rf_if" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_nb_rfspi" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gsm_rfspi" pos="13:13" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_nb_tcu" pos="12:12" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_gsm_tcu" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sci2" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_sci1" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bb_ifc" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bb_wdt" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bb_timer" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bb_irq" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bb_dma" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_cp2" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_bcpu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_bb_disable0" protect="rw">
    <bits access="rw1c" name="disable_nbiot" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_a53" pos="27:27" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_cipher" pos="26:26" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_cholk" pos="25:25" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_excor" pos="24:24" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_vitac" pos="23:23" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_itlv" pos="22:22" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_cordic" pos="21:21" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_xcor" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gea3" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_f8" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_rf_if" pos="15:15" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_nb_rfspi" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gsm_rfspi" pos="13:13" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_nb_tcu" pos="12:12" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_gsm_tcu" pos="11:11" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sci2" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_sci1" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bb_ifc" pos="7:7" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bb_wdt" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bb_timer" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bb_irq" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bb_dma" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_cp2" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_bcpu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_bb_enable1" protect="rw">
    <bits access="rw1s" name="enable_bb_pagespy" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_ca_if" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_rffe" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_dfe" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_ca" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_rf_interface" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="enable_dbg" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="clk_bb_disable1" protect="rw">
    <bits access="rw1c" name="disable_bb_pagespy" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_ca_if" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_rffe" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_dfe" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_ca" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_rf_interface" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="disable_dbg" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="pll_ctrl" protect="rw">
    <bits access="r" name="nb_pll_locked" pos="14:14" rst="0x0">
    </bits>
    <bits access="rw1c" name="nb_pll_pd" pos="13:13" rst="0x0">
    </bits>
    <bits access="rw1s" name="nb_pll_pu" pos="12:12" rst="0x0">
    </bits>
    <bits access="r" name="gsm_pll_locked" pos="10:10" rst="0x0">
    </bits>
    <bits access="rw1c" name="gsm_pll_pd" pos="9:9" rst="0x0">
    </bits>
    <bits access="rw1s" name="gsm_pll_pu" pos="8:8" rst="0x0">
    </bits>
    <bits access="r" name="bb_pll_locked" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="bb_pll_pd" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1s" name="bb_pll_pu" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="mcu_pll_locked" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="mcu_pll_pd" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1s" name="mcu_pll_pu" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sel_clock_sys" protect="rw">
    <bits access="rw" name="sel_clk_bt_modem_tx" pos="18:17" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_bt_master" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_uart3" pos="15:14" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_uart2" pos="13:12" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_uart1" pos="11:10" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_spiflash" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_psram" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_lp" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="sel_clk_sys" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_sys_slow" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sel_clock_bb" protect="rw">
    <bits access="rw" name="sel_clk_dbg" pos="11:10" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_nb_tcu" pos="9:9" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_gsm_tcu" pos="8:8" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_bb" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw" name="sel_clk_bb_slow" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_sys" protect="rw">
    <bits access="rw" name="sys_div_denom" pos="18:10" rst="0x4">
    </bits>
    <bits access="rw" name="sys_div_num" pos="8:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_bb" protect="rw">
    <bits access="rw" name="bb_ahb_stb_denom" pos="25:22" rst="0x1">
    </bits>
    <bits access="rw" name="bb_ahb_stb_num" pos="21:18" rst="0x1">
    </bits>
    <bits access="rw" name="bb_div_denom" pos="17:9" rst="0x4">
    </bits>
    <bits access="rw" name="bb_div_num" pos="8:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_psram" protect="rw">
    <bits access="rw" name="psram_freq" pos="3:0" rst="0xd">
      <options>
      <option name="256Mhz" value="14"/>
      <option name="192Mhz" value="13"/>
      <option name="154Mhz" value="12"/>
      <option name="128Mhz" value="11"/>
      <option name="110Mhz" value="10"/>
      <option name="96Mhz"  value="9 "/>
      <mask/>
      <shift/>
      </options>
    </bits>
  </reg>

  <reg name="cfg_clk_spiflash" protect="rw">
    <bits access="rw" name="spiflash_freq" pos="3:0" rst="0xd">
      <options>
      <option name="256Mhz" value="14"/>
      <option name="192Mhz" value="13"/>
      <option name="154Mhz" value="12"/>
      <option name="128Mhz" value="11"/>
      <option name="110Mhz" value="10"/>
      <option name="96Mhz"  value="9 "/>
      <mask/>
      <shift/>
      </options>
    </bits>
  </reg>

  <reg name="cfg_clk_dbg" protect="rw">
    <bits access="rw" name="dbg_div_denom" pos="23:10" rst="0xE">
    </bits>
    <bits access="rw" name="dbg_div_num" pos="9:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_uart" protect="rw" count="3">
    <bits access="rw" name="uart_div_denom" pos="23:10" rst="0xE">
    </bits>
    <bits access="rw" name="uart_div_num" pos="9:0" rst="0x1">
    </bits>
  </reg>

  <reg name="cfg_clk_rsvd" protect="rw">
    <bits access="rw" name="cfg_clk_rsvd" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_dblr" protect="rw">
    <bits access="rw" name="pu_osc26m" pos="27:27" rst="0x1">
    </bits>
    <bits access="rw" name="pu_clkdblr" pos="26:26" rst="0x1">
    </bits>
    <bits access="rw" name="clkdblr_clk_en" pos="25:25" rst="0x1">
    </bits>
    <bits access="rw" name="clkdblr_r_ctrl" pos="24:22" rst="0x0">
    </bits>
    <bits access="rw" name="clkdblr_vbias_ctrl" pos="21:20" rst="0x0">
    </bits>
    <bits access="rw" name="clkdblr_ibias_ctrl" pos="19:18" rst="0x0">
    </bits>
    <bits access="rw" name="lp_dblr_div_denom" pos="17:12" rst="0x2">
    </bits>
    <bits access="rw" name="bb_dblr_div_denom" pos="11:6" rst="0x2">
    </bits>
    <bits access="rw" name="sys_dblr_div_denom" pos="5:0" rst="0x2">
    </bits>
  </reg>

  <reg name="cfg_clk_i2s" protect="rw">
    <bits access="rw" name="i2s_div_denom" pos="15:0" rst="0x7D">
    </bits>
  </reg>

  <reg name="cfg_clk_out" protect="rw">
    <bits access="rw" name="clkout3_en" pos="31:31" rst="0x0">
    </bits>
    <bits access="rw" name="clkout2_en" pos="30:30" rst="0x0">
    </bits>
    <bits access="rw" name="clkout1_en" pos="29:29" rst="0x0">
    </bits>
    <bits access="rw" name="clkout0_en" pos="28:28" rst="0x0">
    </bits>
    <bits access="rw" name="clkout3_sel" pos="7:6" rst="0x0">
    </bits>
    <bits access="rw" name="clkout2_sel" pos="5:4" rst="0x0">
    </bits>
    <bits access="rw" name="clkout1_sel" pos="3:2" rst="0x0">
    </bits>
    <bits access="rw" name="clkout0_sel" pos="1:0" rst="0x0">
    </bits>
  </reg>

  <reg name="cfg_clk_trng" protect="rw">
    <bits access="rw" name="trng_div_denom" pos="5:0" rst="0x28">
    </bits>
  </reg>

  <reg name="reset_cause" protect="rw">
    <bits access="rw" name="sw_boot_mode" pos="23:20" rst="0x0">
    </bits>
    <bits access="rw" name="boot_mode" pos="19:16" rst="0x0">
        <options><mask/><shift/></options>
    </bits>
    <bits access="r" name="pin_reset" pos="8:8" rst="0x0">
    </bits>
    <bits access="r" name="bor_reset" pos="7:7" rst="0x0">
    </bits>
    <bits access="r" name="lpwdt_reset" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw1c" name="bb_wdt_reset" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw1c" name="sys_wdt_reset" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw1c" name="mcu_lockup_reset" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw1c" name="mcu_sysresetreq_reset" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw1c" name="debughost_reset" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw1c" name="globalsoft_reset" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="sys_wakeup_cause" protect="r">
    <bits access="r" name="mcu_bt_wakeup" pos="10:10" rst="0x0">
    </bits>
    <bits access="r" name="mcu_gpio_wakeup" pos="9:9" rst="0x0">
    </bits>
    <bits access="r" name="mcu_systimer_wakeup" pos="8:8" rst="0x0">
    </bits>
    <bits access="r" name="mcu_ac_on_wakeup" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="mcu_lpwdt_wakeup" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="mcu_lpuart_wakeup" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="mcu_pin_wakeup" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="mcu_sw_wakeup" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="mcu_lps_wakeup" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="mcu_rtc_wakeup" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="bb_wakeup_cause" protect="r">
    <bits access="r" name="bb_bt_wakeup" pos="10:10" rst="0x0">
    </bits>
    <bits access="r" name="bb_gpio_wakeup" pos="9:9" rst="0x0">
    </bits>
    <bits access="r" name="bb_systimer_wakeup" pos="8:8" rst="0x0">
    </bits>
    <bits access="r" name="bb_ac_on_wakeup" pos="6:6" rst="0x0">
    </bits>
    <bits access="r" name="bb_lpwdt_wakeup" pos="5:5" rst="0x0">
    </bits>
    <bits access="r" name="bb_lpuart_wakeup" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="bb_pin_wakeup" pos="3:3" rst="0x0">
    </bits>
    <bits access="r" name="bb_sw_wakeup" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="bb_lps_wakeup" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="bb_rtc_wakeup" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="misc_ctrl" protect="rw">
    <bits access="rw" name="dbg_clk_en" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_clk_sel" pos="19:16" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_trig_sel" pos="15:12" rst="0x0">
    </bits>
    <bits access="rw" name="dbg_out_sel" pos="11:8" rst="0x0">
    </bits>
    <bits access="rw" name="bb_wdt_rstn_en" pos="4:3" rst="0x0">
    </bits>
    <bits access="rw" name="sys_wdt_rstn_en" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="sysresetreq_en" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="lockup_rst_en" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mem_ctrl" protect="rw">
    <bits access="rw" name="emaw" pos="4:3" rst="0x0">
    </bits>
    <bits access="rw" name="ema" pos="2:0" rst="0x2">
    </bits>
  </reg>

  <reg name="pad_ctrl" protect="rw">
    <bits access="rw" name="ibit_simio1" pos="19:18" rst="0x0">
    </bits>
    <bits access="rw" name="ibit_simio0" pos="17:16" rst="0x0">
    </bits>
    <bits access="rw" name="ibit_gpio2" pos="15:14" rst="0x0">
    </bits>
    <bits access="rw" name="ibit_gpio1" pos="13:12" rst="0x0">
    </bits>
    <bits access="rw" name="ibit_gpio0" pos="11:10" rst="0x0">
    </bits>
    <bits access="rw" name="ibit_flash" pos="5:3" rst="0x4">
    </bits>
    <bits access="rw" name="ibit_psram" pos="2:0" rst="0x4">
    </bits>
  </reg>

  <reg name="cpu_ctrl" protect="rw">
    <bits access="r" name="bcpu_sleeping" pos="4:4" rst="0x0">
    </bits>
    <bits access="r" name="mcu_wicenack" pos="3:3" rst="0x0">
    </bits>
    <bits access="rw" name="mcu_wicenreq" pos="2:2" rst="0x0">
    </bits>
    <bits access="r" name="mcu_sleepdeep" pos="1:1" rst="0x0">
    </bits>
    <bits access="r" name="mcu_sleeping" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="otp_reg" protect="rw">
    <bits access="rw" name="otp_reg_rsvd" pos="7:2" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_jtag" pos="1:1" rst="0x0">
    </bits>
    <bits access="rw" name="force_enable_host" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mpll_setting0" protect="rw">
    <bits access="r" name="mpll_lock" pos="30:30" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_digreg_range" pos="29:26" rst="0x8">
    </bits>
    <bits access="rw" name="mpll_band_sel" pos="25:24" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_ready_timer" pos="23:22" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_rstb_dr" pos="21:21" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_rstb_reg" pos="20:20" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sel_dr" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sel_reg" pos="18:18" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_en_dr" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_en_reg" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_cpbias_rbit" pos="15:13" rst="0x4">
    </bits>
    <bits access="rw" name="mpll_cpbias_ibit" pos="12:9" rst="0x4">
    </bits>
    <bits access="rw" name="mpll_cpc2_bit" pos="8:6" rst="0x4">
    </bits>
    <bits access="rw" name="mpll_cpr2_bit" pos="5:3" rst="0x4">
    </bits>
    <bits access="rw" name="mpll_pcon_mode" pos="2:2" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_refmulti2_en" pos="1:1" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_sel" pos="0:0" rst="0x0">
    </bits>
  </reg>

  <reg name="mpll_setting1" protect="rw">
    <bits access="rw" name="mpll_rsvd_reg" pos="29:22" rst="0x1">
    </bits>
    <bits access="rw" name="mpll_testsig_sel" pos="21:20" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_int_mode" pos="19:19" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_vco_low_test" pos="18:18" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_vco_high_test" pos="17:17" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_test_en" pos="16:16" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_clk_inv" pos="6:6" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_resetn_dr" pos="5:5" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_resetn_reg" pos="4:4" rst="0x0">
    </bits>
    <bits access="rw" name="mpll_sdm_int_dec_sel" pos="3:1" rst="0x3">
    </bits>
    <bits access="rw" name="mpll_sdm_dither_bypass" pos="0:0" rst="0x1">
    </bits>
  </reg>

  <reg name="mpll_sdm_freq" protect="rw">
    <bits access="rw" name="mpll_sdm_freq" pos="31:0" rst="0x3b13b13b">
    </bits>
  </reg>

</module>
</archive>

<archive relative = "sys_ifc.xml">

<include file="globals.xml"/>



<var name="SYS_IFC_ADDR_ALIGN" value="0" />

<var name="SYS_IFC_TC_LEN" value="23" />

<var name="SYS_IFC_STD_CHAN_NB" value="SYS_IFC_NB_STD_CHANNEL" /> 

<var name="SYS_IFC_RFSPI_CHAN" value="0" />

<module name="sys_ifc" category="System">
  

  <reg protect="r" name="get_ch">
    <bits access="r" name="ch_to_use" pos="3:0" rst="0">
      <comment>This field indicates which standard channel to use.
      <br /> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br /> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br />0000 = use Channel0
      <br />0001 = use Channel1
      <br />0010 = use Channel2 
      <br /> ...
      <br />0111 = use Channel7
      <br />1111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg protect="r" name="dma_status">
    <bits access="r" name="ch_enable" pos="SYS_IFC_STD_CHAN_NB+SYS_IFC_RFSPI_CHAN-1:0" rst="0">
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br />0000_0000 = All channels disabled 
      <br />0000_0001 = Ch0 enabled 
      <br />0000_0010 = Ch1 enabled 
      <br />0000_0100 = Ch2 enabled 
      <br />0000_0101 = Ch0 and Ch2 enabled 
      <br />0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br />1111_1111 = all channels enabled</comment>
    </bits>

    <bits access="r" name="ch_busy" pos="SYS_IFC_STD_CHAN_NB-1+16:16" rst="0">
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg protect="r" name="debug_status">
    <bits access="r" name="dbg_status" pos="0" rst="1">
      <comment>Debug Channel Status .<br />0= The debug channel is running
      (not idle) <br />1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <hole size="32" />

  

  <struct count="SYS_IFC_STD_CHAN_NB" name="std_ch">
    <reg protect="rw" name="control">
      <bits access="w" name="enable" pos="0" rst="no">
        <comment>Channel Enable, write one in this bit enable the channel.
        <br />When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits access="w" name="disable" pos="1" rst="no">
        <comment>Channel Disable, write one in this bit disable the channel.
        <br />When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>


      <bits access="rw" name="ch_rd_hw_exch" pos="2" rst="0">
        <comment>Exchange the read data from fifo halfword MSB or LSB
        <br />
    </comment>
      </bits>

      <bits access="rw" name="ch_wr_hw_exch" pos="3" rst="0">
        <comment>Exchange the write data to fifo  halfword MSB or LSB
        <br />
    </comment>
      </bits>


      <bits access="rw" name="autodisable" pos="4" rst="1">
        <comment>Set Auto-disable mode<br /> 0 = when TC reach zero the
        channel is not automatically released.<br /> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits access="rw" name="Size" pos="5" rst="0">
        <comment>Peripheral Size
            <br /> 0= 8-bit peripheral
            <br /> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits access="rw" name="req_src" pos="12:8" rst="0x1F" display="hex">
        <options linkenum="Sys_Ifc_Request_IDs"> 
          
          <shift/><mask/><default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits access="rw" name="flush" pos="16" rst="0">
        <comment>When one, flush the internal FIFO channel. 
        <br />This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br /> Before writting back this bit to zero the internal fifo must empty.
        </comment>
      </bits>

        <bits access="rw" name="max_burst_length" pos="18:17" rst="00">
        <comment>Set the MAX burst length for channel 0,1. 
                 This bit field is only used in channel 0~1, for channel 2~6, it is reserved.  
        <br /> The 2'b10 mean burst max 16 2'b01 mean burst max 8, 00 mean burst max 4. 
        <br /> .
        </comment>



        
      </bits>
    </reg>

    <reg protect="r" name="status">
      <bits access="r" name="enable" pos="0" rst="0">
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits access="r" name="fifo_empty" pos="4" rst="1">
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg protect="rw" name="start_addr">
      <bits access="rw" name="start_addr"
            pos="NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN" rst="0xFFFFFFF" display="hex">
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br />For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc">
      <bits access="rw" name="tc" pos="SYS_IFC_TC_LEN-1:0" rst="0xFFFFFF" display="hex">
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br />During a transfer a write in this register add the new value to the current TC. 
        <br />A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>

    <reg protect="rw" name="tc_threshold">
      <bits access="rw" name="tc_threshold" pos="SYS_IFC_TC_LEN-1:0" rst="0x0" display="hex">
        <comment>Tx or Rx transfer Count, this field indicated the transfer size in bytes which already performed.
        </comment>
      </bits>
    </reg>
  </struct>
  
  

  
</module>

</archive>
<archive relative = "sys_mem.xml">
  <var name="SYS_ROM_SIZE"   value="96*1024" />       
  <var name="SYS_RAM_SIZE"   value="192*1024" />      
  <var name="PSRAM_SIZE"     value="4*1024*1024" />   
  <var name="FLASH_SIZE"     value="4*1024*1024" />   

  
  <module name="sys_rom" category="System">
    <memory name="rom_array" size="SYS_ROM_SIZE">
      <comment>System Rom Space
        <br/>This rom is used for XCPU boot code.
      </comment>
    </memory>
  </module>

  
  <module name="sys_ram" category="System">
    <memory name="ram_array" size="SYS_RAM_SIZE">
      <comment>System Ram Space
        <br/>
      </comment>
    </memory>
  </module>

  
  <module name="psram" category="System">
    <memory name="ram_array" size="PSRAM_SIZE">
      <comment>PSRAM Space
        <br/> In-package PSRAM
      </comment>
    </memory>
  </module>

  
  <module name="flash" category="System">
    <memory name="ram_array" size="FLASH_SIZE">
      <comment>FLASH Space
        <br/> In-package FLASH
      </comment>
    </memory>
  </module>




</archive>
<archive relative = "tcu.xml">

<module name="tcu" category="Modem">

    
    <var name="NB_TCO" value="12"/> 
    <var name="NB_TCU_PROG_EVENTS" value="60"/>

    <enum name="Internal_TCO_mapping">
        <entry name="TCO_GMSK_ON" value="6"><comment>Internal TCO mapping</comment></entry>
        <entry name="TCO_TX_OEN"/>
        <entry name="TCO_TX_ON"/>
        <entry name="TCO_RX_ON"/>
        <entry name="TCO_RX_DEC_ON"/>
        <entry name="TCO_PDN"/>
    </enum>

    <enum name="TCU_Event">
        
        <entry name="Clr_TCO_0" value="0"><comment>Clear TCO 0 : set the TCO 0 to the inactive state<br/>To clear TCO n, use event 2*n</comment></entry>
        <entry name="Set_TCO_0" value="1"><comment>Set TCO 0 : set the TCO 0 to the active state<br/>To set TCO n, use event 2*n+1</comment></entry>
        <entry name="Clr_TCO_1"><comment>...</comment></entry>
        <entry name="Set_TCO_1"/>
        <entry name="Clr_TCO_2"/>
        <entry name="Set_TCO_2"/>
        <entry name="Clr_TCO_3"/>
        <entry name="Set_TCO_3"/>
        <entry name="Clr_TCO_4"/>
        <entry name="Set_TCO_4"/>
        <entry name="Clr_TCO_5"/>
        <entry name="Set_TCO_5"/>
        
        
        <entry name="Stop_GMSK" value="TCO_GMSK_ON*2"><comment>stop modulation</comment></entry>
        <entry name="Start_GMSK" value="TCO_GMSK_ON*2+1"><comment>starts modulation and output on IQ DAC</comment></entry>
        <entry name="HighZ_IQ_DAC" value="TCO_TX_OEN*2"/>
        <entry name="Drive_IQ_DAC" value="TCO_TX_OEN*2+1"/>
        <entry name="disable_IQ_DAC" value="TCO_TX_ON*2"/>
        <entry name="enable_IQ_DAC" value="TCO_TX_ON*2+1"/>
        <entry name="disable_IQ_ADC" value="TCO_RX_ON*2"><comment>disable IQ ADC</comment></entry>
        <entry name="enable_IQ_ADC" value="TCO_RX_ON*2+1"><comment>enable IQ ADC</comment></entry>
        <entry name="stop_RFin_record" value="TCO_RX_DEC_ON*2"><comment>stop recording IQ samples</comment></entry>
        <entry name="start_RFin_record" value="TCO_RX_DEC_ON*2+1"><comment>start recording IQ samples</comment></entry>
        <entry name="Clr_PDN" value="TCO_PDN*2"><comment>Clear RF_PDN</comment></entry>
        <entry name="Set_PDN" value="TCO_PDN*2+1"><comment>Set RF_PDN</comment></entry>
        
        <entry name="SEND_SPI_CMD" value="NB_TCO*2"><comment>Send RF spi command</comment></entry>
        <entry name="NEXT_GAIN"/>
        <entry name="FIRST_GAIN"/>
        
        <entry name="NEXT_FC"/>
        
        <entry name="PA_RAMP0"><comment>Start Ramp 0</comment></entry>
        <entry name="PA_RAMP1"><comment>Start Ramp 1</comment></entry>
        <entry name="PA_RAMP2"><comment>Start Ramp 2</comment></entry>
        <entry name="PA_RAMP3"><comment>Start Ramp 3</comment></entry>
        <entry name="PA_RAMP4"><comment>Start Ramp 4</comment></entry>
        <entry name="RX_SOC"/>
        <entry name="DIGRF_STB"/>
        
        <entry name="WAKEUP_DONE"><comment>End of the WakeUp Mode</comment></entry>
        
        <entry name="RFSPI_START"><comment>Start of Rf_spi Transfer</comment></entry>
        <entry name="RFSPI_END"><comment>End of Rf_spi Transfer</comment></entry>
        
        <entry name="BCPU_TCU_IRQ0"><comment>Trigger BCPU TCU irq 0</comment></entry>
        <entry name="BCPU_TCU_IRQ1"><comment>Trigger BCPU TCU irq 1</comment></entry>
        
        <entry name="XCPU_TCU_IRQ0"><comment>Trigger XCPU TCU irq 0</comment></entry>
        <entry name="XCPU_TCU_IRQ1"><comment>Trigger XCPU TCU irq 1</comment></entry>
        <entry name="XCPU_TCU_IRQ2"><comment>Trigger XCPU TCU irq 2</comment></entry>
        <entry name="XCPU_TCU_IRQ3"><comment>Trigger XCPU TCU irq 3</comment></entry>
        <entry name="XCPU_TCU_IRQ4"><comment>Trigger XCPU TCU irq 4</comment></entry>
        <entry name="XCPU_TCU_IRQ5"><comment>Trigger XCPU TCU irq 5</comment></entry>
        <entry name="XCPU_TCU_IRQ6"><comment>Trigger XCPU TCU irq 6</comment></entry>
        <entry name="XCPU_TCU_IRQ7"><comment>Trigger XCPU TCU irq 7</comment></entry>
        <entry name="XCPU_TCU_IRQ8"><comment>Trigger XCPU TCU irq 8</comment></entry>
        <entry name="XCPU_TCU_IRQ9"><comment>Trigger XCPU TCU irq 9</comment></entry>
        <entry name="XCPU_TCU_IRQ10"><comment>Trigger XCPU TCU irq 10</comment></entry>
        <entry name="XCPU_TCU_IRQ11"><comment>Trigger XCPU TCU irq 11</comment></entry>
        <entry name="XCPU_TCU_IRQ12"><comment>Trigger XCPU TCU irq 12</comment></entry>
        <entry name="XCPU_TCU_IRQ13"><comment>Trigger XCPU TCU irq 13</comment></entry>
        <entry name="XCPU_TCU_IRQ14"><comment>Trigger XCPU TCU irq 14</comment></entry>
        <entry name="XCPU_TCU_IRQ15"><comment>Trigger XCPU TCU irq 15</comment></entry>
        
        <entry name="NO_EVENT" value="63"/> 
    </enum>

    
    <reg name="Ctrl" protect="rw">
        <bits name="Load_Val" pos="14:0" access="rw" rst="all1" display="hex">
            <comment>Value loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name="Load_Sf" pos="19:16" access="rw" rst="0" display="hex">
            <comment>Subframe alue loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name="Enable" pos="20" access="rw" rst="0">
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Load" pos="24" access="w" rst="0">
            <comment>Writing a 1 to this bit will load the TCU with the TCU loadval value
                <br/>Writing a 0 has no effect
            </comment>
        </bits>
        <bits name="NoLatch" pos="28" access="rw" rst="0">
            <options>
                <option name="Normal" value="0"><comment>Normal Behavior, The programmation area is copied to the active area when the tcu wraps</comment></option>
                <option name="Force_Only" value="1"><comment>The programmation area is copied into the active area only when force latch is used</comment></option>
            </options>
        </bits>
        <bits name="Wakeup_En" pos="30" access="rw" rst="0">
            <comment>Writing a 1 to enable run tcu wakeup function in lowpower skip frame
                <br/>Writing a 0 to disable 
            </comment>
        </bits>
    </reg>
    <reg name="Wrap_Val" protect="rw">
        <bits name="Wrap_Val" pos="14:0" access="rw" rst="all1" display="hex">
            <comment>TCU counter wrap value.
                <br/>The TCU counter returns to 0 when this value is reached
            </comment>
        </bits>
        <bits name="Sf_Wrap_Val" pos="18:15" access="rw" rst="all1" display="hex">
            <comment>TCU subframe counter wrap value.
                <br/>The TCU subframe counter returns to 0 when this value is reached
            </comment>
        </bits>
    </reg>
    <reg name="Cur_Val" protect="rw">
        <bits name="Cur_Val" pos="14:0" access="r" display="hex" rst="0">
            <comment>TCU counter current value
            </comment>
        </bits>
        <bits name="Cur_Sf" pos="19:16" access="r" display="hex" rst="0">
            <comment>TCU counter current sf value
            </comment>
        </bits>
    </reg>
    <reg name="Latch" protect="rw">
        <bits name="ForceLatch" pos="9:0" access="w" cut="1" cutprefix="ForceLatch_Area" rst="0">
            <comment>Writing 1 transfer the programmed events to the active area.
            </comment>
        </bits>
        <bits name="Force_NoEvent" pos="16" access="w" rst="0">
            <comment>Writing 1 to this bit with one of the ForceLatch bit will force the corresponding Active Area to receive no events (i.e. clear it) instead of transfering the programmed area.
            </comment>
        </bits>
        <bits name="ForceClear" pos="29:20" access="w" cut="1" cutprefix="ForceClear_Area" rst="0">
            <comment>writing 1 to clear the corresponding programmed area.
            </comment>
        </bits>
        <bits name="ClearProgArea" pos="31" access="w" rst="0">
            <comment>Writing 1 clears the Program Area
            </comment>
        </bits>
    </reg>
    <reg name="Setup" protect="rw">
        <bits name="TCO_Polarity" pos="NB_TCO-1:0" access="rw" rst="0" cut="1" cutprefix="POL_TCO">
            <comment>Configure the TCO polarity
            </comment>
            <options>
                <option name="Active High" value="0"/>
                <option name="Active Low" value="1"/>
            </options>
        </bits>
        <bits name="Write_Error" pos="28" access="rc" rst="0">
            <comment>Error Status: become 1 when writing to Program Area while the TCU is coping the Program Area to the Active Area. In this case the write is ignored.
                <br/>Write 1 to clear it.
            </comment>
        </bits>
        <bits name="Debug_Active" pos="31" access="rw" rst="0">
            <comment>This bit allows to access directly the active area for debug purposes
            </comment>
            <options>
                <option name="Normal" value="0"/>
                <option name="Debug" value="1"><comment>the active area is directly mapped instead of the program area.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name="Disable_Event" protect="rw">
        <bits name="Disable_TCO" pos="5:0" access="rw" rst="all1" cut='1' cutprefix="Disable_TCO">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Internal_TCO" pos="11:6" access="rw" rst="all1" cut='1' cutprefix="Disable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Send_Spi_Cmd" pos="12" access="rw" rst="1">
            <comment>Writing 1 disable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Gain" pos="13" access="rw" rst="1">
            <comment>Writing 1 disable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_First_Gain" pos="14" access="rw" rst="1">
            <comment>Writing 1 disable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Next_Fc" pos="15" access="rw" rst="1">
            <comment>Writing 1 disable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Ramp" pos="20:16" access="rw" rst="all1" cut='1' cutprefix="Disable_Ramp">
            <comment>Writing 1 disable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rx_SOC" pos="21" access="rw" rst="1">
            <comment>Writing 1 disable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_DigRF_Strobe" pos="22" access="rw" rst="1">
            <comment>Writing 1 disable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_RfSpi_Start" pos="24" access="rw" rst="1">
            <comment>Writing 1 disable the events RFSPI_START.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_RfSpi_End" pos="25" access="rw" rst="1">
            <comment>Writing 1 disable the events RFSPI_END.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Rf_Spi_Marked_Cmd" pos="31" access="rw" rst="1">
            <comment>Writing 1 disable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>

    <reg name="Disable_Event_ext" protect="rw">
        <bits name="Disable_Bcpu_Irq" pos="1:0" access="rw" rst="all1" cut='1' cutprefix="Disable_Bcpu_Irq">
            <comment>Writing 1 disable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Disable_Xcpu_Irq" pos="17:2" access="rw" rst="all1" cut='1' cutprefix="Disable_Xcpu_Irq">
            <comment>Writing 1 disable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    
    <reg name="Enable_Event" protect="rw">
        <bits name="Enable_TCO" pos="5:0" access="rs" rst="all1" cut='1' cutprefix="Enable_TCO">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Internal_TCO" pos="11:6" access="rs" rst="all1" cut='1' cutprefix="Enable" cutenum="Internal_TCO_mapping">
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Send_Spi_Cmd" pos="12" access="rs" rst="1">
            <comment>Writing 1 enable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Gain" pos="13" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_First_Gain" pos="14" access="rs" rst="1">
            <comment>Writing 1 enable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Next_Fc" pos="15" access="rs" rst="1">
            <comment>Writing 1 enable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Ramp" pos="20:16" access="rs" rst="all1" cut='1' cutprefix="Enable_Ramp">
            <comment>Writing 1 enable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rx_SOC" pos="21" access="rs" rst="1">
            <comment>Writing 1 enable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_DigRF_Strobe" pos="22" access="rs" rst="1">
            <comment>Writing 1 enable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_RfSpi_Start" pos="24" access="rw" rst="1">
            <comment>Writing 1 enable the events RFSPI_START.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_RfSpi_End" pos="25" access="rw" rst="1">
            <comment>Writing 1 enable the events RFSPI_END.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Rf_Spi_Marked_Cmd" pos="31" access="rs" rst="1">
            <comment>Writing 1 enable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>

    <reg name="Enable_Event_ext" protect="rw">
        <bits name="Enable_Bcpu_Irq" pos="1:0" access="rs" rst="all1" cut='1' cutprefix="Enable_Bcpu_Irq">
            <comment>Writing 1 enable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name="Enable_Xcpu_Irq" pos="17:2" access="rs" rst="all1" cut='1' cutprefix="Enable_Xcpu_Irq">
            <comment>Writing 1 enable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>

    <reg name="Set_TCO" protect="rw">
        <bits name="Set_TCO" pos="NB_TCO-1:0" access="s" cut='1' cutprefix="Set_TCO" rst="0">
            <comment>Writing 1 set corresponding TCO to the active state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>
    <reg name="Clr_TCO" protect="rw">
        <bits name="Clr_TCO" pos="NB_TCO-1:0" access="c" cut='1' cutprefix="Clr_TCO" rst="0">
            <comment>Writing 1 set corresponding TCO to the inactive state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>

    <reg name="Cfg_Clk_Div" protect="rw">
        <bits name="Qbit_Div" pos="5:0" access="rw" rst="31">
            <comment>qbit divider, qbit freq is clk_tcu divided by (Qbit_Div + 1).
            </comment>
        </bits>
        <bits name="TCU_Clk_Same_Sys" pos="29" access="rw" rst="0">
            <comment>Enable Clk_TCU same with Clk_Sys.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_DAI_Simple_208K" pos="30" access="rw" rst="0">
            <comment>Enable the 208kHz pulse generation for DAI Simple. (!) When enabling the clock field Enable_Qbit should also be enabled.
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
        <bits name="Enable_Qbit" pos="31" access="rw" rst="0">
            <comment>Enable the Quarter bit generation (required for normal TCU operation)
            </comment>
            <options>
                <option name="Disabled" value="0"/>
                <option name="Enabled" value="1"/>
            </options>
        </bits>
    </reg>
    <reg name="TCU_IRQ" protect="rw">
        <bits name="TCU_Sync_Done_Cause" pos="0" access="rc" rst="0">
            <comment>1 when the IRQ was triggered because the tcu counter synchronization is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="TCU_IRQ_Cause">
            <entry ref="TCU_Sync_Done_Cause"/>
        </bitgroup>

        <bits name="TCU_Sync_Done_Status" pos="16" access="rc" rst="0">
            <comment>1 when the tcu counter synchronization is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name="TCU_IRQ_Status">
            <entry ref="TCU_Sync_Done_Status"/>
        </bitgroup>
    </reg>
    <reg name="TCU_IRQ_Mask" protect="rw">
        <bits name="TCU_Sync_Done_Mask" pos="0" access="rw" rst="0">
            <comment>when 1 the LPS_IRQ_TCU_Sync_Done is enabled.
            </comment>
        </bits>
        <bitgroup name="TCU_IRQ_Mask">
            <entry ref="TCU_Sync_Done_Mask"/>
        </bitgroup>
    </reg>
    <reg name="GLOBAL_SYNC_CTRL" protect="rw">
        <bits name="TCU_Sync_Enable" pos="0" access="rw" rst="0">
            <comment>enable sync tcu counter to global counter function.
            </comment>
        </bits>
        <bits name="TCU_Sync_Value" pos="16:2" access="rw" rst="0">
            <comment>tcu counter load value when synchronized.
            </comment>
        </bits>
        <bits name="TCU_Sync_Sf" pos="20:17" access="rw" rst="0">
            <comment>tcu counter load subframe value when synchronized.
            </comment>
        </bits>
    </reg> 
    <reg name="TCO_DBG_SEL" protect="rw">
        <bits name="tco_dbg0_sel" pos="3:0" access="rw" rst="0">
        </bits>
        <bits name="tco_dbg1_sel" pos="7:4" access="rw" rst="0">
        </bits>
    </reg>
    <reg name="Rfspi_Conflict_Val" protect="rw">
        <bits name="Rfspi_Conflict_Val" pos="13:0" access="r" display="hex" rst="0">
            <comment>TCU counter value when rfspi conflict happen
            </comment>
        </bits>
    </reg>
    <reg name="Snapshot" protect="r">
        <bits name="Snapshot_X" pos="1:0" access="r" rst="0">
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name="Snapshot_B" pos="3:2" access="r" rst="0">
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>
    <reg name="Snapshot_Cfg" protect="rw">
        <bits name="Snapshot_Cfg"  pos="0" access="rw" rst="0">
            <comment>Number of snapshot.
            </comment>
          </bits>
    </reg>
    <reg name="Subframe_Mask" protect="rw">
        <bits name="mask_auto_clr_en" pos="31" access="rw" rst="0">
            <comment>enable subframe mask bits auto clear.
            </comment>
        </bits>
        <bits name="subframe_mask_clr" pos="29:20" access="w" cut="1" cutprefix="clr_subframe_mask" rst="all0">
            <comment>write 1 to clear the corresponding subframe mask bit.
            </comment>
        </bits>
        <bits name="subframe_mask_set" pos="19:10" access="w" cut="1" cutprefix="set_subframe_mask" rst="all0">
            <comment>write 1 to set the corresponding subframe mask bit.
            </comment>
        </bits>
        <bits name="subframe_mask" pos="9:0" access="r" cut="1" cutprefix="subframe_mask" rst="0">
            <comment>subframe mask value.
            </comment>
        </bits>
    </reg>
    <hole size="1408"/>
    <reg name="Event" protect="rw" count="NB_TCU_PROG_EVENTS">
        <bits name="Event_Time" pos="14:0" access="rw" rst="all1">
            <comment>The event Id will be executed when the TCU counter reaches the value programmed in Event time field of this register.
            </comment>
        </bits>
        <bits name="Event_Id" pos="21:16" access="rw" rst="all1">
            <comment>Event to be executed when the TCU counter reaches the programmed event time.
                <br/>
            </comment>
            <options linkenum="TCU_Event">
                <default />
            </options>
        </bits>
    </reg>

</module>

</archive>
<archive relative = "timer.xml">

<module name="timer" category="System">
    <var name = "NB_INTERVAL" value="1"/>
    <var name = "INT_TIMER_NB_BITS" value="24"/>
    <var name = "WD_TIMER_NB_BITS" value="24"/>
    <var name = "HW_TIMER_NB_BITS" value="32"/>
    <var name = "TIM_MAXVAL" value="0xffffff"/>

    <reg name="OSTimer_Ctrl" protect="rw">
        <bits name="LoadVal" pos="23:0" access="rw" rst="0">
            <comment>Value loaded to OS timer.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name="Enable" pos="24" access="rw" rst="0">
            <comment>Write '1' to this bit will enable OS timer.
                <br/>When read, the value is what we have written to this bit, it changes immediately  after been written.
            </comment>
        </bits>
        <bits name="Enabled" pos="25" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
                <br/>
                <br/>'1' indicates OS timer enabled.
                <br/>'0' indicates OS timer not enabled.
            </comment>
        </bits>
        <bits name="Cleared" pos="26" access="r" rst="0">
            <comment>Read this bit will get the information if OS timer interruption clear operation is finished or not.
                <br/>
                <br/>'1' indicates OS timer interruption clear operation is on going.
                <br/>'0' indicates no OS timer interruption clear operation is on going.
            </comment>
        </bits>
        <bits name="Repeat" pos="28" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to repeat mode.
                <br/>When read, get the information if OS timer is in repeat mode.
                <br/>
                <br/>'1' indicates OS timer in repeat mode.
                <br/>'0' indicates OS timer not in repeat mode.
            </comment>
        </bits>
        <bits name="Wrap" pos="29" access="rw" rst="0">
            <comment>Write '1' to this bit will set OS timer to wrap mode.
                <br/>When read, get the information if OS timer is in wrap mode.
                <br/>
                <br/>'1' indicates OS timer in wrap mode.
                <br/>'0' indicates OS timer not in wrap mode.
            </comment>
        </bits>
        <bits name="Load" pos="30" access="rw" rst="0">
            <comment>Write '1' to this bit will load the initial value to OS timer.
            </comment>
        </bits>
    </reg>
    <reg name="OSTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="-">
            <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.
            </comment>
        </bits>
    </reg>
    
    <hole size="2*32" />
    <reg name="HWTimer_Ctrl" protect="rw">
        <bits name="Interval_En" pos="8" access="rw" rst="0">
            <comment>This bit enables interval IRQ mode.
                <br/>
                <br/>'0': hw delay timer does not generate interval IRQ.
                <br/>'1': hw delay timer generate an IRQ each interval.
            </comment>
        </bits>
        <bits name="Interval" pos="1:0" access="rw" rst="00">
            <comment> interval of generating an HwTimer IRQ. 
                <br/>
                <br/>"00": interval of 1/8 second.
                <br/>"01": interval of 1/4 second.
                <br/>"10": interval of 1/2 second.
                <br/>"11": interval of 1 second.
            </comment>
        </bits>
    </reg>
    <reg name="HWTimer_CurVal" protect="rw">
        <bits name="CurVal" pos="31:0" access="r" rst="0">
            <comment>Current value of the hardware delay timer. The value is incremented every 61 us. This timer is running all the time and wrap at value 0xFFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Set" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rs" rst="0">
            <comment>Set mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rs" rst="0">
            <comment>Set mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Mask_Clr" protect="rw">
        <bits name="OSTimer_Mask" pos="0" access="rc" rst="0">
            <comment>Clear mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Mask" pos="1" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Mask" pos="2" access="rc" rst="0">
            <comment>Clear mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Clr" protect="rw">
        <bits name="OSTimer_Clr" pos="0" access="c" rst="0">
            <comment>Clear OS timer IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Clr" pos="1" access="c" rst="0">
            <comment>Clear hardware delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Clr" pos="2" access="c" rst="0">
            <comment>Clear hardware delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name="Timer_Irq_Cause" protect="rw">
        <bits name="OSTimer_Cause" pos="0" access="r" rst="0">
            <comment>OS timer IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Cause" pos="1" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ cause.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Cause" pos="2" access="r" rst="0">
            <comment>hardware delay timer interval IRQ cause.
            </comment>
        </bits>
        <bits name="OSTimer_Status" pos="16" access="r" rst="0">
            <comment>OS timer IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Wrap_Status" pos="17" access="r" rst="0">
            <comment>hardware delay timer wrap IRQ status.
            </comment>
        </bits>
        <bits name="HWTimer_Itv_Status" pos="18" access="r" rst="0">
            <comment>hardware delay timer interval IRQ status.
            </comment>
        </bits>
        <bitgroup name="Other_Tims_irq">
            <entry ref="HWTimer_Wrap_Cause"/>
            <entry ref="HWTimer_Itv_Cause"/>
        </bitgroup>
    </reg>
</module>

</archive>

<archive relative = "uart.xml">
<module name="uart" category="Periph">
  <var  name="UART_RX_FIFO_SIZE"    value="128"  />
  <var  name="UART_TX_FIFO_SIZE"    value="16"  />
  <var  name="NB_RX_FIFO_BITS"      value="7"   />
  <var  name="NB_TX_FIFO_BITS"      value="4"   />

  
  <reg protect="rw" name="ctrl">
    <bits access="rw" name="Enable" pos="0" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Allows to turn off the UART:<br />0 = Disable<br />1 = Enable
      </comment>
    </bits>

    <bits access="rw" name="Data Bits" pos="1" rst="0">
      <options>
        <option name="7_BITS" value="0" />

        <option name="8_BITS" value="1" />

        <default />
      </options>

      <comment>Number of data bits per character (least significant bit
      first):<br />0 = 7 bits<br />1 = 8 bits </comment>
    </bits>

    <bits access="rw" name="Tx Stop Bits" pos="2" rst="0">
      <options>
        <option name="1_BIT" value="0" />

        <option name="2_BITS" value="1" />

        <default />
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br />0 = one stop bit is
      transmitted in the serial data.<br />1 = two stop bits are generated and
      transmitted in the serial data out. </comment>
    </bits>

    <bits access="rw" name="Parity Enable" pos="3" rst="0">
      <options>
        <option name="NO" value="0" />

        <option name="YES" value="1" />

        <default />
      </options>

      <comment> Parity is enabled when this bit is set. </comment>
    </bits>

    <bits access="rw" name="Parity Select" pos="5:4" rst="0">
      <options>
        <option name="ODD" value="0" />

        <option name="EVEN" value="1" />

        <option name="SPACE" value="2" />

        <option name="MARK" value="3" />

        <default />
      </options>

      <comment> Controls the parity format when parity is enabled:<br />00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br />01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br />10 = a space is
      generated and received as parity bit.<br />11 = a mark is generated and
      received as parity bit. </comment>
    </bits>

    <bits access="rw" name="soft flow ctrl enable" pos="6" rst="0">
      <comment> Controls whether enable or disable soft flow ctrl function. <br />0 = disable flow ctrl function 
      <br />1 = enable flow ctrl function </comment>
    </bits>

    <bits access="rw" name="auto_enable" pos="8" rst="0">
      <comment> Controls whether enable or disable auto baud rate function. <br />0 = disable auto baud rate function 
      <br />1 = enable auto baud rate function </comment>
    </bits>


    <bits access="rw" name="Divisor Mode" pos="20:19" rst="2'h1">
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br />0 =
      (BCLK = SCLK / 16)<br />1 = (BCLK = SCLK / 4) <br />2 = (BCLK = SCLK / 3) </comment>
    </bits>

    <bits access="rw" name="IrDA Enable" pos="21" rst="0">
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). </comment>
    </bits>

    <bits access="rw" name="DMA Mode" pos="22" rst="0">
      <options>
        <option name="DISABLE" value="0" />

        <option name="ENABLE" value="1" />

        <default />
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>
    
    <bits access="rw" name="Auto Flow Control" pos="23" rst="0">
      <options>
        <option name="ENABLE" value="1" />
        
        <option name="DISABLE" value="0" />
        
        <default />
      </options>
      <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped. </comment>
    </bits>

    <bits access="rw" name="Loop Back Mode" pos="24" rst="0">
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits access="rw" name="Rx Lock Err" pos="25" rst="0">
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. </comment>
    </bits>

    <bits access="rw" name="Rx Break Length" pos="31:28" rst="0xF">
      <comment>Length of a break, in number of bits. </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="Rx Fifo Level" pos="NB_RX_FIFO_BITS:0" rst="0">
       <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits access="r" name="Tx Fifo space" pos="NB_TX_FIFO_BITS+8:8" rst="5'h10">
        <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of space available in the Tx
      Fifo. </comment>
    </bits>

    <bits access="r" name="at_match_flag" pos="13" rst="0">
      <comment> at_match flag
            <br/> '0' = AT is detected successfully. 
            <br/> '1' = at is detected successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>
    <bits access="r" name="Tx Active" pos="14" rst="0">
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits access="r" name="Rx Active" pos="15" rst="0">
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits access="r" name="Rx Overflow Err" pos="16" rst="0">
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Tx Overflow Err" pos="17" rst="0">
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Parity Err" pos="18" rst="0">
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Framing Err" pos="19" rst="0">
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits access="r" name="Rx Break Int" pos="20" rst="0">
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits access="r" name="character_miscompare" pos="21" rst="0">
      <comment> character miscompare flag
            <br/> '0' = AT or at compare failed. 
            <br/> '1' = AT or at compare successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>

    <bits access="r" name="auto_baud_locked" pos="22" rst="0">
      <comment> auto baud locked flag
            <br/> '0' = baud rate is detected failed. 
            <br/> '1' = baud rate is detected successfully. 
            When auto_enable is 0,this bit is cleared to 0.
       </comment>
    </bits>

    <bits access="r" name="DCTS" pos="24" rst="1">
      <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value. </comment>
    </bits>

    <bits access="r" name="CTS" pos="25" rst="0">
        <comment>current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
      </comment>
    </bits>

    <bits access="r" name="Auto ratio flag" pos="26" rst="0">
      <comment>Auto mode ratio flag.
      </comment>
    </bits>
    
    <bits access="r" name="Mask tx enable flag" pos="27" rst="0">
      <comment>Mask tx enable flag.
      </comment>
    </bits>
    
    <bits access="r" name="DTR" pos="28" rst="0">
      <comment>Current value of the DTR line.
      </comment>
    </bits>
    
    <bits access="r" name="Clk Enabled" pos="31" rst="0">
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
    </bits>
  </reg>

  <reg protect="--" name="rxtx_buffer">
    <bits access="r" name="Rx Data" pos="7:0" rst="no">
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits access="w" name="Tx Data" pos="7:0" rst="no">
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="irq_mask">
    <bits access="rw" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal change detected. </comment>
    </bits>

    <bits access="rw" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits access="rw" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits access="rw" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
        </comment>
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>Rising edge detected on the UART_DTR signal. 
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>Falling edge detected on the UART_DTR signal. 
      </comment>
    </bits>
  
    <bits access="rw" name="Auto Fail" pos="10" rst="0">
      <comment>Auto function fail. 
      </comment>
    </bits>
  
    <bits access="rw" name="Uart dma rx adone" pos="11" rst="0">
      <comment>When rx transfer num equals to transfer threshold, there is a interrupt flag. 
      </comment>
    </bits>
  
    <bits access="rw" name="Uart dma tx adone" pos="12" rst="0">
      <comment>When tx transfer num equals to transfer threshold, there is a interrupt flag. 
      </comment>
    </bits>
  
    <bits access="rw" name="xoff_trig" pos="13" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.
      </comment>
    </bits>
  
    <bits access="rw" name="xon_trig" pos="14" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.
      </comment>
    </bits>
  
    <bits access="rw" name="start_det" pos="15" rst="0">
      <comment>This interrupt is generated when start bit is detected.
      </comment>
    </bits>
  
  </reg>

  <reg protect="rw" name="irq_cause">
    <bits access="r" name="Tx Modem Status" pos="0" rst="0">
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits access="r" name="Rx Data Available" pos="1" rst="0">
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed" pos="2" rst="0">
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits access="r" name="Rx Timeout" pos="3" rst="0">
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits access="r" name="Rx Line Err" pos="4" rst="0">
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits access="rw" name="Tx Dma Done" pos="5" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Done" pos="6" rst="0">
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="Rx Dma Timeout" pos="7" rst="0">
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.
            Reset control: Write one in this register.
        </comment>    
    </bits>

    <bits access="rw" name="DTR RISE" pos="8" rst="0">
      <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits access="rw" name="DTR FALL" pos="9" rst="0">
      <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="Auto Fail" pos="10" rst="0">
      <comment>This interrupt is generated when auto function fail.
      Reset control: Write  0 in auto_enable.
      </comment>
    </bits>
    
    <bits access="rw" name="Uart dma rx adone" pos="11" rst="0">
      <comment>This interrupt is generated when rx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="Uart dma tx adone" pos="12" rst="0">
      <comment>This interrupt is generated when tx transfer num is not less than transfer threshold.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="xoff_trig" pos="13" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xoff.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="xon_trig" pos="14" rst="0">
      <comment>This interrupt is generated when sw flow ctrl is enabled and rx char is xon.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="rw" name="start_det" pos="15" rst="0">
      <comment>This interrupt is generated when start is detected.
      Reset control: Write  1 in this register.
      </comment>
    </bits>
    
    <bits access="r" name="Tx Modem Status U" pos="16" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Data Available U" pos="17" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Data Needed U" pos="18" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Timeout U" pos="19" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Line Err U" pos="20" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Tx Dma Done U" pos="21" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Done U" pos="22" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Rx Dma Timeout U" pos="23" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR RISE U" pos="24" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="DTR FALL U" pos="25" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits access="r" name="Auto fail U" pos="26" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="Uart dma rx adone U" pos="27" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="Uart dma tx adone U" pos="28" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="xoff_trig U" pos="29" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="xon_trig U" pos="30" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
    <bits access="rw" name="start_det U" pos="31" rst="0">
      <comment>Same as previous, not masked. </comment>
    </bits>
    
  </reg>

  <reg protect="rw" name="triggers">
    <bits access="rw" name="Rx Trigger" pos="NB_RX_FIFO_BITS-1:0" rst="0">
      <comment>Defines the empty threshold level at which the Data Available
      Interrupt will be generated. <br />The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits access="rw" name="Tx Trigger" pos="NB_TX_FIFO_BITS-1+8:8" rst="0">
      <comment>Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.<br />The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits access="rw" name="AFC Level" pos="NB_RX_FIFO_BITS-1+16:16" rst="0">
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br />The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Set">
    <bits access="rs" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>
    
    <bits access="rs" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits access="rs" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rs" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rs" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br />1 = the Uart_RTS will be active low (Rx allowed).
        </comment>
    </bits>
    
    <bits access="r" name="Rx Fifo Reset" pos="6" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
    
    <bits access="r" name="Tx Fifo Reset" pos="7" rst="0">
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="CMD_Clr">
    <bits access="rc" name="RI" pos="0" rst="0">
        <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="DCD" pos="1" rst="0">
        <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>

    <bits access="rc" name="DSR" pos="2" rst="0">
        <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits access="rc" name="Tx Break Control" pos="3" rst="0">
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits access="rc" name="Tx Finish n Wait" pos="4" rst="0">
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits access="rc" name="RTS" pos="5" rst="0">
        <comment>Controls the Uart_RTS output.
            <br />0 = the Uart_RTS will be inactive high.
            <br />1 = the Uart_RTS will be active low.
        </comment>
    </bits>
    
  </reg>
  
  <reg protect="r" name="Auto ratio">
    <bits access="r" name="Auto ratio" pos="15:0" rst="0">
        <comment>Auto mode ratio.
        </comment>
    </bits>
  </reg>

  <reg protect="rw" name="XON">
    <bits access="rw" name="XON" pos="7:0" rst="8'h11">
        <comment>XON character value. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="XOFF">
    <bits access="rw" name="XOFF" pos="7:0" rst="8'h13">
        <comment>XOFF character value. </comment>
    </bits>
  </reg>

</module>


</archive>


<archive relative = "vitac.xml">

<include file="globals.xml"/>

<module name="vitac" category="Baseband">
  <reg protect="rw" name="command">
    <bits access="rw" name="start_equ" pos="0" rst="0x0">
      <comment>Writing a '1' in this register triggers a Viterbi Equalization
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="start_dec" pos="1" rst="0x0">
      <comment>Writing a '1' in this register triggers a Viterbi Decoding
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="start_tb" pos="2" rst="0x0">
      <comment>Writing a '1' in this register triggers the TraceBack process.
      Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="int_mask" pos="3" rst="0x0">
      <comment>When this bit is set, it enables the generation of the
      VITAC_DONE_H interrupt. </comment>
    </bits>

    <bits access="rw" name="punctured" pos="4" rst="0x0">
      <comment>Indicates whether a puncturing scheme has to be used during
      decoding. If this bit is set to '0', the code is assumed unpunctured and
      no puncturing matrix is needed. </comment>
    </bits>

    <bits access="rw" name="nb_states" pos="6:5" rst="0x0">
      <comment>This field sets the number of states of the Trellis:
      <br />"00": 16 states <br />"01": 32 states <br />"10": 64 states
      <br />"11": reserved </comment>
    </bits>

    <bits access="rw" name="bkwd_trellis" pos="7" rst="0x0">
      <comment>When this bit is set, the channel symbols are treated in the
      reverse order, i.e. CH_SYMB_ADDR represents the end of the buffer and
      the symbols are read out backward. </comment>
    </bits>

    <bits access="rw" name="code_rate" pos="10:8" rst="0x0">
      <comment>This field sets the convolutional code rate for decoding:
      <br />"010": 1/2 rate <br />"011": 1/3 rate <br />"100": 1/4 rate
      <br />"101": 1/5 rate <br />"110": 1/6 rate <br />others: reserved
      </comment>
    </bits>

    <bits access="rw" name="bm_shift_lev" pos="14:11" rst="0x0">
      <comment>This field sets the amount of shift right applied at the output
      of the equalizer BM calculation: <br />"0000": BM = OUT[30:19]
      <br />"0001": BM = OUT[29:18] <br />... <br />"1111": BM = OUT[15:4]
      </comment>
    </bits>

    <bits access="rw" name="sv_shift_lev" pos="18:15" rst="0x0">
      <comment>This field sets the amount of shift right applied to the
      difference of the two metrics arriving at a node to create a Softvalue:
      <br />"0000": SoftVal = DELTA[15:9] <br />"0001": SoftVal =
      DELTA[14:8] <br />... <br />"1101": SoftVal = DELTA[2:0]&amp;"0000" <br />others:
      reserved </comment>
    </bits>

    <bits access="rw" name="nb_symbols" pos="28:20" rst="0x0">
      <comment>Number of symbols to be Equalized / Decoded. Auto decrement.
      </comment>
    </bits>
  </reg>

  <reg protect="r" name="status">
    <bits access="r" name="equ_pending" pos="0" rst="0x0">
      <comment>This bit is high when an equalization process is ongoing. It
      stays high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="dec pending" pos="1" rst="0x0">
      <comment>This bit is high when an decoding process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="tb_pending" pos="2" rst="0x0">
      <comment>This bit is high when an traceback process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits access="r" name="nb_rescales" pos="7:4" rst="0x0">
      <comment>After a Viterbi process, this field reports the number of
      rescaling operations that have been performed along the trellis.
      <br />This field is reset at every new Viterbi process. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="ch_symb_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the channel symbols buffer in
      SRAM. For Equalization channel symbols are the sampled RF samples
      (2x12-bits packed complex values), and for Decoding channel symbols are
      a frame of softvalues (4x8-bits packed). <br />This address must be
      4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="exp_symb_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>For Equalization, this is the base address of the partial sum
      terms buffer in SRAM. (2x12-bits packed complex values) <br />For
      Decoding, this is the base address of the puncturing matrix. <br />This
      address must be 4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="pm_base_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the base address in SRAM of the Path Metrics buffer.
      The VITAC will read and update PMs according to the scheme given in
      1.2.1.2. (2x16-bits packed values). <br />This address must be 4-bytes
      aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="out_base_addr">
    <bits access="rw" name="addr" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>This is the start address of the output buffer in SRAM. When in
      Equalizer mode, the VITAC will output the calculated Softvalues
      according to the scheme given in 1.2.1.7. When in Decoder mode, the
      VITAC will output the trace words according to the scheme given in
      1.2.2.4. <br />This address must be 4-bytes aligned, bits[1:0] will be
      ignored. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="H0_param">
    <bits access="rw" name="H0_I_part" pos="BB_SYMBOL_SIZE-1:0" rst="0x0">
      <comment>Real part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>

    <bits access="rw" name="H0_Q_part" pos="BB_SYMBOL_SIZE+15:16" rst="0x0">
      <comment>Imaginary part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="HL_param">
    <bits access="rw" name="HL_I_part" pos="BB_SYMBOL_SIZE-1:0" rst="0x0">
      <comment>Real part of the hL parameter of the estimated channel
      response. </comment>
    </bits>

    <bits access="rw" name="HL_Q_part" pos="BB_SYMBOL_SIZE+15:16" rst="0x0">
      <comment>Imaginary part of the hL parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg protect="rw" name="rescale">
    <bits access="rw" name="threshold" pos="15:0" rst="0x0">
      <comment>This field indicates the threshold value to be reach by every
      PMs for triggering a rescale operation. The rescale operation consist in
      subtracting the threshold value to every PMs to avoid overflow during PM
      update. </comment>
    </bits>
  </reg>

  <reg protect="rw" count="3" name="res_poly">
    <comment>This register bank stores the less significant bit of the output
    from the coder for a particular code (see 1.2.2.1). The kth butterfly uses
    the bit k of this register. </comment>

    <bits access="rw" name="res_poly" pos="31:0" rst="0x0">
      <comment>This register stores the less significant bit of the output
      from the coder for a particular code (see 1.2.2.1). The kth butterfly
      uses the bit k of this register. </comment>
    </bits>
  </reg>

  <reg protect="r" name="int_status">
    <bits access="r" name="it_cause" pos="0" rst="0x0">
      <comment>This bit is set when the VITAC module finishes an ongoing
      operation. It can be masked by setting VITAC_CMD(IT_MASK) to '1'.
      <br />Resetting this bit is done by writing in IT_CLEAR register.
      <br />IT_CAUSE is the image of the VITAC_DONE_H interrupt line to the
      CPU. </comment>
    </bits>

    <bits access="r" name="it_status" pos="16" rst="0x0">
      <comment>This bit is the unmasked version of the IT_CAUSE bit.
      </comment>
    </bits>
  </reg>

  <reg protect="w" name="int_clear">
    <bits access="w" name="it_clear" pos="0" rst="0x0">
      <comment>Setting this bit to '1' resets the VITAC interrupt. </comment>
    </bits>
  </reg>
</module>

</archive>
<archive relative="wcn_rf_if.xml">
  <module name="wcn_rf_if" category="BT">
    <reg protect="r" name="revision">
      <bits access="r" name="revision_reserved_0" pos="31:4" rst="2">
      </bits>
      <bits access="r" name="revid" pos="3:0" rst="0">
        <comment>
          Revision ID.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="sys_control">
      <bits access="r" name="sys_control_reserved_0" pos="31:9" rst="19">
      </bits>
      <bits access="rw" name="fm_adc_clk_mode" pos="8:7" rst="2">
        <comment>
          fm adc clock mode.
2'd0:: divider
divider of rfpll
2'd1:: aupll
43.008MHz
2'd2:: adpll
43.008MHz
        </comment>
      </bits>
      <bits access="rw" name="bt_hopping_en" pos="6" rst="1">
        <comment>
          enable bt hopping while channel is muliplier of 26MHz during rx procedure.
If this bit is set to 1'd1, rf_interface will change the ADC clock to 28MHz generated by adpll instead of 26MHz crystal clock to avoid the receiving interference caused by 26MHz adc clock.
        </comment>
      </bits>
      <bits access="rw" name="bt_tune_diff_en" pos="5" rst="1">
        <comment>
          enable BT ARFCN tune diff mode.
If this bit is set to 1'd1, rf_interface will redo the rx/tx procedure (including RFPLL calibration process) if ARFCN changes during one rx/tx procedure.
        </comment>
      </bits>
      <bits access="rw" name="clk_digital_enable_reg" pos="4" rst="0">
        <comment>
          enable all digital clock.
If this bit is set to 1'd1, all digital clocks including gating ones will be forcely on.
        </comment>
      </bits>
      <bits access="rw" name="rf_mode" pos="3:2" rst="2">
        <comment>
          RF mode.
2'd0:: BT
2'd1:: WIFI
2'd2:: FM
        </comment>
      </bits>
      <bits access="rw" name="chip_self_cal_enable" pos="1" rst="0">
        <comment>
          Chip self_cal enable.
Self cal process will be triggered at posedge of chip_self_cal_enable.
        </comment>
      </bits>
      <bits access="rw" name="soft_resetn" pos="0" rst="1">
        <comment>
          soft reset. Active low.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_control">
      <bits access="r" name="bt_control_reserved_0" pos="31:8" rst="20">
      </bits>
      <bits access="rw" name="bt_ch_type" pos="7" rst="1">
        <comment>
          BT channel type.
1'd0:: normal
1'd1:: multiplier
Multiplier of 26MHz. _x000D_
        </comment>
      </bits>
      <bits access="rw" name="bt_arfcn" pos="6:0" rst="7">
        <comment>
          BT Channel number. _x000D_
7'h00 : Channel0 _x000D_
7'h4E : Channel78
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_control">
      <bits access="r" name="wf_control_reserved_0" pos="31:23" rst="0">
      </bits>
      <bits access="rw" name="wf_freq_direct" pos="22:6" rst="15">
        <comment>
          frequency direct reg. u7.10, unit is MHz
        </comment>
      </bits>
      <bits access="rw" name="wf_freq_mode" pos="5" rst="1">
      </bits>
      <bits access="rw" name="wf_chn" pos="4:1" rst="4">
        <comment>
          WIFI channel.
        </comment>
      </bits>
      <bits access="rw" name="wf_tune" pos="0" rst="1">
        <comment>
          Start tune.
WIFI will be started at the posedge of wf_tune.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fm_control">
      <bits access="rw" name="fm_freq_direct" pos="31:16" rst="14">
        <comment>
          frequency direct reg. u6.10, unit is MHz
        </comment>
      </bits>
      <bits access="r" name="fm_control_reserved_0" pos="15" rst="1">
      </bits>
      <bits access="rw" name="fm_band_sel" pos="14:13" rst="2">
        <comment>
          FM band select.
2'd0:: 87_108MHz : (US/Europe)
2'd1:: 76_91MHz : (Japan)
2'd2:: 76_108MHz : (World Wide)
2'd3:: 65_76MHz : (East Europe)
        </comment>
      </bits>
      <bits access="rw" name="fm_freq_mode" pos="12" rst="1">
        <comment>
          FM freq mode.
1'd0:: channel
channel number mode. Channel Freq = 25KHz*fm_chan_reg + bottom freq
1'd1:: direct
direct mode. Channel Freq = bottom freq + fm_freq_direct
        </comment>
      </bits>
      <bits access="rw" name="fm_chan_reg" pos="11:1" rst="9">
        <comment>
          FM channel.
        </comment>
      </bits>
      <bits access="rw" name="fm_tune" pos="0" rst="1">
        <comment>
          Start tune.
FM will be started at the posedge of fm_tune.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="inter_freq_setting">
      <bits access="r" name="inter_freq_setting_reserved_0" pos="31:28" rst="4">
      </bits>
      <bits access="rw" name="fm_imgrej" pos="27" rst="0">
        <comment>
          FM intermediate frequency mode.
1'd0:: positive
1'd1:: negtive
        </comment>
      </bits>
      <bits access="rw" name="fm_if" pos="26:16" rst="128">
        <comment>
          FM intermediate freqeuncy. u1.10. Unit is Mhz. Default is 125KHz. _x000D_
        </comment>
      </bits>
      <bits access="r" name="inter_freq_setting_reserved_1" pos="15:13" rst="3">
      </bits>
      <bits access="rw" name="bt_zif" pos="12" rst="0">
        <comment>
          enable zero intermediate frequency.
1'd0:: use_bt_freq
use intermediate frequency defined by bt_digital_lo_freq;
1'd1:: use_0hz
use 0Hz intermediate frequency.
        </comment>
      </bits>
      <bits access="rw" name="bt_imgrej" pos="11" rst="0">
        <comment>
          BT intermediate frequency mode.
1'd0:: positive
1'd1:: negtive
        </comment>
      </bits>
      <bits access="rw" name="bt_if" pos="10:0" rst="758">
        <comment>
          BT intermediate freqeuncy. u1.10. Unit is Mhz. Default is740KHz.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="ldo_setting">
      <bits access="r" name="ldo_setting_reserved_0" pos="31:2" rst="24">
      </bits>
      <bits access="rw" name="sel_bg" pos="1" rst="1">
      </bits>
      <bits access="rw" name="ivref_bit" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="bt_lna_rmx_setting">
      <bits access="rw" name="bt_rmx_lo_vcom_bit" pos="31:30" rst="1">
      </bits>
      <bits access="rw" name="bt_balun_cap_bit_rx" pos="29:27" rst="3">
      </bits>
      <bits access="rw" name="bt_balun_cap_bit_tx" pos="26:24" rst="3">
      </bits>
      <bits access="rw" name="bt_lna_reg_bit" pos="23:21" rst="3">
      </bits>
      <bits access="rw" name="bt_lna_reg_bypass" pos="20" rst="1">
      </bits>
      <bits access="r" name="bt_lna_rmx_setting_reserved_0" pos="19:17" rst="3">
      </bits>
      <bits access="rw" name="bt_lna_vcas_bit" pos="16:15" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_selfbias_en" pos="14" rst="1">
      </bits>
      <bits access="r" name="bt_lna_rmx_setting_reserved_1" pos="13" rst="1">
      </bits>
      <bits access="rw" name="bt_rmx_i2i_ibit" pos="12:9" rst="4">
      </bits>
      <bits access="rw" name="bt_rmx_lo_ifvcom_sel" pos="8" rst="1">
      </bits>
      <bits access="r" name="bt_lna_rmx_setting_reserved_2" pos="7:4" rst="4">
      </bits>
      <bits access="rw" name="bt_rmx_reg_bit" pos="3:1" rst="3">
      </bits>
      <bits access="rw" name="bt_rmx_reg_bypass" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="fm_lna_rmx_rxflt_setting">
      <bits access="r" name="fm_lna_rmx_rxflt_setting_reserved_0" pos="31:18" rst="12">
      </bits>
      <bits access="rw" name="fm_lna_lv_mode" pos="17" rst="0">
      </bits>
      <bits access="rw" name="fm_lna_ibit" pos="16:14" rst="4">
      </bits>
      <bits access="rw" name="fm_lna_reg_bit" pos="13:11" rst="3">
      </bits>
      <bits access="rw" name="fm_lna_reg_bypass" pos="10" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_harm_rej_en" pos="9" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_lobias_bit" pos="8:7" rst="2">
      </bits>
      <bits access="rw" name="fm_rmx_reg_bit" pos="6:4" rst="3">
      </bits>
      <bits access="rw" name="fm_rmx_reg_bypass" pos="3" rst="1">
      </bits>
      <bits access="rw" name="fm_rxflt_op_ibit" pos="2:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="rxflt_setting">
      <bits access="r" name="rxflt_setting_reserved_0" pos="31:20" rst="10">
      </bits>
      <bits access="rw" name="adc_reg_bypass" pos="19" rst="1">
      </bits>
      <bits access="rw" name="rxflt_rstn_dr" pos="18" rst="1">
      </bits>
      <bits access="rw" name="rxflt_rstn_reg" pos="17" rst="1">
      </bits>
      <bits access="rw" name="rxflt_mode_sel_dr" pos="16" rst="1">
      </bits>
      <bits access="rw" name="rxflt_mode_sel_reg" pos="15:14" rst="2">
      </bits>
      <bits access="rw" name="rxflt_bt_if_ctrl" pos="13:12" rst="2">
      </bits>
      <bits access="rw" name="rxflt_wf_if_ctrl" pos="11:10" rst="2">
      </bits>
      <bits access="rw" name="rxflt_fm_if_ctrl" pos="9:8" rst="2">
      </bits>
      <bits access="rw" name="rxflt_cap_bit" pos="7:4" rst="4">
      </bits>
      <bits access="rw" name="rxflt_op_drv_bit" pos="3:1" rst="3">
      </bits>
      <bits access="rw" name="rxflt_iqswap" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="adc_setting">
      <bits access="rw" name="adc_vcm_sel" pos="31:28" rst="4">
      </bits>
      <bits access="rw" name="adc_comp_power_bit" pos="27" rst="1">
      </bits>
      <bits access="rw" name="adc_clk_xtal_en_dr" pos="26" rst="1">
      </bits>
      <bits access="rw" name="adc_clk_xtal_en_reg" pos="25" rst="1">
      </bits>
      <bits access="rw" name="adc_clk_sel_dr" pos="24" rst="1">
      </bits>
      <bits access="rw" name="adc_clk_sel_reg" pos="23:22" rst="2">
      </bits>
      <bits access="rw" name="adc_clk_edge_sel" pos="21" rst="1">
      </bits>
      <bits access="rw" name="adc_clk_div2" pos="20" rst="1">
      </bits>
      <bits access="rw" name="adc_delay_bit" pos="19:14" rst="6">
      </bits>
      <bits access="rw" name="adc_vref_rbit" pos="13:12" rst="2">
      </bits>
      <bits access="rw" name="adc_vref_vbit" pos="11:10" rst="2">
      </bits>
      <bits access="rw" name="adc_clk_ducy_sel" pos="9:6" rst="4">
      </bits>
      <bits access="rw" name="adc_reg_ibit" pos="5:3" rst="3">
      </bits>
      <bits access="rw" name="adc_reg_rbit" pos="2:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="bt_dac_setting">
      <bits access="r" name="bt_dac_setting_reserved_0" pos="31:6" rst="22">
      </bits>
      <bits access="rw" name="bt_dac_vlow_ctrl_bit" pos="5:3" rst="3">
      </bits>
      <bits access="rw" name="bt_dac_clk_edge" pos="2" rst="1">
      </bits>
      <bits access="rw" name="bt_dac_vtr_sel" pos="1" rst="0">
      </bits>
      <bits access="rw" name="bt_dac_vdd_sel" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="bt_padrv_tmx_setting">
      <bits access="r" name="bt_padrv_tmx_setting_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_delay_padrv" pos="30:23" rst="30">
      </bits>
      <bits access="rw" name="bt_padrv_ibit" pos="22:17" rst="31">
      </bits>
      <bits access="r" name="bt_padrv_tmx_setting_reserved_1" pos="16:12" rst="5">
        <comment>
          bt_tmx_lobias
        </comment>
      </bits>
      <bits access="rw" name="bt_tmx_ibit" pos="11:10" rst="1">
      </bits>
      <bits access="r" name="bt_padrv_tmx_setting_reserved_2" pos="9:6" rst="4">
        <comment>
          bt_tmx_cap_bit
        </comment>
      </bits>
      <bits access="rw" name="bt_tmx_cal_clk_edge" pos="5" rst="1">
      </bits>
      <bits access="rw" name="bt_tmx_pll_test" pos="4" rst="1">
      </bits>
      <bits access="rw" name="bt_tmx_dac_mon_en" pos="3" rst="1">
      </bits>
      <bits access="rw" name="bt_tmx_reg_lodiv_bit" pos="2:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="fm_dsp_setting">
      <bits access="r" name="fm_dsp_setting_reserved_0" pos="31:4" rst="2">
      </bits>
      <bits access="rw" name="fm_dsp_resetn_delay" pos="3:2" rst="2">
      </bits>
      <bits access="rw" name="fm_dsp_resetn_dr" pos="1" rst="1">
      </bits>
      <bits access="rw" name="fm_dsp_resetn_reg" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="vco_setting">
      <bits access="r" name="vco_setting_reserved_0" pos="31:10" rst="18">
      </bits>
      <bits access="rw" name="vco_reg_bypass" pos="9" rst="1">
      </bits>
      <bits access="rw" name="vco_buf_ibit" pos="8:5" rst="1">
      </bits>
      <bits access="rw" name="vco_buf_bias_bit" pos="4:3" rst="1">
      </bits>
      <bits access="rw" name="vco_div2_bias_bit" pos="2:0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_setting0">
      <bits access="rw" name="rfpll_cp_r_bit_tx" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="rfpll_cp_r_bit_rx" pos="29:28" rst="2">
      </bits>
      <bits access="rw" name="rfpll_reg_peri_bit" pos="27:24" rst="4">
      </bits>
      <bits access="rw" name="rfpll_reg_peri_bypass" pos="23" rst="1">
      </bits>
      <bits access="rw" name="rfpll_reg_presc" pos="22:19" rst="8">
      </bits>
      <bits access="rw" name="reset_rfpll_lock_delay" pos="18:17" rst="0">
      </bits>
      <bits access="rw" name="rfpll_refmulti2_en" pos="16" rst="1">
      </bits>
      <bits access="rw" name="rfpll_bypass_notch" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rfpll_peri_dvdd_r_bit" pos="14:11" rst="4">
      </bits>
      <bits access="rw" name="rfpll_div_fm_lo_clk_dr" pos="10" rst="1">
      </bits>
      <bits access="rw" name="rfpll_div_fm_lo_clk_reg" pos="9:6" rst="4">
      </bits>
      <bits access="rw" name="rfpll_div_fm_adc_clk_dr" pos="5" rst="1">
      </bits>
      <bits access="rw" name="rfpll_div_fm_adc_clk_reg" pos="4:0" rst="5">
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_setting1">
      <bits access="rw" name="mdll_div_rx" pos="31:28" rst="2">
      </bits>
      <bits access="rw" name="rfpll_lowpwr_mode" pos="27" rst="1">
      </bits>
      <bits access="rw" name="rfpll_lock_flag_duration" pos="26:25" rst="2">
      </bits>
      <bits access="rw" name="rfpll_gain_bit_rx" pos="24:22" rst="4">
      </bits>
      <bits access="rw" name="rfpll_cp_bit_rx" pos="21:16" rst="3">
      </bits>
      <bits access="rw" name="mdll_div_tx" pos="15:12" rst="2">
      </bits>
      <bits access="rw" name="rfpll_reg_presc_rc" pos="11:9" rst="4">
      </bits>
      <bits access="rw" name="rfpll_gain_bit_tx" pos="8:6" rst="4">
      </bits>
      <bits access="rw" name="rfpll_cp_bit_tx" pos="5:0" rst="3">
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_setting2">
      <bits access="rw" name="rfpll_r_bit_rx" pos="31:27" rst="12">
      </bits>
      <bits access="rw" name="rfpll_lpf_gain_rx" pos="26:22" rst="5">
      </bits>
      <bits access="rw" name="rfpll_pfd_res_bit_rx" pos="21:16" rst="6">
      </bits>
      <bits access="rw" name="rfpll_r_bit_tx" pos="15:11" rst="12">
      </bits>
      <bits access="rw" name="rfpll_lpf_gain_tx" pos="10:6" rst="5">
      </bits>
      <bits access="rw" name="rfpll_pfd_res_bit_tx" pos="5:0" rst="6">
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_status">
      <bits access="r" name="rfpll_status_reserved_0" pos="31:4" rst="2">
      </bits>
      <bits access="rw" name="rfpll_ref_mode_tx" pos="3" rst="1">
      </bits>
      <bits access="rw" name="rfpll_ref_mode_rx" pos="2" rst="1">
      </bits>
      <bits access="r" name="rfpll_lock_flag" pos="1" rst="1">
      </bits>
      <bits access="r" name="rfpll_lock_det" pos="0" rst="0">
        <comment>
          Indicate if rfpll in lock state.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adpll_setting0">
      <bits access="rw" name="adpll_band_sel" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="adpll_lock_flag_duration" pos="29:28" rst="2">
      </bits>
      <bits access="rw" name="adpll_testsig_sel" pos="27:26" rst="2">
      </bits>
      <bits access="rw" name="adpll_vco_high_test" pos="25" rst="1">
      </bits>
      <bits access="rw" name="adpll_vco_low_test" pos="24" rst="1">
      </bits>
      <bits access="rw" name="reset_adpll_lock_delay" pos="23:22" rst="2">
      </bits>
      <bits access="rw" name="adpll_rstn_dr" pos="21" rst="1">
      </bits>
      <bits access="rw" name="adpll_rstn_reg" pos="20" rst="1">
      </bits>
      <bits access="rw" name="adpll_digreg_range" pos="19:16" rst="8">
      </bits>
      <bits access="rw" name="adpll_cp_rbit" pos="15:13" rst="4">
      </bits>
      <bits access="rw" name="adpll_cp_ibit" pos="12:9" rst="8">
      </bits>
      <bits access="rw" name="adpll_cpc2_bit" pos="8:6" rst="4">
      </bits>
      <bits access="rw" name="adpll_cpr2_bit" pos="5:3" rst="4">
      </bits>
      <bits access="rw" name="adpll_refmulti2_en" pos="2" rst="1">
      </bits>
      <bits access="rw" name="adpll_pcon_mode" pos="1" rst="0">
      </bits>
      <bits access="rw" name="adpll_sdm_clk_test_en" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="adpll_setting1">
      <bits access="r" name="adpll_setting1_reserved_0" pos="31:8" rst="20">
      </bits>
      <bits access="rw" name="adpll_clk2bt_adc_en" pos="7" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2bt_dig_en" pos="6" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2fmwf_adc_en" pos="5" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2wf_dig_en" pos="4" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2bt_adc_sel" pos="3" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2bt_dig_sel" pos="2" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2fmwf_adc_sel" pos="1" rst="1">
      </bits>
      <bits access="rw" name="adpll_clk2wf_dig_sel" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="r" name="adpll_status">
      <bits access="r" name="adpll_status_reserved_0" pos="31:2" rst="24">
      </bits>
      <bits access="r" name="adpll_lock_flag" pos="1" rst="0">
      </bits>
      <bits access="r" name="adpll_lock_det" pos="0" rst="0">
        <comment>
          Indicate if pll in lock state.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_sdm_setting0">
      <bits access="r" name="rfpll_sdm_setting0_reserved_0" pos="31:19" rst="11">
      </bits>
      <bits access="rw" name="rfpll_freq_former_shift_ct" pos="18:16" rst="5">
      </bits>
      <bits access="rw" name="rfpll_freq_former_bypass" pos="15" rst="0">
      </bits>
      <bits access="rw" name="rfpll_div_dr" pos="14" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_clk_sel_0" pos="13" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_clk_sel_1" pos="12" rst="1">
      </bits>
      <bits access="rw" name="reset_rfpll_sdm_delay" pos="11:10" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_resetn_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_resetn_reg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_clk_edge" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_int_dec_sel" pos="6:5" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_dither_bypass" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rfpll_sdm_delay_sel" pos="3:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_sdm_setting1">
      <bits access="r" name="rfpll_sdm_setting1_reserved_0" pos="31" rst="0">
      </bits>
      <bits access="rw" name="rfpll_div_reg" pos="30:0" rst="0">
        <comment>
          To be used when rfpll_pll_freq_dr=1._x000D_
Fomula is freq*2^24/(mdll_div*crystal_clk)
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="adpll_sdm_setting0">
      <bits access="r" name="adpll_sdm_setting0_reserved_0" pos="31:13" rst="1">
      </bits>
      <bits access="rw" name="adpll_sdm_freq_dr" pos="12" rst="0">
        <comment>
          If 1, pll frequency is decided by freq register;_x000D_
        </comment>
      </bits>
      <bits access="rw" name="adpll_sdm_clk_sel_0" pos="11" rst="0">
      </bits>
      <bits access="rw" name="adpll_sdm_clk_sel_1" pos="10" rst="1">
      </bits>
      <bits access="rw" name="reset_adpll_sdm_delay" pos="9:8" rst="0">
        <comment>
          Delay time select after txon|rxon|self_cal_en after pll_cal_ready &amp; prescaler_div_ready_x000D_
0:: 1us
1:: 2us
2:: 8us
3:: 16us
        </comment>
      </bits>
      <bits access="rw" name="adpll_sdm_resetn_dr" pos="7" rst="0">
        <comment>
          If 1, adpll sdm resetn uses sdm_resetn_reg; _x000D_
if 0, use logic value.
        </comment>
      </bits>
      <bits access="rw" name="adpll_sdm_resetn_reg" pos="6" rst="0">
        <comment>
          adpll Sdm modulator module reset register
        </comment>
      </bits>
      <bits access="rw" name="adpll_sdm_clk_fbc_inv" pos="5" rst="0">
        <comment>
          Invert SDM clock edge.
        </comment>
      </bits>
      <bits access="rw" name="adpll_sdm_int_dec_sel" pos="4:2" rst="3">
      </bits>
      <bits access="rw" name="adpll_sdm_dither_bypass" pos="1" rst="0">
        <comment>
          SDM dither bypass enable.
        </comment>
      </bits>
      <bits access="rw" name="adpll_sdm_refdiv2_en" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="adpll_sdm_setting1">
      <bits access="rw" name="adpll_sdm_freq_reg" pos="31:0" rst="0">
        <comment>
          To be used when adpll_sdm_freq_dr=1._x000D_
Fomula is freq*2^23/crystal_clk
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rxflt_cal_setting0">
      <bits access="rw" name="wf_rxflt_cal_loop_pol" pos="31" rst="0">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_loop_coef" pos="30:20" rst="1209">
      </bits>
      <bits access="rw" name="rxflt_cal_bit_dr" pos="19" rst="0">
      </bits>
      <bits access="rw" name="rxflt_cal_range_bit" pos="18:16" rst="4">
      </bits>
      <bits access="rw" name="rxflt_cal_mode" pos="15" rst="1">
      </bits>
      <bits access="rw" name="rxflt_cal_clk_edge" pos="14" rst="1">
      </bits>
      <bits access="rw" name="bt_gain_table_full_mode" pos="13" rst="1">
      </bits>
      <bits access="rw" name="wf_gain_table_full_mode" pos="12" rst="1">
      </bits>
      <bits access="rw" name="fm_gain_table_full_mode" pos="11" rst="1">
      </bits>
      <bits access="rw" name="rxflt_cal_clk_edge_sel" pos="10" rst="0">
      </bits>
      <bits access="rw" name="rxflt_cal_mode_sel" pos="9:8" rst="0">
      </bits>
      <bits access="rw" name="rxflt_cal_polarity" pos="7" rst="0">
      </bits>
      <bits access="rw" name="rxflt_cal_iqswap" pos="6" rst="0">
      </bits>
      <bits access="rw" name="rxflt_cal_cnt" pos="5:2" rst="8">
      </bits>
      <bits access="rw" name="rxflt_cal_init_delay" pos="1:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="rxflt_cal_setting1">
      <bits access="r" name="rxflt_cal_setting1_reserved_0" pos="31:26" rst="6">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_loop_adc_rng" pos="25:16" rst="750">
      </bits>
      <bits access="rw" name="rxflt_cal_i_bit_reg" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="rxflt_cal_q_bit_reg" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="r" name="cal_results">
      <bits access="r" name="cal_results_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="r" name="vco_band" pos="29:20" rst="512">
        <comment>
          current vco_band
        </comment>
      </bits>
      <bits access="r" name="vco_ibit" pos="19:16" rst="8">
        <comment>
          current vco_ibit
        </comment>
      </bits>
      <bits access="r" name="rxflt_cal_i_bit" pos="15:8" rst="128">
        <comment>
          current rxflt_cal_i_bit
        </comment>
      </bits>
      <bits access="r" name="rxflt_cal_q_bit" pos="7:0" rst="128">
        <comment>
          current rxflt_cal_q_bit
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="vco_cal_setting">
      <bits access="r" name="vco_cal_setting_reserved_0" pos="31:16" rst="14">
      </bits>
      <bits access="rw" name="vco_ibit_dr" pos="15" rst="0">
        <comment>
          if 1, vco_ibit is triggered by register;
if 0, vco_ibit is triggered by logic.
        </comment>
      </bits>
      <bits access="rw" name="vco_ibit_reg" pos="14:11" rst="8">
      </bits>
      <bits access="rw" name="vco_pkd_ref_bit" pos="10:8" rst="3">
      </bits>
      <bits access="rw" name="vco_pkd_clk_edge" pos="7" rst="1">
        <comment>
          vco_pkd_clk edge selection
        </comment>
      </bits>
      <bits access="rw" name="vco_cal_clk_edge_sel" pos="6" rst="1">
      </bits>
      <bits access="rw" name="vco_cal_mode" pos="5" rst="1">
        <comment>
          vco calibration mode. 1'd1: fast;'1d0:normal
        </comment>
      </bits>
      <bits access="rw" name="vco_cal_cnt" pos="4:3" rst="2">
        <comment>
          if vco_cal_mode=0, define the calibration period.
(vco_cal_cnt+1)*16*(vco_cal_wait_cnt+1)*4us
        </comment>
      </bits>
      <bits access="rw" name="vco_cal_init_delay" pos="2:1" rst="2">
        <comment>
          vco calibration initial delay.
2'd0:4us;2'd1:8us;2'd2:16us;2'd3:32us.
        </comment>
      </bits>
      <bits access="rw" name="vco_cal_polarity" pos="0" rst="1">
        <comment>
          vco_pkd_out polarity
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_setting0">
      <bits access="r" name="rfpll_cal_setting0_reserved_0" pos="31:27" rst="5">
      </bits>
      <bits access="rw" name="rfpll_cal_clk_sel" pos="26" rst="0">
        <comment>
          Select the positive or negative edge of cal clk
        </comment>
      </bits>
      <bits access="rw" name="rfpll_cal_bit" pos="25:24" rst="1">
        <comment>
          Control voltage when in calibration._x000D_
0 :: lowest_x000D_
1 :: medial_01_x000D_
2 :: medial_10
3 :: highest
        </comment>
      </bits>
      <bits access="rw" name="rfpll_open_en" pos="23" rst="0">
        <comment>
          If 1, pll will be open loop.
        </comment>
      </bits>
      <bits access="rw" name="vco_band_dr" pos="22" rst="0">
        <comment>
          Pll_vco_band_reg direct reg enable.
        </comment>
      </bits>
      <bits access="rw" name="vco_band_reg" pos="21:12" rst="512">
        <comment>
          VCO band  setting.
        </comment>
      </bits>
      <bits access="rw" name="rfpll_cal_freq_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="rfpll_cnt_enable_polarity" pos="10" rst="0">
        <comment>
          If 1, change pll_cnt_en edge mode(posedge or negedge of 26mhz clk)
        </comment>
      </bits>
      <bits access="rw" name="rfpll_vco_bit_hold_time" pos="9:7" rst="0">
        <comment>
          Vco bit hold time when vco bit changed during pll vco band calibration._x000D_
3'd0:: vco_bit_hold_time_0 : 0.25us_x000D_
3'd1:: vco_bit_hold_time_1 : 0.5us_x000D_
3'd2:: vco_bit_hold_time_2 : 0.75us_x000D_
3'd3:: vco_bit_hold_time_3 : 1us_x000D_
3'd4:: vco_bit_hold_time_4 : 1.25us_x000D_
3'd5:: vco_bit_hold_time_5 : 1.5us_x000D_
3'd6:: vco_bit_hold_time_6 : 1.75us_x000D_
3'd7:: vco_bit_hold_time_7 : 2us
        </comment>
      </bits>
      <bits access="rw" name="rfpll_cal_opt" pos="6" rst="1">
        <comment>
          If 1, select the best vco band bit
        </comment>
      </bits>
      <bits access="rw" name="rfpll_cal_cnt_sel" pos="5:3" rst="1">
        <comment>
          pll cal count time select_x000D_
3'd0:: each_cnt_time_0 : 0.5us_x000D_
3'd1:: each_cnt_time_1 : 1us_x000D_
3'd2:: each_cnt_time_2 : 2us_x000D_
3'd4:: each_cnt_time_3 : 4us_x000D_
3'd5:: each_cnt_time_4 : 8us
        </comment>
      </bits>
      <bits access="rw" name="rfpll_init_delay" pos="2:0" rst="0">
        <comment>
          Define pll_cal initial delay, which is the  time between RXON(TXON) and rxpll_cal_enable._x000D_ Unit is us.
3'd0:: loop_0
3'd1:: loop_1_x000D_
3'd2::  loop_2_x000D_
3'd3:: loop_3_x000D_
3'd4:: loop_4_x000D_
3'd5:: loop_5_x000D_
3'd6:: loop_6_x000D_
3'd7:: loop_7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="rfpll_cal_setting1">
      <bits access="r" name="rfpll_cal_setting1_reserved_0" pos="31:16" rst="14">
      </bits>
      <bits access="rw" name="rfpll_cal_freq_reg" pos="15:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="cal_dr_setting">
      <bits access="r" name="cal_dr_setting_reserved_0" pos="31:16" rst="14">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_fsm_type" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_fsm_type" pos="13:12" rst="0">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_fsm_resetn_dr" pos="11" rst="0">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_fsm_resetn_reg" pos="10" rst="0">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_fsm_resetn_dr" pos="9" rst="0">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_fsm_resetn_reg" pos="8" rst="0">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_fsm_resetn_dr" pos="7" rst="0">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_fsm_resetn_reg" pos="6" rst="0">
      </bits>
      <bits access="rw" name="vco_cal_resetn_dr" pos="5" rst="0">
      </bits>
      <bits access="rw" name="vco_cal_resetn_reg" pos="4" rst="0">
      </bits>
      <bits access="rw" name="rfpll_cal_resetn_dr" pos="3" rst="0">
      </bits>
      <bits access="rw" name="rfpll_cal_resetn_reg" pos="2" rst="0">
      </bits>
      <bits access="rw" name="self_cal_ready_dr" pos="1" rst="0">
      </bits>
      <bits access="rw" name="self_cal_ready_reg" pos="0" rst="0">
      </bits>
    </reg>
    <reg protect="r" name="cal_status">
      <bits access="r" name="cal_status_reserved_0" pos="31:9" rst="19">
      </bits>
      <bits access="r" name="fm_rxflt_cal_fsm_ready" pos="8" rst="1">
      </bits>
      <bits access="r" name="wf_rxflt_cal_fsm_ready" pos="7" rst="1">
      </bits>
      <bits access="r" name="bt_rxflt_cal_fsm_ready" pos="6" rst="1">
      </bits>
      <bits access="r" name="vco_cal_ready" pos="5" rst="1">
      </bits>
      <bits access="r" name="rfpll_cal_ready" pos="4" rst="1">
      </bits>
      <bits access="r" name="rxflt_cal_ready" pos="3" rst="1">
      </bits>
      <bits access="r" name="fm_self_cal_ready" pos="2" rst="1">
      </bits>
      <bits access="r" name="wf_self_cal_ready" pos="1" rst="1">
      </bits>
      <bits access="r" name="bt_self_cal_ready" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="power_dr">
      <bits access="r" name="power_dr_reserved_0" pos="31:20" rst="10">
      </bits>
      <bits access="rw" name="bt_rmx_i2i_en_dr" pos="19" rst="1">
      </bits>
      <bits access="rw" name="pu_bg_dr" pos="18" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_fm_lna_dr" pos="17" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_fm_rmx_dr" pos="16" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_lna_dr" pos="15" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_rmx_dr" pos="14" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_rxflt_dr" pos="13" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_adc_dr" pos="12" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_dac_dr" pos="11" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_padrv_dr" pos="10" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_tmx_dr" pos="9" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_dr" pos="8" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_txlo_dr" pos="7" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_rxlo_dr" pos="6" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_pkd_dr" pos="5" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_peri_dr" pos="4" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_presc_dr" pos="3" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_fm_lo_clk_dr" pos="2" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_fm_adc_clk_dr" pos="1" rst="1">
        <comment>
          enable direct power control.
If this bit is set to 1'd1, corresponding power is directely controlled by register.
        </comment>
      </bits>
      <bits access="rw" name="pu_adpll_dr" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="rw" name="power_reg">
      <bits access="r" name="power_reg_reserved_0" pos="31:21" rst="9">
      </bits>
      <bits access="rw" name="pu_lvshifter_reg" pos="20" rst="1">
      </bits>
      <bits access="rw" name="bt_rmx_i2i_en_reg" pos="19" rst="1">
      </bits>
      <bits access="rw" name="pu_bg_reg" pos="18" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_fm_lna_reg" pos="17" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_fm_rmx_reg" pos="16" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_lna_reg" pos="15" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_rmx_reg" pos="14" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_rxflt_reg" pos="13" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_adc_reg" pos="12" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_dac_reg" pos="11" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_padrv_reg" pos="10" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_bt_tmx_reg" pos="9" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_reg" pos="8" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_txlo_reg" pos="7" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_rxlo_reg" pos="6" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_vco_pkd_reg" pos="5" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_peri_reg" pos="4" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_presc_reg" pos="3" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_fm_lo_clk_reg" pos="2" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_rfpll_fm_adc_clk_reg" pos="1" rst="1">
        <comment>
          power control direct register.
1'd0: power down; 1'd1: power up.
        </comment>
      </bits>
      <bits access="rw" name="pu_adpll_reg" pos="0" rst="1">
      </bits>
    </reg>
    <reg protect="r" name="power_status">
      <bits access="r" name="power_status_reserved_0" pos="31:20" rst="10">
      </bits>
      <bits access="r" name="bt_rmx_i2i_en" pos="19" rst="1">
      </bits>
      <bits access="r" name="pu_bg" pos="18" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_fm_lna" pos="17" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_fm_rmx" pos="16" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_bt_lna" pos="15" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_bt_rmx" pos="14" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_rxflt" pos="13" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_adc" pos="12" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_bt_dac" pos="11" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_bt_padrv" pos="10" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_bt_tmx" pos="9" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_vco" pos="8" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_vco_txlo" pos="7" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_vco_rxlo" pos="6" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_vco_pkd" pos="5" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_rfpll_peri" pos="4" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_rfpll_presc" pos="3" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_rfpll_fm_lo_clk" pos="2" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_rfpll_fm_adc_clk" pos="1" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
      <bits access="r" name="pu_adpll" pos="0" rst="1">
        <comment>
          power up status.
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_0">
      <bits access="r" name="bt_gain_table_0_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_0" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_0" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_0" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_0" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_0" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_0_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_1" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_1" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_1" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_1" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_1" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_1">
      <bits access="r" name="bt_gain_table_1_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_2" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_2" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_2" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_2" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_2" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_1_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_3" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_3" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_3" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_3" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_3" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_2">
      <bits access="r" name="bt_gain_table_2_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_4" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_4" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_4" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_4" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_4" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_2_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_5" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_5" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_5" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_5" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_5" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_3">
      <bits access="r" name="bt_gain_table_3_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_6" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_6" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_6" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_6" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_6" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_3_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_7" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_7" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_7" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_7" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_7" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_4">
      <bits access="r" name="bt_gain_table_4_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_8" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_8" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_8" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_8" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_8" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_4_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_9" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_9" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_9" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_9" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_9" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_5">
      <bits access="r" name="bt_gain_table_5_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_a" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_a" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_a" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_a" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_a" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_5_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_b" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_b" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_b" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_b" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_b" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=b
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_6">
      <bits access="r" name="bt_gain_table_6_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_c" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_c" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_c" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_c" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_c" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_6_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_d" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_d" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_d" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_d" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_d" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=d
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_gain_table_7">
      <bits access="r" name="bt_gain_table_7_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_lna_gain1_e" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_e" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_e" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_e" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_e" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="bt_gain_table_7_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_gain1_f" pos="13:10" rst="15">
        <comment>
          lna_gain1 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_gain2_f" pos="9:8" rst="3">
        <comment>
          lna_gain2 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="bt_rmx_gain_f" pos="7:4" rst="15">
        <comment>
          rmx_gain when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain1_f" pos="3:2" rst="3">
        <comment>
          filter_gain1 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="bt_rxflt_gain2_f" pos="1:0" rst="3">
        <comment>
          filter_gain2 when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_ibit_table_0">
      <bits access="r" name="bt_ibit_table_0_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_0" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_0" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_0_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_1" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_1" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=1
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_0_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_2" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_2" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_0_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_3" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_3" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_ibit_table_1">
      <bits access="r" name="bt_ibit_table_1_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_4" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_4" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_1_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_5" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_5" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=5
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_1_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_6" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_6" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_1_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_7" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_7" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_ibit_table_2">
      <bits access="r" name="bt_ibit_table_2_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_8" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_8" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_2_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_9" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_9" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=9
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_2_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_a" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_a" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_2_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_b" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_b" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=b
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_ibit_table_3">
      <bits access="r" name="bt_ibit_table_3_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_c" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_c" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_3_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_d" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_d" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=d
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_3_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_e" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_e" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_3_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bt_lna_ibit1_f" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="bt_lna_ibit2_f" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_ibit_table_4">
      <bits access="r" name="bt_ibit_table_4_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_0" pos="30:28" rst="4">
        <comment>
          rx filter op_ibit when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_1" pos="27" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_1" pos="26:24" rst="4">
        <comment>
          rx filter op_ibit when agc_index=1
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_2" pos="23" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_2" pos="22:20" rst="4">
        <comment>
          rx filter op_ibit when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_3" pos="19" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_3" pos="18:16" rst="4">
        <comment>
          rx filter op_ibit when agc_index=3
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_4" pos="15" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_4" pos="14:12" rst="4">
        <comment>
          rx filter op_ibit when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_5" pos="11" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_5" pos="10:8" rst="4">
        <comment>
          rx filter op_ibit when agc_index=5
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_6" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_6" pos="6:4" rst="4">
        <comment>
          rx filter op_ibit when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_4_reserved_7" pos="3" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_7" pos="2:0" rst="4">
        <comment>
          rx filter op_ibit when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_ibit_table_5">
      <bits access="r" name="bt_ibit_table_5_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_8" pos="30:28" rst="4">
        <comment>
          rx filter op_ibit when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_1" pos="27" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_9" pos="26:24" rst="4">
        <comment>
          rx filter op_ibit when agc_index=9
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_2" pos="23" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_a" pos="22:20" rst="4">
        <comment>
          rx filter op_ibit when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_3" pos="19" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_b" pos="18:16" rst="4">
        <comment>
          rx filter op_ibit when agc_index=b
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_4" pos="15" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_c" pos="14:12" rst="4">
        <comment>
          rx filter op_ibit when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_5" pos="11" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_d" pos="10:8" rst="4">
        <comment>
          rx filter op_ibit when agc_index=d
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_6" pos="7" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_e" pos="6:4" rst="4">
        <comment>
          rx filter op_ibit when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="bt_ibit_table_5_reserved_7" pos="3" rst="1">
      </bits>
      <bits access="rw" name="bt_rxflt_op_ibit_f" pos="2:0" rst="4">
        <comment>
          rx filter op_ibit when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_0">
      <bits access="r" name="wf_gain_table_0_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_0" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_0" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_0" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_0" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_0" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_0_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_1" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_1" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_1" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_1" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_1" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=1
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_1">
      <bits access="r" name="wf_gain_table_1_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_2" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_2" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_2" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_2" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_2" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_1_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_3" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_3" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_3" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_3" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_3" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_2">
      <bits access="r" name="wf_gain_table_2_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_4" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_4" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_4" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_4" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_4" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_2_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_5" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_5" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_5" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_5" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_5" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=5
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_3">
      <bits access="r" name="wf_gain_table_3_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_6" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_6" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_6" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_6" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_6" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_3_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_7" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_7" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_7" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_7" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_7" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_4">
      <bits access="r" name="wf_gain_table_4_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_8" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_8" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_8" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_8" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_8" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_4_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_9" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_9" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_9" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_9" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_9" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=9
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_5">
      <bits access="r" name="wf_gain_table_5_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_a" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_a" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_a" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_a" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_a" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_5_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_b" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_b" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_b" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_b" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_b" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=b
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_6">
      <bits access="r" name="wf_gain_table_6_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_c" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_c" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_c" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_c" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_c" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_6_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_d" pos="13:10" rst="4">
        <comment>
          lna_gain1 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_d" pos="9:8" rst="2">
        <comment>
          lna_gain2 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_d" pos="7:4" rst="4">
        <comment>
          rmx_gain when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_d" pos="3:2" rst="2">
        <comment>
          filter_gain1 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_d" pos="1:0" rst="2">
        <comment>
          filter_gain2 when agc_index=d
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_gain_table_7">
      <bits access="r" name="wf_gain_table_7_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="wf_lna_gain1_e" pos="29:26" rst="4">
        <comment>
          lna_gain1 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_e" pos="25:24" rst="2">
        <comment>
          lna_gain2 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_e" pos="23:20" rst="4">
        <comment>
          rmx_gain when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_e" pos="19:18" rst="2">
        <comment>
          filter_gain1 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_e" pos="17:16" rst="2">
        <comment>
          filter_gain2 when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="wf_gain_table_7_reserved_1" pos="15:14" rst="0">
      </bits>
      <bits access="rw" name="wf_lna_gain1_f" pos="13:10" rst="15">
        <comment>
          lna_gain1 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_gain2_f" pos="9:8" rst="3">
        <comment>
          lna_gain2 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="wf_rmx_gain_f" pos="7:4" rst="15">
        <comment>
          rmx_gain when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain1_f" pos="3:2" rst="3">
        <comment>
          filter_gain1 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="wf_rxflt_gain2_f" pos="1:0" rst="3">
        <comment>
          filter_gain2 when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_ibit_table_0">
      <bits access="r" name="wf_ibit_table_0_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_0" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_0" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_0_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_1" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_1" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=1
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_0_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_2" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_2" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_0_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_3" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_3" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_ibit_table_1">
      <bits access="r" name="wf_ibit_table_1_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_4" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_4" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_1_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_5" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_5" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=5
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_1_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_6" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_6" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_1_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_7" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_7" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_ibit_table_2">
      <bits access="r" name="wf_ibit_table_2_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_8" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_8" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_2_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_9" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_9" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=9
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_2_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_a" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_a" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_2_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_b" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_b" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=b
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_ibit_table_3">
      <bits access="r" name="wf_ibit_table_3_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_c" pos="30:28" rst="4">
        <comment>
          lna_ibit1 when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_c" pos="27:24" rst="8">
        <comment>
          lna_ibit2 when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_3_reserved_1" pos="23" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_d" pos="22:20" rst="4">
        <comment>
          lna_ibit1 when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_d" pos="19:16" rst="8">
        <comment>
          lna_ibit2 when agc_index=d
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_3_reserved_2" pos="15" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_e" pos="14:12" rst="4">
        <comment>
          lna_ibit1 when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_e" pos="11:8" rst="8">
        <comment>
          lna_ibit2 when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_3_reserved_3" pos="7" rst="1">
      </bits>
      <bits access="rw" name="wf_lna_ibit1_f" pos="6:4" rst="4">
        <comment>
          lna_ibit1 when agc_index=f
        </comment>
      </bits>
      <bits access="rw" name="wf_lna_ibit2_f" pos="3:0" rst="8">
        <comment>
          lna_ibit2 when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_ibit_table_4">
      <bits access="r" name="wf_ibit_table_4_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_0" pos="30:28" rst="4">
        <comment>
          rx filter op_ibit when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_1" pos="27" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_1" pos="26:24" rst="4">
        <comment>
          rx filter op_ibit when agc_index=1
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_2" pos="23" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_2" pos="22:20" rst="4">
        <comment>
          rx filter op_ibit when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_3" pos="19" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_3" pos="18:16" rst="4">
        <comment>
          rx filter op_ibit when agc_index=3
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_4" pos="15" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_4" pos="14:12" rst="4">
        <comment>
          rx filter op_ibit when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_5" pos="11" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_5" pos="10:8" rst="4">
        <comment>
          rx filter op_ibit when agc_index=5
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_6" pos="7" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_6" pos="6:4" rst="4">
        <comment>
          rx filter op_ibit when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_4_reserved_7" pos="3" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_7" pos="2:0" rst="4">
        <comment>
          rx filter op_ibit when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="wf_ibit_table_5">
      <bits access="r" name="wf_ibit_table_5_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_8" pos="30:28" rst="4">
        <comment>
          rx filter op_ibit when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_1" pos="27" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_9" pos="26:24" rst="4">
        <comment>
          rx filter op_ibit when agc_index=9
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_2" pos="23" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_a" pos="22:20" rst="4">
        <comment>
          rx filter op_ibit when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_3" pos="19" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_b" pos="18:16" rst="4">
        <comment>
          rx filter op_ibit when agc_index=b
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_4" pos="15" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_c" pos="14:12" rst="4">
        <comment>
          rx filter op_ibit when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_5" pos="11" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_d" pos="10:8" rst="4">
        <comment>
          rx filter op_ibit when agc_index=d
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_6" pos="7" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_e" pos="6:4" rst="4">
        <comment>
          rx filter op_ibit when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="wf_ibit_table_5_reserved_7" pos="3" rst="1">
      </bits>
      <bits access="rw" name="wf_rxflt_op_ibit_f" pos="2:0" rst="4">
        <comment>
          rx filter op_ibit when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_padrv_tmx_gain_table_0">
      <bits access="r" name="bt_padrv_tmx_gain_table_0_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_0" pos="29:27" rst="7">
        <comment>
          tmx gain when apc_index=0
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_0" pos="26:24" rst="7">
        <comment>
          padrv gain when apc_index=0
        </comment>
      </bits>
      <bits access="r" name="bt_padrv_tmx_gain_table_0_reserved_1" pos="23:22" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_1" pos="21:19" rst="7">
        <comment>
          tmx gain when apc_index=1
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_1" pos="18:16" rst="7">
        <comment>
          padrv gain when apc_index=1
        </comment>
      </bits>
      <bits access="r" name="bt_padrv_tmx_gain_table_0_reserved_2" pos="15:14" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_2" pos="13:11" rst="7">
        <comment>
          tmx gain when apc_index=2
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_2" pos="10:8" rst="7">
        <comment>
          padrv gain when apc_index=2
        </comment>
      </bits>
      <bits access="r" name="bt_padrv_tmx_gain_table_0_reserved_3" pos="7:6" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_3" pos="5:3" rst="7">
        <comment>
          tmx gain when apc_index=3
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_3" pos="2:0" rst="7">
        <comment>
          padrv gain when apc_index=3
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="bt_padrv_tmx_gain_table_1">
      <bits access="r" name="bt_padrv_tmx_gain_table_1_reserved_0" pos="31:30" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_4" pos="29:27" rst="7">
        <comment>
          tmx gain when apc_index=4
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_4" pos="26:24" rst="7">
        <comment>
          padrv gain when apc_index=4
        </comment>
      </bits>
      <bits access="r" name="bt_padrv_tmx_gain_table_1_reserved_1" pos="23:22" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_5" pos="21:19" rst="7">
        <comment>
          tmx gain when apc_index=5
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_5" pos="18:16" rst="7">
        <comment>
          padrv gain when apc_index=5
        </comment>
      </bits>
      <bits access="r" name="bt_padrv_tmx_gain_table_1_reserved_2" pos="15:14" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_6" pos="13:11" rst="7">
        <comment>
          tmx gain when apc_index=6
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_6" pos="10:8" rst="7">
        <comment>
          padrv gain when apc_index=6
        </comment>
      </bits>
      <bits access="r" name="bt_padrv_tmx_gain_table_1_reserved_3" pos="7:6" rst="2">
      </bits>
      <bits access="rw" name="bt_tmx_gain_7" pos="5:3" rst="7">
        <comment>
          tmx gain when apc_index=7
        </comment>
      </bits>
      <bits access="rw" name="bt_padrv_gain_7" pos="2:0" rst="7">
        <comment>
          padrv gain when apc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fm_lna_gain_table">
      <bits access="rw" name="fm_lna_gain_bit_0" pos="31:30" rst="2">
        <comment>
          fm lna gain bit when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_1" pos="29:28" rst="2">
        <comment>
          fm lna gain bit when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_2" pos="27:26" rst="2">
        <comment>
          fm lna gain bit when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_3" pos="25:24" rst="2">
        <comment>
          fm lna gain bit when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_4" pos="23:22" rst="2">
        <comment>
          fm lna gain bit when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_5" pos="21:20" rst="2">
        <comment>
          fm lna gain bit when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_6" pos="19:18" rst="2">
        <comment>
          fm lna gain bit when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_7" pos="17:16" rst="2">
        <comment>
          fm lna gain bit when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_8" pos="15:14" rst="2">
        <comment>
          fm lna gain bit when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_9" pos="13:12" rst="2">
        <comment>
          fm lna gain bit when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_a" pos="11:10" rst="2">
        <comment>
          fm lna gain bit when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_b" pos="9:8" rst="2">
        <comment>
          fm lna gain bit when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_c" pos="7:6" rst="2">
        <comment>
          fm lna gain bit when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_d" pos="5:4" rst="2">
        <comment>
          fm lna gain bit when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_e" pos="3:2" rst="2">
        <comment>
          fm lna gain bit when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="fm_lna_gain_bit_f" pos="1:0" rst="3">
        <comment>
          fm lna gain bit when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fm_rmx_gain_table_0">
      <bits access="r" name="fm_rmx_gain_table_0_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_0" pos="30:28" rst="3">
        <comment>
          fm mixer gain bit when agc_index=0
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_1" pos="27" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_1" pos="26:24" rst="3">
        <comment>
          fm mixer gain bit when agc_index=1
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_2" pos="23" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_2" pos="22:20" rst="3">
        <comment>
          fm mixer gain bit when agc_index=2
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_3" pos="19" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_3" pos="18:16" rst="3">
        <comment>
          fm mixer gain bit when agc_index=3
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_4" pos="15" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_4" pos="14:12" rst="3">
        <comment>
          fm mixer gain bit when agc_index=4
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_5" pos="11" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_5" pos="10:8" rst="3">
        <comment>
          fm mixer gain bit when agc_index=5
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_6" pos="7" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_6" pos="6:4" rst="3">
        <comment>
          fm mixer gain bit when agc_index=6
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_0_reserved_7" pos="3" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_7" pos="2:0" rst="3">
        <comment>
          fm mixer gain bit when agc_index=7
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fm_rmx_gain_table_1">
      <bits access="r" name="fm_rmx_gain_table_1_reserved_0" pos="31" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_8" pos="30:28" rst="3">
        <comment>
          fm mixer gain bit when agc_index=8
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_1" pos="27" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_9" pos="26:24" rst="3">
        <comment>
          fm mixer gain bit when agc_index=9
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_2" pos="23" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_a" pos="22:20" rst="3">
        <comment>
          fm mixer gain bit when agc_index=a
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_3" pos="19" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_b" pos="18:16" rst="3">
        <comment>
          fm mixer gain bit when agc_index=b
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_4" pos="15" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_c" pos="14:12" rst="3">
        <comment>
          fm mixer gain bit when agc_index=c
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_5" pos="11" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_d" pos="10:8" rst="3">
        <comment>
          fm mixer gain bit when agc_index=d
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_6" pos="7" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_e" pos="6:4" rst="3">
        <comment>
          fm mixer gain bit when agc_index=e
        </comment>
      </bits>
      <bits access="r" name="fm_rmx_gain_table_1_reserved_7" pos="3" rst="1">
      </bits>
      <bits access="rw" name="fm_rmx_gain_bit_f" pos="2:0" rst="7">
        <comment>
          fm mixer gain bit when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_gain_table">
      <bits access="rw" name="fm_rxflt_gain_bit_0" pos="31:30" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=0
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_1" pos="29:28" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=1
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_2" pos="27:26" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=2
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_3" pos="25:24" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=3
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_4" pos="23:22" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=4
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_5" pos="21:20" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=5
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_6" pos="19:18" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=6
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_7" pos="17:16" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=7
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_8" pos="15:14" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=8
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_9" pos="13:12" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=9
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_a" pos="11:10" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=a
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_b" pos="9:8" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=b
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_c" pos="7:6" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=c
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_d" pos="5:4" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=d
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_e" pos="3:2" rst="2">
        <comment>
          fm rxflt gain bit when agc_index=e
        </comment>
      </bits>
      <bits access="rw" name="fm_rxflt_gain_bit_f" pos="1:0" rst="3">
        <comment>
          fm rxflt gain bit when agc_index=f
        </comment>
      </bits>
    </reg>
    <reg protect="rw" name="direct_gain_setting">
      <bits access="r" name="direct_gain_setting_reserved_0" pos="31:21" rst="0">
      </bits>
      <bits access="rw" name="bt_agc_gain_dr" pos="20" rst="0">
      </bits>
      <bits access="rw" name="bt_agc_gain_reg" pos="19:16" rst="15">
      </bits>
      <bits access="r" name="direct_gain_setting_reserved_1" pos="15:13" rst="0">
      </bits>
      <bits access="rw" name="wf_agc_gain_dr" pos="12" rst="0">
      </bits>
      <bits access="rw" name="wf_agc_gain_reg" pos="11:8" rst="15">
      </bits>
      <bits access="r" name="direct_gain_setting_reserved_2" pos="7:5" rst="0">
      </bits>
      <bits access="rw" name="fm_agc_gain_dr" pos="4" rst="0">
      </bits>
      <bits access="rw" name="fm_agc_gain_reg" pos="3:0" rst="15">
      </bits>
    </reg>
    <reg protect="rw" name="channel_setting0">
      <bits access="r" name="channel_setting0_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_cap_bit_lo" pos="15:13" rst="3">
      </bits>
      <bits access="rw" name="bt_rmx_lo_ifvcom_bit_lo" pos="12:9" rst="4">
      </bits>
      <bits access="rw" name="bt_tmx_cap_bit_lo" pos="8:5" rst="7">
      </bits>
      <bits access="rw" name="bt_tmx_lobias_lo" pos="4:0" rst="4">
      </bits>
    </reg>
    <reg protect="rw" name="channel_setting1">
      <bits access="r" name="channel_setting1_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_cap_bit_md" pos="15:13" rst="3">
      </bits>
      <bits access="rw" name="bt_rmx_lo_ifvcom_bit_md" pos="12:9" rst="4">
      </bits>
      <bits access="rw" name="bt_tmx_cap_bit_md" pos="8:5" rst="7">
      </bits>
      <bits access="rw" name="bt_tmx_lobias_md" pos="4:0" rst="4">
      </bits>
    </reg>
    <reg protect="rw" name="channel_setting2">
      <bits access="r" name="channel_setting2_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="bt_lna_cap_bit_hi" pos="15:13" rst="3">
      </bits>
      <bits access="rw" name="bt_rmx_lo_ifvcom_bit_hi" pos="12:9" rst="4">
      </bits>
      <bits access="rw" name="bt_tmx_cap_bit_hi" pos="8:5" rst="7">
      </bits>
      <bits access="rw" name="bt_tmx_lobias_hi" pos="4:0" rst="4">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg0">
      <bits access="rw" name="bt_rxflt_cal_i_bit_0" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_0" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_1" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_1" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg1">
      <bits access="rw" name="bt_rxflt_cal_i_bit_2" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_2" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_3" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_3" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg2">
      <bits access="rw" name="bt_rxflt_cal_i_bit_4" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_4" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_5" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_5" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg3">
      <bits access="rw" name="bt_rxflt_cal_i_bit_6" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_6" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_7" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_7" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg4">
      <bits access="rw" name="bt_rxflt_cal_i_bit_8" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_8" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_9" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_9" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg5">
      <bits access="rw" name="bt_rxflt_cal_i_bit_a" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_a" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_b" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_b" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg6">
      <bits access="rw" name="bt_rxflt_cal_i_bit_c" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_c" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_d" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_d" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg7">
      <bits access="rw" name="bt_rxflt_cal_i_bit_e" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_e" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_f" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_f" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg8">
      <bits access="rw" name="bt_rxflt_cal_i_bit_c_lo" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_c_lo" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_d_lo" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_d_lo" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_reg9">
      <bits access="rw" name="bt_rxflt_cal_i_bit_e_lo" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_e_lo" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_f_lo" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_f_lo" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_rega">
      <bits access="rw" name="bt_rxflt_cal_i_bit_c_hi" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_c_hi" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_d_hi" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_d_hi" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="bt_rxflt_cal_bit_regb">
      <bits access="rw" name="bt_rxflt_cal_i_bit_e_hi" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_e_hi" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_i_bit_f_hi" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_q_bit_f_hi" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg0">
      <bits access="rw" name="wf_rxflt_cal_i_bit_0" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_0" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_1" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_1" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg1">
      <bits access="rw" name="wf_rxflt_cal_i_bit_2" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_2" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_3" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_3" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg2">
      <bits access="rw" name="wf_rxflt_cal_i_bit_4" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_4" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_5" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_5" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg3">
      <bits access="rw" name="wf_rxflt_cal_i_bit_6" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_6" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_7" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_7" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg4">
      <bits access="rw" name="wf_rxflt_cal_i_bit_8" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_8" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_9" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_9" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg5">
      <bits access="rw" name="wf_rxflt_cal_i_bit_a" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_a" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_b" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_b" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg6">
      <bits access="rw" name="wf_rxflt_cal_i_bit_c" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_c" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_d" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_d" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg7">
      <bits access="rw" name="wf_rxflt_cal_i_bit_e" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_e" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_f" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_f" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg8">
      <bits access="rw" name="wf_rxflt_cal_i_bit_c_lo" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_c_lo" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_d_lo" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_d_lo" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_reg9">
      <bits access="rw" name="wf_rxflt_cal_i_bit_e_lo" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_e_lo" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_f_lo" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_f_lo" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_rega">
      <bits access="rw" name="wf_rxflt_cal_i_bit_c_hi" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_c_hi" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_d_hi" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_d_hi" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="wf_rxflt_cal_bit_regb">
      <bits access="rw" name="wf_rxflt_cal_i_bit_e_hi" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_e_hi" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_i_bit_f_hi" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_q_bit_f_hi" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg0">
      <bits access="rw" name="fm_rxflt_cal_i_bit_0" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_0" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_1" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_1" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg1">
      <bits access="rw" name="fm_rxflt_cal_i_bit_2" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_2" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_3" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_3" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg2">
      <bits access="rw" name="fm_rxflt_cal_i_bit_4" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_4" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_5" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_5" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg3">
      <bits access="rw" name="fm_rxflt_cal_i_bit_6" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_6" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_7" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_7" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg4">
      <bits access="rw" name="fm_rxflt_cal_i_bit_8" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_8" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_9" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_9" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg5">
      <bits access="rw" name="fm_rxflt_cal_i_bit_a" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_a" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_b" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_b" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg6">
      <bits access="rw" name="fm_rxflt_cal_i_bit_c" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_c" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_d" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_d" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="fm_rxflt_cal_bit_reg7">
      <bits access="rw" name="fm_rxflt_cal_i_bit_e" pos="31:24" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_e" pos="23:16" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_i_bit_f" pos="15:8" rst="128">
      </bits>
      <bits access="rw" name="fm_rxflt_cal_q_bit_f" pos="7:0" rst="128">
      </bits>
    </reg>
    <reg protect="rw" name="rxflt_cal_setting2">
      <bits access="r" name="rxflt_cal_setting2_reserved_0" pos="31:30" rst="0">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_inter_en" pos="29" rst="0">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_loop_en" pos="28" rst="0">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_inter_en" pos="27" rst="0">
      </bits>
      <bits access="rw" name="wf_chn_md" pos="26:23" rst="7">
      </bits>
      <bits access="rw" name="bt_chn_md" pos="22:16" rst="39">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_inter_coef_lo" pos="15:8" rst="43">
      </bits>
      <bits access="rw" name="wf_rxflt_cal_inter_coef_hi" pos="7:0" rst="43">
      </bits>
    </reg>
    <reg protect="rw" name="rxflt_cal_setting3">
      <bits access="r" name="rxflt_cal_setting3_reserved_0" pos="31" rst="0">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_inter_coef_lo" pos="30:16" rst="840">
      </bits>
      <bits access="r" name="rxflt_cal_setting3_reserved_1" pos="15" rst="0">
      </bits>
      <bits access="rw" name="bt_rxflt_cal_inter_coef_hi" pos="14:0" rst="840">
      </bits>
    </reg>
    <reg protect="rw" name="reserved_reg0">
      <bits access="rw" name="ana_rsvd" pos="31:0" rst="4294901760">
      </bits>
    </reg>
    <reg protect="rw" name="reserved_reg1">
      <bits access="r" name="reserved_reg1_reserved_0" pos="31:16" rst="0">
      </bits>
      <bits access="rw" name="dig_rsvd" pos="15:8" rst="240">
      </bits>
      <bits access="r" name="rf_rsvd_in" pos="7:0" rst="0">
      </bits>
    </reg>
    <reg protect="rw" name="reserved_reg2">
      <bits access="r" name="reserved_reg2_reserved_0" pos="31:24" rst="0">
      </bits>
      <bits access="rw" name="adpll_rsvd" pos="23:16" rst="240">
      </bits>
      <bits access="rw" name="fm_rsvd" pos="15:0" rst="65280">
      </bits>
    </reg>
  </module>
</archive>
<archive relative = "wdt.xml">

<module name="wdt" category="System">

  <reg name="wdt_cvr0" protect="rw">
    <bits access="rw" name="count_value_0" pos="23:0" rst="0xffffff">
      <comment>Count Value for 1st TimeOut
      </comment>
    </bits>
  </reg>

  <reg name="wdt_cvr1" protect="rw">
    <bits access="rw" name="count_value_1" pos="23:0" rst="0xffffff">
      <comment>Count Value for 2nd TimeOut
      </comment>
    </bits>
  </reg>

  <reg name="wdt_cr" protect="rw">
    <bits access="rw" name="mode" pos="4:4" rst="0x1">
      <comment>Watchdog response mode.
          <br/>0 = Generate a system reset.
          <br/>1 = First generate an interrupt and if it is not cleared by the time a second timeout occurs then generate a system reset.
      </comment>
    </bits>
    <bits access="rw" name="reset_length" pos="2:0" rst="0x0">
      <comment>Reset pulse length in number of wdt clock cycles. The range of values available is 1 to 8 clk cycles.
          <br/>3'b000 - 1 clk cycle
          <br/>3'b001 - 2 clk cycles
          <br/>3'b010 - 3 clk cycles
          <br/>...
          <br/>3'b111 - 8 clk cycles
      </comment>
    </bits>
  </reg>

  <reg name="wdt_cmd" protect="rw">
    <bits access="rw" name="cmd" pos="7:0" rst="0x0">
      <comment>This register is used to restart/stop the WDT counter. As a safety feature to prevent accidental restarts/stops, write 8'h76 to restart and 8'h34 to stop.
          <br/>When written is done, this register is self-cleared on the next clock cycle. Reading this register always returns zero.
      </comment>
    </bits>
  </reg>

  <reg name="wdt_icr" protect="rw">
    <bits access="rw" name="int_clr" pos="0:0" rst="0x0">
      <comment>A pulse to clear interrupt.
          <br/>When written is done, this register is self-cleared on the next clock cycle. Reading this register always returns zero.
      </comment>
    </bits>
  </reg>

  <reg name="wdt_sr" protect="r">
    <bits access="r" name="wdt_active" pos="1:1" rst="0x0">
      <comment>This register shows the word status of the WDT.
          <br/>0 = The watchdog counter is idle/stopped.
          <br/>1 = The watchdog counter runs.
      </comment>
    </bits>
    <bits access="r" name="int_assert" pos="0:0" rst="0x0">
      <comment>This register shows the interrupt status of the WDT.
          <br/>0 = Interrupt is inactive.
          <br/>1 = Interrupt asserts.
      </comment>
    </bits>
  </reg>

</module>
</archive>



<archive relative = "xcor.xml">

<include file="globals.xml"/>

<module name="xcor" category="Baseband">
  <var name="XCOR_SYMBOL_SIZE" value="VITAC_MULT_SIZE" />

  <var name="XCOR_SADDER_SIZE" value="XCOR_SYMBOL_SIZE+1 +6" />

  <reg name="command" protect="rw">
    <bits access="rw" name="biterr_en" pos="0" rst="0x0">
      <comment>Enables the Biterror calculation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="dco1p_en" pos="1" rst="0x0">
      <comment>Enables the DC Offset Correction (1st pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="dco2p_en" pos="2" rst="0x0">
      <comment>Enables the DC Offset Correction (2nd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="dco3p_en" pos="3" rst="0x0">
      <comment>Enables the DC Offset Correction (3rd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits access="rw" name="tscxc_en" pos="4" rst="0x0">
      <comment>Enables the Training Sequence Cross-Correlation mode.
      Auto-reset. </comment>
    </bits>

    <bits access="rw" name="srec_en" pos="5" rst="0x0">
      <comment>Enables the Symbol Re-Construction mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="bext_en" pos="6" rst="0x0">
      <comment>Enables the Bit Extraction mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="sproc_en" pos="7" rst="0x0">
      <comment>Enables the Sum Of PROduCt mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="chest_en" pos="8" rst="0x0">
      <comment>Enables the Channel Estimation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="fchxc_en" pos="9" rst="0x0">
      <comment>Enables the FCH Xcorrelation mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="sldwin_en" pos="10" rst="0x0">
      <comment>Enables the Sliding window mode. Auto-reset. </comment>
    </bits>

    <bits access="rw" name="it_mask" pos="11" rst="0x0">
      <comment>Mask of the end of processing interrupt.</comment>
    </bits>

    <bits access="rw" name="pack_IQ" pos="12" rst="0x0">
      <comment>Data path setting. Pack I and Q on a single 32-bits word.
      </comment>
    </bits>

    <bits access="rw" name="derotation_en" pos="13" rst="0x0">
      <comment>Data path setting. Enables derotation for DCOC 3pass.
      </comment>
    </bits>

    <bits access="rw" name="nb_iloop" pos="23:16" rst="0x0">
      <comment>Control setting. Number of internal loop iteration. </comment>
    </bits>

    <bits access="rw" name="nb_symb" pos="31:24" rst="0x0">
      <comment>Control setting. Number of symbols to process. </comment>
    </bits>
  </reg>

  <reg name="status" protect="rw">
    <bits access="r" name="op_pending" pos="0" rst="0x0">
      <comment>This bit is high when an operation is ongoing.</comment>
    </bits>
    <bits access="r" name="it_cause" pos="16" rst="0x0">
      <comment>Masked version of it_status that goes to Interrupt controller.</comment>
    </bits>
    <bits access="rw" name="it_status" pos="31" rst="0x0">
        <comment>This bit is set high when an operation is finished. It must be reset before lauching a new operation if Xcor interrupt is enabled.</comment>
    </bits>
  </reg>

  <reg name="hv0" protect="rw">
    <comment>Multipurpose Data Register. <br /> Store Training Sequence in
    TSXC mode. <br /> Store SUM in DCOC 3rd pass mode. <br /> Store bit
    sequence in SREC mode. <br /> Store SUM in SPROC mode. <br /> Store I SUM
    in CHEST mode. <br /> Store R(k-1) in FCHXC mode. </comment>

    <bits access="rw" name="hv0" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name="hv1" protect="rw">
    <comment>Multipurpose Data Register. <br /> Store Training Sequence in
    TSXC mode. <br /> Store bit sequence in SREC mode. <br /> Store Q SUM in
    CHEST mode. </comment>

    <bits access="rw" name="hv1" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg count="6" name="data" protect="rw">
    <comment>Multipurpose Data Registers. <br />D0 stores
    symbols/softvalues/channel taps depending on mode. Not readable. <br />D1
    stores decoded bits/IQ threshols/IQ Offsets/A terms depending on mode. Not
    readable. <br />D2 (aka A1) serves as Rd address (decoded bits, A or B
    terms) / Wr address register (I or packed IQ results, Symbols) / event
    counter depending on mode. <br />D3 (aka A2) serves as Wr address (Q
    results) / event counter depending on mode. <br />D4 stores results from
    VITAC / extracted HardValues depending on mode. Not readable.<br />D5 (aka
    A3) serves as Wr address (CQ results) Not readable. </comment>

    <bits access="rw" name="data" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name="accuI" protect="r">
    <bits access="r" name="accuI" pos="XCOR_SADDER_SIZE-1:0" rst="0x0">
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name="accuQ" protect="r">
    <bits access="r" name="accuQ" pos="XCOR_SADDER_SIZE-1:0" rst="0x0">
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name="addr0" protect="rw">
    <comment>Address 0 Register. <br />Stores Rd address for symbols /
    SoftValues / A terms depending on mode. <br /> Auto
    increment/decrement/reset. </comment>

    <bits access="rw" name="addr0" pos="BB_SRAM_ADDR_WIDTH+1:2" rst="0x0">
      <comment>32-bit word address (bits 0 and 1 disregarded). </comment>
    </bits>
  </reg>
  
  <reg count="6" name="data_e" protect="rw">
    <comment>Multipurpose Data Edge Registers. </comment>

    <bits access="rw" name="data" pos="31:0" rst="0x0">
      <comment>Multipurpose. </comment>
    </bits>
  </reg>
  
</module>

</archive>

<archive relative = "config.xml">
<include file="globals.xml"/>
  
  
  <var name="SYS_RAM_BASE_FOR_ARM" value="0x00000000"><comment>SYS RAM/ROM base FOR ARM</comment></var>
  <var name="EXT_RAM_BASE_FOR_ARM" value="0x60000000"><comment>PSRAM/FLASH base FOR ARM</comment></var>
  <var name="REG_SYS_APB_BASE_FOR_ARM" value="0x41a00000"><comment>System APB base FOR ARM</comment></var>
  <var name="REG_LP_APB_BASE_FOR_ARM" value="0x41800000"><comment>Low Power APB base FOR ARM</comment></var>
  <var name="REG_CM4_CACHE_BASE_FOR_ARM" value="0x41b00000"><comment>CM4_CACHE base FOR ARM</comment></var>
  <var name="BB_RAM_BASE_FOR_ARM" value="0x20000000"><comment>Baseband RAM/ROM base FOR ARM</comment></var>
  <var name="REG_BB_APB_BASE_FOR_ARM" value="0x41900000"><comment>Baseband APB base FOR ARM</comment></var>
  <var name="RFDIG_RAM_BASE_FOR_ARM" value="0x40000000"><comment>RF_DIG IRAM/DRAM base FOR ARM</comment></var>
  <var name="RFDIG_APB_BASE_FOR_ARM" value="0x41030000"><comment>RF_DIG APB base FOR ARM</comment></var>

  
  
  <instance address="0x00000000" type="debug_host_internal_registers" name="INT_REG_DBG_HOST" />
  

  
  
  <instance address="0x00000000" type="sys_rom" name="SYS_ROM" />

  <instance address="0x00000000" type="sys_rom" name="SYS_ROM" >
      <altaddress name="ARM" address="SYS_RAM_BASE_FOR_ARM + 0x00000000"/>
  </instance>
  <instance address="0x01c00000" type="sys_ram" name="SYS_RAM" >
      <altaddress name="ARM" address="SYS_RAM_BASE_FOR_ARM + 0x01c00000"/>
  </instance>
  <instance address="0x02000000" type="psram" name="PSRAM" >
      <altaddress name="ARM" address="EXT_RAM_BASE_FOR_ARM + 0x02000000"/>
  </instance>
  <instance address="0x02000000" type="psram" name="CS1" >
      <altaddress name="ARM" address="EXT_RAM_BASE_FOR_ARM + 0x02000000"/>
  </instance>
  <instance address="0x08000000" type="flash" name="FLASH" >
      <altaddress name="ARM" address="EXT_RAM_BASE_FOR_ARM + 0x08000000"/>
  </instance>
  <instance address="0x08000000" type="flash" name="CS0" >
      <altaddress name="ARM" address="EXT_RAM_BASE_FOR_ARM + 0x08000000"/>
  </instance>
  <instance address="0x01b00000" type="cm4_cache" name="CM4_ICACHE" >
      <altaddress name="ARM" address="REG_CM4_CACHE_BASE_FOR_ARM + 0x00000000"/>
  </instance>
  <instance address="0x01b20000" type="cm4_cache" name="CM4_DCACHE" >
      <altaddress name="ARM" address="REG_CM4_CACHE_BASE_FOR_ARM + 0x00020000"/>
  </instance>
  <instance address="0x01a60000" type="ble_link" name="BLE_LINK" >
      <altaddress name="ARM" address="0x41a60000"/>
  </instance>

  
  <var name="REG_SYS_APB_BASE" value="0x01a00000"><comment>System APB base</comment></var>

  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI1" type="spi" name="SPI1" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_SPI1"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI2" type="spi" name="SPI2" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_SPI2"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART1" type="uart" name="UART1" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_UART1"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART2" type="uart" name="UART2" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_UART2"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART3" type="uart" name="UART3" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_UART3"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SDMMC2" type="sdmmc2" name="SDMMC2" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_SDMMC2"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2S" type="i2s" name="I2S" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_I2S"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IFC" type="sys_ifc" name="SYS_IFC" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_IFC"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GPT1" type="gpt" name="GPT1" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_GPT1"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GPT2" type="gpt" name="GPT2" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_GPT2"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_KEYPAD" type="keypad" name="KEYPAD" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_KEYPAD"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SEG_LCD" type="seg_lcd" name="SEG_LCD" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_SEG_LCD"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C1" type="i2c_master" name="I2C1" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_I2C1"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C2" type="i2c_master" name="I2C2" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_I2C2"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C3" type="i2c_master" name="I2C3" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_I2C3"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DMA" type="dma" name="SYS_DMA" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_DMA"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_MAILBOX" type="mailbox" name="MAILBOX" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_MAILBOX"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CTRL" type="mcu_ctrl" name="MCU_CTRL" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_CTRL"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_WDT" type="wdt" name="SYS_WDT" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_WDT"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_LZMA" type="lzma" name="LZMA" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_LZMA"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_BT_DBM" type="dbm" name="BT_DBM" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_BT_DBM"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_BT_MODEM" type="bt_modem" name="BT_MODEM" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_BT_MODEM"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_BT_CORE" type="bt_core" name="BT_CORE" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_BT_CORE"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_WCN_RF_IF" type="wcn_rf_if" name="WCN_RF_IF" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_WCN_RF_IF"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PAGE_SPY" type="page_spy" name="MCU_PAGE_SPY" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_PAGE_SPY"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPIFLASH" type="spi_flash" name="SPI_FLASH" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_SPIFLASH"/>
  </instance>
  <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_AES" type="aes_dma" name="AES_DMA" >
      <altaddress name="ARM" address="REG_SYS_APB_BASE_FOR_ARM + SYS_APB_STEP * SYS_ID_AES"/>
  </instance>

  
  <var name="REG_LP_APB_BASE" value="0x01800000"><comment>Low Power APB base</comment></var>

  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_CTRL" type="sys_ctrl" name="SYS_CTRL" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_CTRL"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_TIMER" type="timer" name="LP_TIMER" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_TIMER"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_GPIO" type="gpio" name="GPIO" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_GPIO"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_IOMUX" type="iomux" name="IOMUX" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_IOMUX"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_PSRAM8_CTRL" type="psram8_ctrl" name="PSRAM8_CTRL" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_PSRAM8_CTRL"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_BT_AON" type="aon_sleep" name="BT_AON" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_BT_AON"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_PMUC" type="pmuc" name="PMUC" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_PMUC"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_RTC" type="calendar" name="CALENDAR" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_RTC"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_LPUART" type="uart" name="LPUART" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_LPUART"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_GSM_LPS" type="lps" name="GSM_LPS" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_GSM_LPS"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_NB_LPS" type="lps" name="NB_LPS" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_NB_LPS"/>
  </instance>
  <instance address="REG_LP_APB_BASE + LP_APB_STEP * LP_ID_WDT" type="wdt" name="AON_WDT" >
      <altaddress name="ARM" address="REG_LP_APB_BASE_FOR_ARM + LP_APB_STEP * LP_ID_WDT"/>
  </instance>

  
  
  <instance address="0x01e00000" type="bb_rom" name="BB_ROM" >
      <altaddress name="ARM" address="BB_RAM_BASE_FOR_ARM + 0x01e00000"/>
  </instance>
  <instance address="0x01d00000" type="bb2g_ram" name="BB2G_RAM" >
      <altaddress name="ARM" address="BB_RAM_BASE_FOR_ARM + 0x01d00000"/>
  </instance>

  
  <var name="REG_BB_APB_BASE" value="0x01900000"><comment>Baseband APB base</comment></var>

  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_SCI1" type="sci" name="SCI1">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_SCI1"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_SCI2" type="sci" name="SCI2">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_SCI2"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_DEBUG_UART" type="debug_uart" name="DEBUG_UART" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_DEBUG_UART"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_GSM_RFSPI" type="rf_spi" name="GSM_RF_SPI">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_GSM_RFSPI"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_NB_RFSPI" type="rf_spi" name="NB_RF_SPI">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_NB_RFSPI"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_GSM_TCU" type="tcu" name="GSM_TCU" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_GSM_TCU"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_NB_TCU" type="tcu" name="NB_TCU" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_NB_TCU"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CTRL" type="bb_ctrl" name="BB_CTRL" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_CTRL"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF_IF" type="rf_if" name="RF_IF" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_RF_IF"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_ROM_CTRL" type="bb_rom_ctrl" name="BB_ROM_CTRL" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_ROM_CTRL"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IRQ" type="bb_irq" name="BB_IRQ" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_IRQ"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_DMA" type="dma" name="BB_DMA" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_DMA"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_WDT" type="wdt" name="BB_WDT" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_WDT"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_TIMER" type="timer" name="BB_TIMER" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_TIMER"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IFC" type="bb_ifc" name="BB_IFC" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_IFC"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_DEBUG_HOST" type="debug_host" name="DEBUG_HOST" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_DEBUG_HOST"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_XCOR" type="xcor" name="XCOR" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_XCOR"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CORDIC" type="cordic" name="CORDIC" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_CORDIC"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_ITLV" type="itlv" name="ITLV" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_ITLV"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_VITAC" type="vitac" name="VITAC" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_VITAC"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_EXCOR" type="excor" name="EXCOR" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_EXCOR"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CHOLK" type="cholk" name="CHOLK" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_CHOLK"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CIPHER" type="cipher" name="CIPHER" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_CIPHER"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_PAGE_SPY" type="page_spy" name="BB_PAGE_SPY" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_PAGE_SPY"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_CTRL" type="nb_ctrl" name="NB_CTRL" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_CTRL"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_COMMON" type="nb_common" name="NB_COMMON" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_COMMON"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_INTC" type="nb_intc" name="NB_INTC" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_INTC"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_CS" type="nb_cell_search" name="NB_CS" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_CS"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT" type="nb_fft_rsrp" name="NB_FFT_RSRP" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_FFT"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT + 0x100" type="NBIOT_MULTI_CA_FFT" name="NBIOT_MULTI_CA_FFT" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_FFT + 0x100"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT + 0x200" type="nb_ca_rx_dump" name="NB_CA_RX_DUMP" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_FFT + 0x200"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_FFT + 0x400" type="nb_acc" name="NB_ACC" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_FFT + 0x400"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_VITERBI" type="nb_viterbi" name="NB_VITERBI" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_VITERBI"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_MEAS" type="nb_meas" name="NB_MEAS" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_MEAS"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_DS_BSEL" type="nb_ds_bsel" name="NB_DS_BSEL" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_DS_BSEL"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_PUSCH" type="nb_tx_pusch_encoder" name="NB_TX_PUSCH" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_TX_PUSCH"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_CHSC" type="nb_tx_chsc" name="NB_TX_CHSC" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_TX_CHSC"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_FE" type="nb_tx_frontend" name="NB_TX_FRONTEND" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_TX_FE"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_FE + 0x200" type="nb_ca_tx_dump" name="NB_CA_TX_DUMP" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_TX_FE + 0x200"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * NB_ID_TX_FE + 0x400" type="NBIOT_MULTI_CA_IFFT" name="NBIOT_MULTI_CA_IFFT" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * NB_ID_TX_FE + 0x400"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF_INTERFACE" type="rf_interface" name="RF_INTERFACE">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_RF_INTERFACE"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_DFE" type="dfe" name="DFE">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_DFE"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RFFE" type="rf_dig_rffe" name="RFFE">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_RFFE"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_ADI2CA_IF" type="adi2ca_if" name="ADI2CA_IF">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_ADI2CA_IF"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CA" type="ca" name="CA">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_CA"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_A53" type="cipher_a53" name="CIPHER_A53" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_A53"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_GEA3" type="gea3" name="GEA3">
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_GEA3"/>
  </instance>
  <instance address="REG_BB_APB_BASE + BB_APB_STEP * BB_ID_F8" type="cipher_f8" name="CIPHER_F8" >
      <altaddress name="ARM" address="REG_BB_APB_BASE_FOR_ARM + BB_APB_STEP * BB_ID_F8"/>
  </instance>


</archive>

</bigarchive>
